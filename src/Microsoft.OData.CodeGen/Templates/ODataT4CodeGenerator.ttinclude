<#
/*
//---------------------------------------------------------------------------------
// <copyright file="ODataT4CodeGenerator.ttinclude" company=".NET Foundation">
//      Copyright (c) .NET Foundation and Contributors.  All rights reserved.
//      See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------------------
*/
#>
<#@ template debug="true" hostSpecific="true" visibility="internal" linePragmas="false"#>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Runtime.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Xml.ReaderWriter.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ Assembly Name="Microsoft.OData.Edm.dll" #>
<#@ Import Namespace="System" #>
<#@ Import Namespace="System.IO" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ Import Namespace="System.Globalization" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Xml"#>
<#@ Import Namespace="System.Xml.Linq" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="Microsoft.OData.Edm.Csdl" #>
<#@ Import Namespace="Microsoft.OData.Edm" #>
<#@ Import Namespace="Microsoft.OData.Edm.Validation" #>
<#@ Import Namespace="Microsoft.OData.Edm.Vocabularies" #>
<#@ Import Namespace="Microsoft.OData.Edm.Vocabularies.V1" #>
<#@ Import Namespace="Microsoft.OData.Edm.Vocabularies.Community.V1" #>
<#@ Import Namespace="Microsoft.OData.CodeGen.FileHandling" #>
<#@ Import Namespace="Microsoft.OData.CodeGen.Logging" #>
<#@ Import Namespace="System.Text"#>
<#@ Import Namespace="System.Net"#>
<#@include file="ODataT4CodeGenFilesManager.ttinclude"
#><#
    CodeGenerationContext context;
    if (!string.IsNullOrWhiteSpace(this.Edmx))
    {
        context = new CodeGenerationContext(this.Edmx, this.NamespacePrefix)
        {
            UseDataServiceCollection = this.UseDataServiceCollection,
            TargetLanguage = this.TargetLanguage,
            EnableNamingAlias = this.EnableNamingAlias,
            IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
            MetadataFilePath = this.MetadataFilePath,
            MetadataFileRelativePath = this.MetadataFileRelativePath,
            MakeTypesInternal = this.MakeTypesInternal,
            MultipleFilesManager = new FilesManager(null),
            GenerateMultipleFiles = this.GenerateMultipleFiles,
            ExcludedOperationImports = this.ExcludedOperationImports,
            ExcludedBoundOperations = this.ExcludedBoundOperations,
            ExcludedSchemaTypes = this.ExcludedSchemaTypes,
            EmitContainerPropertyAttribute = this.EmitContainerPropertyAttribute
        };
    }
    else
    {
        this.ApplyParametersFromCommandLine();
        if (string.IsNullOrEmpty(metadataDocumentUri))
        {
            this.ApplyParametersFromConfigurationClass();
        }

        WebProxy proxy = null;
        if(this.IncludeWebProxy)
        {
            proxy = new WebProxy(this.WebProxyHost,true);

            if(this.IncludeWebProxyNetworkCredentials)
            {
               NetworkCredential  credentials = new NetworkCredential(this.WebProxyNetworkCredentialsUsername,
               this.WebProxyNetworkCredentialsPassword,
               this.WebProxyNetworkCredentialsDomain);
               proxy.Credentials = credentials;
            }

        }

        context = new CodeGenerationContext(new Uri(this.MetadataDocumentUri, UriKind.Absolute), this.NamespacePrefix, proxy, this.CustomHttpHeaders)
        {
            UseDataServiceCollection = this.UseDataServiceCollection,
            TargetLanguage = this.TargetLanguage,
            EnableNamingAlias = this.EnableNamingAlias,
            IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
            MetadataFilePath = this.MetadataFilePath,
            MetadataFileRelativePath = this.MetadataFileRelativePath,
            MakeTypesInternal = this.MakeTypesInternal,
            MultipleFilesManager = new FilesManager(null),
            GenerateMultipleFiles = this.GenerateMultipleFiles,
            ExcludedOperationImports = this.ExcludedOperationImports,
            ExcludedBoundOperations = this.ExcludedBoundOperations,
            ExcludedSchemaTypes = this.ExcludedSchemaTypes,
            EmitContainerPropertyAttribute = this.EmitContainerPropertyAttribute
        };
    }

     this.MultipleFilesManager = context.MultipleFilesManager;

    if(this.GetReferencedModelReaderFunc != null)
    {
        context.GetReferencedModelReaderFunc = this.GetReferencedModelReaderFunc;
    }

    ODataClientTemplate template;
    switch(this.TargetLanguage)
    {
        case LanguageOption.CSharp:
            template = new ODataClientCSharpTemplate(context);
            break;
        case LanguageOption.VB:
            template = new ODataClientVBTemplate(context);
            break;

        default:
            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, "Code gen for the target language '{0}' is not supported.", this.TargetLanguage.ToString()));
    }

#><#=template.TransformText()#><#
    foreach (string warning in context.Warnings)
    {
        this.Warning(warning);
    }
#><#+
/// <summary>
/// The string for the edmx content.
/// </summary>
public string Edmx
{
    get;
    set;
}

/// <summary>
/// The Uri string to the metadata document.
/// </summary>
public string MetadataDocumentUri
{
    get
    {
        return this.metadataDocumentUri;
    }

    set
    {
        value = Uri.UnescapeDataString(value);
        Uri uri;
        if (!Uri.TryCreate(value, UriKind.Absolute, out uri))
        {
            // ********************************************************************************************************
            // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
            // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
            // value then hit Ctrl-S to save the .tt file to refresh the code generation.
            // ********************************************************************************************************
            throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" is not a valid MetadataDocumentUri because is it not a valid absolute Uri. The MetadataDocumentUri must be set to an absolute Uri referencing the $metadata endpoint of an OData service.", value));
        }

        if (uri.Scheme == "http" || uri.Scheme == "https")
        {
            value = uri.Scheme + "://" + uri.Authority + uri.AbsolutePath;
            value = value.TrimEnd('/');
            if (!value.EndsWith("$metadata"))
            {
                value += "/$metadata";
            }
        }

        this.metadataDocumentUri = value;
    }
}

private string metadataDocumentUri;

/// <summary>
/// The Func to get referenced model's XmlReader. Must have value when the this.Edmx xml or this.metadataDocumentUri's model has referneced model.
/// </summary>
public Func<Uri, WebProxy, IList<string>, XmlReader> GetReferencedModelReaderFunc
{
    get;
    set;
}

/// <summary>
/// The NamespacePrefix is used as the only namespace for types in the same namespace as the default container,
/// and as a prefix for the namespace from the model for everything else. If this argument is null, the
/// namespaces from the model are used for all types.
/// </summary>
public string NamespacePrefix
{
    get
    {
        return this.namespacePrefix;
    }

    set
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            this.namespacePrefix = null;
        }
        else
        {
            this.namespacePrefix = value;
        }
    }
}

private string namespacePrefix;

/// <summary>
/// true to use DataServiceCollection in the generated code, false otherwise.
/// </summary>
public bool UseDataServiceCollection
{
    get;
    set;
}

/// <summary>
/// Specifies which specific .Net Framework language the generated code will target.
/// </summary>
public LanguageOption TargetLanguage
{
    get;
    set;
}

/// <summary>
/// true to use Upper camel case for all class and property names, false otherwise.
/// </summary>
public bool EnableNamingAlias
{
    get;
    set;
}

/// <summary>
/// true to ignore unknown elements or attributes in metadata, false otherwise.
/// </summary>
public bool IgnoreUnexpectedElementsAndAttributes
{
    get;
    set;
}

/// <summary>
/// true to use the "internal" access modifier ("Friend" in VB) on generated types,
/// otherwise "public" is used
/// </summary>
public bool MakeTypesInternal
{
    get;
    set;
}

private IEnumerable<string> excludedOperationImports = new List<string>();

/// <summary>
/// list of operation imports to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedOperationImports
{
    get
    {
        return excludedOperationImports;
    }

    set
    {
        excludedOperationImports = value;
    }
}

private IEnumerable<string> excludedBoundOperations = new List<string>();

/// <summary>
/// list of bound operations to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedBoundOperations
{
    get
    {
        return excludedBoundOperations;
    }

    set
    {
        excludedBoundOperations = value;
    }
}

private IEnumerable<string> excludedSchemaTypes = new List<string>();

/// <summary>
/// List of entity types to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedSchemaTypes
{
    get
    {
        return excludedSchemaTypes;
    }

    set
    {
        excludedSchemaTypes = value;
    }
}

/// <summary>
/// The path for the file where the metadata xml document can be stored.
/// </summary>
public string MetadataFilePath
{
    get;
    set;
}

/// <summary>
/// The relative path for the file where the metadata xml document can be stored.
/// </summary>
public string MetadataFileRelativePath
{
    get;
    set;
}

/// <summary>
/// Object instance of a file manager responsible for splitting generating multiple files.
/// </summary>
public FilesManager MultipleFilesManager
{
    get;
    set;
}

/// <summary>
/// The web proxy host address
/// </summary>
public string WebProxyHost
{
    get;
    set;
}

/// <summary>
/// true to generate multiple files, false generate a single file.
/// </summary>
public bool GenerateMultipleFiles
{
    get;
    set;
}
/// <summary>
/// Boolean to show if we should include the web proxy
/// </summary>
public bool IncludeWebProxy
{
    get;
    set;
}

/// <summary>
/// Boolean to show if we should include the web proxy network credentials
/// </summary>
public bool IncludeWebProxyNetworkCredentials
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials domain
/// </summary>
public string WebProxyNetworkCredentialsDomain
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials username
/// </summary>
public string WebProxyNetworkCredentialsUsername
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials password
/// </summary>
public string WebProxyNetworkCredentialsPassword
{
    get;
    set;
}

/// <summary>
/// true to emit container property attribute on dynamic property container, false otherwise
/// </summary>
public bool EmitContainerPropertyAttribute
{
    get;
    internal set;
}

/// <summary>
/// Generate code targeting a specific .Net Framework language.
/// </summary>
public enum LanguageOption
{
    /// <summary>Generate code for C# language.</summary>
    CSharp = 0,

    /// <summary>Generate code for Visual Basic language.</summary>
    VB = 1,
}

/// <summary>
/// Stores Custom Http Headers to be added to the WebRequest.Headers property.
/// </summary>
public virtual IList<string> CustomHttpHeaders
{
    get;
    set;
}

/// <summary>
/// Set the UseDataServiceCollection property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetUseDataServiceCollectionFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the UseDataServiceCollection parameter because it is not a valid boolean value.", inputValue));
    }

    this.UseDataServiceCollection = boolValue;
}

/// <summary>
/// Tries to set the TargetLanguage property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetTargetLanguageFromString(string inputValue)
{
    LanguageOption option;
    if (!Enum.TryParse(inputValue, true, out option))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the TargetLanguage parameter because it is not a valid LanguageOption. The supported LanguageOptions are \"CSharp\" and \"VB\".", inputValue));
    }

    this.TargetLanguage = option;
}

/// <summary>
/// Set the EnableNamingAlias property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetEnableNamingAliasFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the EnableNamingAlias parameter because it is not a valid boolean value.", inputValue));
    }

    this.EnableNamingAlias = boolValue;
}

/// <summary>
/// Set the IgnoreUnexpectedElementsAndAttributes property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the IgnoreUnexpectedElementsAndAttributes parameter because it is not a valid boolean value.", inputValue));
    }

    this.IgnoreUnexpectedElementsAndAttributes = boolValue;
}

/// <summary>
/// Set the MakeTypesInternal property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetMakeTypesInternalFromString(string inputValue)
{
    bool parsedValue;
    if (!bool.TryParse(inputValue, out parsedValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the MakeTypesInternal parameter because it is not a valid boolean value.", inputValue));
    }

    this.MakeTypesInternal = parsedValue;
}

/// <summary>
/// Validate the supplied custom http header string.
/// </summary>
/// <param name="header">Custom http header string.</param>
public void ValidateCustomHttpHeaderString(string header)
{
    if (!header.Contains(':'))
    {
        throw new ArgumentException("A http header string must have a colon delimeter");
    }
}

/// <summary>
/// Set the CustomHttpHeaders property using supplied custom http headers string.
/// </summary>
/// <param name="headersValue">Custom http headers string.</param>
public void SetCustomHttpHeadersFromString(string headersValue)
{
    if (String.IsNullOrWhiteSpace(headersValue))
    {
        return;
    }

    this.CustomHttpHeaders = new List<string>();

    string[] headerElements = headersValue.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
    foreach (var headerElement in headerElements)
    {
        // Trim header for empty spaces
        var header = headerElement.Trim();
        ValidateCustomHttpHeaderString(header);
        CustomHttpHeaders.Add(header);
    }
}

/// Set the ExcludedOperationImports property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of operation import names</param>
public void ValidateAndSetExcludedOperationImportsFromString(string inputValue)
{
    this.ExcludedOperationImports = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// Set the ExcludedBoundOperations property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of bound operation names</param>
public void ValidateAndSetExcludedBoundOperationsFromString(string inputValue)
{
    this.ExcludedBoundOperations = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// Set the ExcludedSchemaTypes property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of operation import names</param>
public void ValidateAndSetExcludedSchemaTypesFromString(string inputValue)
{
    this.ExcludedSchemaTypes = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// <summary>
/// Reads the parameter values from the Configuration class and applies them.
/// </summary>
private void ApplyParametersFromConfigurationClass()
{
    this.MetadataDocumentUri = Configuration.MetadataDocumentUri;
    this.NamespacePrefix = Configuration.NamespacePrefix;
    this.UseDataServiceCollection = Configuration.UseDataServiceCollection;
    this.ValidateAndSetTargetLanguageFromString(Configuration.TargetLanguage);
    this.EnableNamingAlias = Configuration.EnableNamingAlias;
    this.IgnoreUnexpectedElementsAndAttributes = Configuration.IgnoreUnexpectedElementsAndAttributes;
    this.MakeTypesInternal = Configuration.MakeTypesInternal;
    this.MetadataFilePath = Configuration.MetadataFilePath;
    this.MetadataFileRelativePath = Configuration.MetadataFileRelativePath;
    this.GenerateMultipleFiles = Configuration.GenerateMultipleFiles;
    this.SetCustomHttpHeadersFromString(Configuration.CustomHttpHeaders);
    this.ExcludedOperationImports = Configuration.ExcludedOperationImports.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
    this.ExcludedBoundOperations = Configuration.ExcludedBoundOperations.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
    this.ExcludedSchemaTypes = Configuration.ExcludedSchemaTypes.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// <summary>
/// Reads the parameter values from the command line (TextTransform.exe) and applies them.
/// </summary>
private void ApplyParametersFromCommandLine()
{
    if (this.Host == null)
    {
        return;
    }

    string metadataDocumentUri = this.Host.ResolveParameterValue("notempty", "notempty", "MetadataDocumentUri");
    if (!string.IsNullOrEmpty(metadataDocumentUri))
    {
        this.MetadataDocumentUri = metadataDocumentUri;
    }

    string namespacePrefix = this.Host.ResolveParameterValue("notempty", "notempty", "NamespacePrefix");
    if (!string.IsNullOrEmpty(namespacePrefix))
    {
        this.NamespacePrefix = namespacePrefix;
    }

    string useDataServiceCollection = this.Host.ResolveParameterValue("notempty", "notempty", "UseDataServiceCollection");
    if (!string.IsNullOrEmpty(useDataServiceCollection))
    {
        this.ValidateAndSetUseDataServiceCollectionFromString(useDataServiceCollection);
    }

    string targetLanguage = this.Host.ResolveParameterValue("notempty", "notempty", "TargetLanguage");
    if (!string.IsNullOrEmpty(targetLanguage))
    {
        this.ValidateAndSetTargetLanguageFromString(targetLanguage);
    }

    string enableNamingAlias = this.Host.ResolveParameterValue("notempty", "notempty", "EnableNamingAlias");
    if (!string.IsNullOrEmpty(enableNamingAlias))
    {
        this.ValidateAndSetEnableNamingAliasFromString(enableNamingAlias);
    }

    string ignoreUnexpectedElementsAndAttributes = this.Host.ResolveParameterValue("notempty", "notempty", "IgnoreUnexpectedElementsAndAttributes");
    if (!string.IsNullOrEmpty(ignoreUnexpectedElementsAndAttributes))
    {
        this.ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(ignoreUnexpectedElementsAndAttributes);
    }

    string makeTypesInternal = this.Host.ResolveParameterValue("notempty", "notempty", "MakeTypesInternal");
    if (!string.IsNullOrEmpty(makeTypesInternal))
    {
        this.ValidateAndSetMakeTypesInternalFromString(makeTypesInternal);
    }

    string customHttpHeaders = this.Host.ResolveParameterValue("notempty", "notempty", "CustomHttpHeaders");
    if (!string.IsNullOrEmpty(customHttpHeaders))
    {
        this.SetCustomHttpHeadersFromString(customHttpHeaders);
    }
}

/// <summary>
/// Enable one to mock the requests when fetching metadata
/// </summary>
internal interface IHttpRequestCreator
{
    HttpWebRequest Create(Uri uri);
}
/// <summary>
/// Includes a default http request creator that creates web requests for the client
/// </summary>
internal class DefaultHttpRequestCreator : IHttpRequestCreator
{
    public HttpWebRequest Create(Uri uri)
    {
        return (HttpWebRequest) WebRequest.Create(uri);
    }
}

/// <summary>
/// Context object to provide the model and configuration info to the code generator.
/// </summary>
public class CodeGenerationContext
{
    /// <summary>
    /// The namespace of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermNamespace = "Com.Microsoft.OData.Service.Conventions.V1";

    /// <summary>
    /// The name of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermName = "UrlConventions";

    /// <summary>
    /// The string value for indicating that the key-as-segment convention is being used in annotations and headers.
    /// </summary>
    private const string KeyAsSegmentConventionName = "KeyAsSegment";

    /// <summary>
    /// The XElement for the edmx
    /// </summary>
    private readonly XElement edmx;

    /// <summary>
    /// The namespacePrefix is used as the only namespace in generated code when there's only one schema in edm model,
    /// and as a prefix for the namespace from the model with multiple schemas. If this argument is null, the
    /// namespaces from the model are used for all types.
    /// </summary>
    private readonly string namespacePrefix;

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    private IEdmModel edmModel;

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    private string[] namespacesInModel;

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    private string[] warnings;

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    private bool? modelHasInheritance;

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    private Dictionary<string, string> namespaceMap;

    /// <summary>
    /// Maps the element type of a navigation source to the navigation source.
    /// </summary>
    private Dictionary<IEdmEntityType, List<IEdmNavigationSource>> elementTypeToNavigationSourceMap;

    /// <summary>
    /// HashSet contains the pair of Names and Namespaces of EntityContainers using KeyAsSegment url convention
    /// </summary>
    private HashSet<string> keyAsSegmentContainers;

    /// <summary>
    /// Preconfigured WebProxy for fetching the metadata
    /// </summary>
    private WebProxy webProxy;

    /// <summary>
    /// The metadata uri used for the original source edmx
    /// </summary>
    private Uri metadataUri;

    private  IList<string> customHttpHeaders;
    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    public CodeGenerationContext(Uri metadataUri, string namespacePrefix)
        : this(metadataUri, namespacePrefix, null, null)
    {
    }

    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    /// <param name="proxy">Webproxy instance to use for retriving the metadata</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    public CodeGenerationContext(Uri metadataUri, string namespacePrefix,  WebProxy proxy,  IList<string> CustomHttpHeaders)
        : this(GetEdmxStringFromMetadataPath(metadataUri, proxy, CustomHttpHeaders), namespacePrefix)
    {
        this.metadataUri = metadataUri;
        webProxy = proxy;
        customHttpHeaders = CustomHttpHeaders;
    }
    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="edmx">The string for the edmx.</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    /// when there's only one schema in edm model, and as a prefix for the namespace from the model with multiple
    /// schemas. If this argument is null, the namespaces from the model are used for all types.</param>
    public CodeGenerationContext(string edmx, string namespacePrefix)
    {
        this.edmx = XElement.Parse(edmx);
        this.namespacePrefix = namespacePrefix;
    }

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public XElement Edmx
    {
        get { return this.edmx; }
    }

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public IEdmModel EdmModel
    {
        get
        {
            if (this.edmModel == null)
            {
                Debug.Assert(this.edmx != null, "this.edmx != null");

                IEnumerable<Microsoft.OData.Edm.Validation.EdmError> errors;
                CsdlReaderSettings csdlReaderSettings = new CsdlReaderSettings()
                {
                    GetReferencedModelReaderFunc = this.GetReferencedModelReaderFuncWrapper,
                    IgnoreUnexpectedAttributesAndElements = this.IgnoreUnexpectedElementsAndAttributes
                };
                if (!CsdlReader.TryParse(this.edmx.CreateReader(ReaderOptions.None), Enumerable.Empty<IEdmModel>(), csdlReaderSettings, out this.edmModel, out errors))
                {
                    Debug.Assert(errors != null, "errors != null");
                    throw new InvalidOperationException(errors.FirstOrDefault().ErrorMessage);
                }
                else if (this.IgnoreUnexpectedElementsAndAttributes)
                {
                    if (errors != null && errors.Any())
                    {
                        this.warnings = errors.Select(e => e.ErrorMessage).ToArray();
                    }
                }
            }

            return this.edmModel;
        }
    }

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    public Func<Uri, WebProxy, IList<string>, XmlReader> GetReferencedModelReaderFunc
    {
        get { return getReferencedModelReaderFunc; }
        set { this.getReferencedModelReaderFunc = value; }
    }
    private static IHttpRequestCreator requestCreator;
    internal static IHttpRequestCreator RequestCreator
    {
        get
        {
             if(requestCreator==null)
             {
                requestCreator= new DefaultHttpRequestCreator();
             }
             return  requestCreator;
        }

        set { requestCreator = value;}
    }
    /// <summary>
    /// Basic setting for XmlReader.
    /// </summary>
    private static readonly XmlReaderSettings settings = new XmlReaderSettings() { IgnoreWhitespace = true, XmlResolver = null };

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    private Func<Uri, WebProxy, IList<string>, XmlReader> getReferencedModelReaderFunc = (uri, proxy, headers) => XmlReader.Create(GetEdmxStreamFromUri(uri, proxy, headers), settings);

    /// <summary>
    /// The Wrapper func for user code to overwrite and provide referenced model's stream.
    /// </summary>
    public Func<Uri, XmlReader> GetReferencedModelReaderFuncWrapper
    {
        get
        {
            return (uri) =>
            {
                Uri originalUri = uri;
                if(!uri.IsAbsoluteUri)
                {
                    // In the case that the reference model uri is relative we should create an absolute uri using the metadataUri as the base
                    uri = new Uri(metadataUri, uri.ToString());
                }
                using (XmlReader reader = GetReferencedModelReaderFunc(uri, webProxy, customHttpHeaders))
                {
                    if (reader == null)
                    {
                        return null;
                    }

                    XElement element = XElement.Load(reader);
                    if (this.ReferencesMap == null)
                    {
                        this.ReferencesMap = new Dictionary<Uri, XElement>();
                    }

                    this.ReferencesMap.Add(originalUri, element);
                    return element.CreateReader(ReaderOptions.None);
                }
            };
        }
    }

    /// <summary>
    /// Dictionary that stores uri and referenced xml mapping.
    /// </summary>
    public Dictionary<Uri, XElement> ReferencesMap
    {
        get;
        set;
    }

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    public string[] NamespacesInModel
    {
        get
        {
            if (this.namespacesInModel == null)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.namespacesInModel = GetElementsFromModelTree(this.EdmModel, (m) => m.SchemaElements.Select(e => e.Namespace)).Distinct().ToArray();
            }

            return this.namespacesInModel;
        }
    }

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    public string[] Warnings
    {
        get { return this.warnings ?? (this.warnings = new string[] {}); }
    }

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    public bool ModelHasInheritance
    {
        get
        {
            if (!this.modelHasInheritance.HasValue)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.modelHasInheritance = this.EdmModel.SchemaElementsAcrossModels().OfType<IEdmStructuredType>().Any(t => !t.FullTypeName().StartsWith("Org.OData.Authorization.V1") &&
                            !t.FullTypeName().StartsWith("Org.OData.Capabilities.V1") &&
                            !t.FullTypeName().StartsWith("Org.OData.Core.V1") && t.BaseType != null);
            }

            return this.modelHasInheritance.Value;
        }
    }

    /// <summary>
    /// true if we need to generate the ResolveNameFromType method, false otherwise.
    /// </summary>
    public bool NeedResolveNameFromType
    {
        get    { return this.ModelHasInheritance || this.NamespaceMap.Count > 0 || this.EnableNamingAlias; }
    }

    /// <summary>
    /// true if we need to generate the ResolveTypeFromName method, false otherwise.
    /// </summary>
    public bool NeedResolveTypeFromName
    {
        get { return this.NamespaceMap.Count > 0 || this.EnableNamingAlias; }
    }

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    public Dictionary<string, string> NamespaceMap
    {
        get
        {
            if (this.namespaceMap == null)
            {
                if (!string.IsNullOrEmpty(this.namespacePrefix))
                {
                    if (this.NamespacesInModel.Count() == 1)
                    {
                        IEdmEntityContainer container = this.EdmModel.EntityContainer;
                        string containerNamespace = container == null ? null : container.Namespace;
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => ns == containerNamespace ?
                                    this.namespacePrefix :
                                    this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                    else
                    {
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                }
                else if (this.EnableNamingAlias)
                {
                    this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => Customization.CustomizeNamespace(ns));
                }
                else
                {
                    this.namespaceMap = new Dictionary<string, string>();
                }
            }

            return this.namespaceMap;
        }
    }

    /// <summary>
    /// true to use DataServiceCollection in the generated code, false otherwise.
    /// </summary>
    public bool UseDataServiceCollection
    {
        get;
        set;
    }

	/// <summary>
	/// true to use internal access modifier for generated classes, otherwise they will be made public.
	/// This is useful if you don't want the generated classes to be visible outside the assembly
	/// </summary>
    public bool MakeTypesInternal
    {
        get;
        set;
    }

    /// <summary>
	/// list of operation imports to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedOperationImports
    {
        get;
        set;
    }

    /// <summary>
	/// list of bound operations to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedBoundOperations
    {
        get;
        set;
    }

    /// <summary>
	/// list of entity types to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedSchemaTypes
    {
        get;
        set;
    }

    /// <summary>
    /// Specifies which specific .Net Framework language the generated code will target.
    /// </summary>
    public LanguageOption TargetLanguage
    {
        get;
        set;
    }

    /// <summary>
    /// true to use Upper camel case for all class and property names, false otherwise.
    /// </summary>
    public bool EnableNamingAlias
    {
        get;
        set;
    }

    /// <summary>
    /// true to ignore unknown elements or attributes in metadata, false otherwise.
    /// </summary>
    public bool IgnoreUnexpectedElementsAndAttributes
    {
        get;
        set;
    }

    /// <summary>
    /// true to generate multiple files, false generate a single file.
    /// </summary>
    public bool GenerateMultipleFiles
    {
        get;
        set;
    }

    /// <summary>
    /// The path for the file where the metadata xml document can be stored.
    /// </summary>
    public string MetadataFilePath
    {
        get;
        set;
    }

    /// <summary>
    /// The relative path for the file where the metadata xml document can be stored.
    /// </summary>
    public string MetadataFileRelativePath
    {
        get;
        set;
    }

    /// <summary>
    /// Object instance of a file manager responsible for splitting generating multiple files.
    /// </summary>
    public FilesManager MultipleFilesManager
    {
        get;
        set;
    }

    /// <summary>
    /// Maps the element type of an entity set to the entity set.
    /// </summary>
    public Dictionary<IEdmEntityType, List<IEdmNavigationSource>> ElementTypeToNavigationSourceMap
    {
        get
        {
            return this.elementTypeToNavigationSourceMap ?? (this.elementTypeToNavigationSourceMap = new Dictionary<IEdmEntityType, List<IEdmNavigationSource>>(EqualityComparer<IEdmEntityType>.Default));
        }
    }

    /// <summary>
    /// true to emit container property attribute on dynamic property container, false otherwise.
    /// </summary>
    public bool EmitContainerPropertyAttribute
    {
        get;
        set;
    }

    /// <summary>
    /// true if this EntityContainer need to set the UrlConvention to KeyAsSegment, false otherwise.
    /// </summary>
    public bool UseKeyAsSegmentUrlConvention(IEdmEntityContainer currentContainer)
    {
        if (this.keyAsSegmentContainers == null)
        {
            this.keyAsSegmentContainers = new HashSet<string>();
            Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
            IEnumerable<IEdmVocabularyAnnotation> annotations = this.EdmModel.VocabularyAnnotations;
            foreach(IEdmVocabularyAnnotation valueAnnotation in annotations)
            {
                IEdmEntityContainer container = valueAnnotation.Target as IEdmEntityContainer;
                IEdmTerm valueTerm = valueAnnotation.Term as IEdmTerm;
                IEdmStringConstantExpression expression = valueAnnotation.Value as IEdmStringConstantExpression;
                if (container != null && valueTerm != null && expression != null)
                {
                    if (valueTerm.Namespace == ConventionTermNamespace &&
                        valueTerm.Name == ConventionTermName &&
                        expression.Value == KeyAsSegmentConventionName)
                    {
                        this.keyAsSegmentContainers.Add(container.FullName());
                    }
                }
            }
        }

        return this.keyAsSegmentContainers.Contains(currentContainer.FullName());
    }

    /// <summary>
    /// Gets the enumeration of schema elements with the given namespace.
    /// </summary>
    /// <param name="ns">The namespace of the schema elements to get.</param>
    /// <returns>The enumeration of schema elements with the given namespace.</returns>
    public IEnumerable<IEdmSchemaElement> GetSchemaElements(string ns)
    {
        Debug.Assert(ns != null, "ns != null");
        Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
        return GetElementsFromModelTree(this.EdmModel, m => m.SchemaElements.Where(e => e.Namespace == ns));
    }

    /// <summary>
    /// Gets the namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.
    /// </summary>
    /// <param name="schemaElement">The schema element to get the full name for.</param>
    /// <param name="schemaElementFixedName">The fixed name of this schemaElement.</param>
    /// <param name="template">The current code generate template.</param>
    /// <returns>The namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.</returns>
    public string GetPrefixedFullName(IEdmSchemaElement schemaElement, string schemaElementFixedName, ODataClientTemplate template, bool needGlobalPrefix = true)
    {
        if (schemaElement == null)
        {
            return null;
        }

        return this.GetPrefixedNamespace(schemaElement.Namespace, template, true, needGlobalPrefix) + "." + schemaElementFixedName;
    }

    /// <summary>
    /// Gets the prefixed namespace for the given <paramref name="ns"/>.
    /// </summary>
    /// <param name="ns">The namespace without the prefix.</param>
    /// <param name="template">The current code generate template.</param>
    /// <param name="needFix">The flag indicates whether the namespace need to be fixed now.</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by gloabal prefix.</param>
    /// <returns>The prefixed namespace for the given <paramref name="ns"/>.</returns>
    public string GetPrefixedNamespace(string ns, ODataClientTemplate template, bool needFix, bool needGlobalPrefix)
    {
        if (ns == null)
        {
            return null;
        }

        string prefixedNamespace;
        if (!this.NamespaceMap.TryGetValue(ns, out prefixedNamespace))
        {
            prefixedNamespace = ns;
        }

        if (needFix)
        {
            string[] segments = prefixedNamespace.Split('.');
            prefixedNamespace = string.Empty;
            int n = segments.Length;
            for (int i = 0; i < n; ++i)
            {
                if (template.LanguageKeywords.Contains(segments[i]))
                {
                    prefixedNamespace += string.Format(CultureInfo.InvariantCulture, template.FixPattern, segments[i]);
                }
                else
                {
                    prefixedNamespace += segments[i];
                }

                prefixedNamespace += (i == n - 1 ? string.Empty : ".");
            }
        }

        if (needGlobalPrefix)
        {
            prefixedNamespace = template.GlobalPrefix + prefixedNamespace;
        }

        return prefixedNamespace;
    }

    /// <summary>
    /// Reads the edmx string from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    private static string GetEdmxStringFromMetadataPath(Uri metadataUri, WebProxy proxy, IList<string> customHttpHeaders)
    {
        string content = null;
        using (StreamReader streamReader = new StreamReader(GetEdmxStreamFromUri(metadataUri, proxy ,customHttpHeaders)))
        {
            content = streamReader.ReadToEnd();
        }

        return content;
    }

    /// <summary>
    /// Get the metadata stream from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the stream. The supported scheme are File, http and https.</param>
    private static Stream GetEdmxStreamFromUri(Uri metadataUri, WebProxy proxy, IList<string> customHttpHeaders)
    {
        Debug.Assert(metadataUri != null, "metadataUri != null");
        Stream metadataStream = null;
        if (metadataUri.Scheme == "file")
        {
            metadataStream = new FileStream(Uri.UnescapeDataString(metadataUri.AbsolutePath), FileMode.Open, FileAccess.Read);
        }
        else if (metadataUri.Scheme == "http" || metadataUri.Scheme == "https")
        {
            try
            {
                 HttpWebRequest webRequest = RequestCreator.Create(metadataUri);
                if (customHttpHeaders != null)
                {
                    foreach (var header in customHttpHeaders)
                    {
                        webRequest.Headers.Add(header);
                    }
                }

                if(proxy != null)
                {
                    webRequest.Proxy= proxy;
                }

                WebResponse webResponse = webRequest.GetResponse();
                metadataStream = webResponse.GetResponseStream();

            }
            catch (WebException e)
            {
                HttpWebResponse webResponse = e.Response as HttpWebResponse;
                if (webResponse != null && webResponse.StatusCode == HttpStatusCode.Unauthorized)
                {
                    throw new WebException("Failed to access the metadata document. The OData service requires authentication for accessing it. Please download the metadata, store it into a local file, and set the value of “MetadataDocumentUri” in the .odata.config file to the file path. After that, run custom tool again to generate the OData Client code.");
                }
                else
                {
                    throw e;
                }
            }
        }
        else
        {
            throw new ArgumentException("Only file, http, https schemes are supported for paths to metadata source locations.");
        }

        return metadataStream;
    }

    private static IEnumerable<T> GetElementsFromModelTree<T>(IEdmModel mainModel, Func<IEdmModel, IEnumerable<T>> getElementFromOneModelFunc)
    {
        List<T> ret = new List<T>();
        if(mainModel is EdmCoreModel || mainModel.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null)
        {
            return ret;
        }

        ret.AddRange(getElementFromOneModelFunc(mainModel));
        foreach (var tmp in mainModel.ReferencedModels)
        {
            if (tmp is EdmCoreModel ||
                tmp.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null ||
                tmp.FindDeclaredTerm(CapabilitiesVocabularyConstants.ChangeTracking) != null ||
                tmp.FindDeclaredTerm(AlternateKeysVocabularyConstants.AlternateKeys) != null ||
                tmp.FindDeclaredTerm("Org.OData.Authorization.V1.Authorizations") != null ||
                tmp.FindDeclaredTerm("Org.OData.Validation.V1.DerivedTypeConstraint") != null ||
                tmp.FindDeclaredTerm("Org.OData.Community.V1.UrlEscapeFunction") != null)
            {
                continue;
            }

            ret.AddRange(getElementFromOneModelFunc(tmp));
        }

        return ret;
    }
}

/// <summary>
/// The template class to generate the OData client code.
/// </summary>
public abstract class ODataClientTemplate : TemplateBase
{
    protected const string T4Version  = "#VersionNumber#";

    protected const string deprecated = "Deprecated";

    /// <summary>
    /// The code generation context.
    /// </summary>
    protected readonly CodeGenerationContext context;

    /// <summary>
    /// The Dictionary to store identifier mappings when there are duplicate names between properties and Entity/Complex types
    /// </summary>
    protected Dictionary<string, string> IdentifierMappings = new Dictionary<string, string>(StringComparer.Ordinal);

    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientTemplate(CodeGenerationContext context)
    {
        this.context = context;
        if(context.MultipleFilesManager != null)
        {
            context.MultipleFilesManager.Template = this.GenerationEnvironment;
        }
    }

    internal string SingleSuffix
    {
        get { return "Single"; }
    }

    /// <summary>
    /// Options for <see cref="WritePropertyForStructuredType"/> method.
    /// </summary>
    internal class PropertyOptions
    {
        public string PropertyType { get; set; }
        public string OriginalPropertyName { get; set; }
        public string PropertyName { get; set; }
        public string FixedPropertyName { get; set; }
        public string PrivatePropertyName { get; set; }
        public string PropertyInitializationValue { get; set; }
        public string PropertyAttribute { get; set; }
        public string PropertyDescription { get; set; }
        public int? PropertyMaxLength { get; set; }
        public bool WriteOnPropertyChanged { get; set; }
        public bool IsNullable { get; set; }
        public IDictionary<string, string> RevisionAnnotations { get; set; }

        public override bool Equals(object other)
        {
            if(other == null)
                return false;
            
            if (object.ReferenceEquals(this, other))
                return true;

            if (this.GetType() != other.GetType())
                return false;

            return this.Equals(other as PropertyOptions);
        }

        private bool Equals(PropertyOptions other)
        {
            return
                string.Compare(this.PropertyType, other.PropertyType) == 0 &&
                string.Compare(this.OriginalPropertyName, other.OriginalPropertyName) == 0 &&
                string.Compare(this.PropertyName, other.PropertyName) == 0 &&
                string.Compare(this.FixedPropertyName, other.FixedPropertyName) == 0 &&
                string.Compare(this.PrivatePropertyName, other.PrivatePropertyName) == 0 &&
                string.Compare(this.PropertyInitializationValue, other.PropertyInitializationValue) == 0 &&
                string.Compare(this.PropertyAttribute, other.PropertyAttribute) == 0 &&
                string.Compare(this.PropertyDescription, other.PropertyDescription) == 0 &&
                other.PropertyMaxLength == null
                    ? this.PropertyMaxLength == null
                    : other.PropertyMaxLength.Equals(this.PropertyMaxLength) &&
                other.WriteOnPropertyChanged.Equals(this.WriteOnPropertyChanged) &&
                other.IsNullable.Equals(this.IsNullable) &&
                other.RevisionAnnotations == null
                    ? this.RevisionAnnotations == null
                    : other.RevisionAnnotations.Equals(this.RevisionAnnotations);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    #region Get Language specific keyword names.
    internal abstract string GlobalPrefix { get; }
    internal abstract string SystemTypeTypeName { get; }
    internal abstract string AbstractModifier { get; }
    internal abstract string PublicAccessModifier { get; }
    internal abstract string InternalAccessModifier { get; }
    internal abstract string DataServiceActionQueryTypeName { get; }
    internal abstract string DataServiceActionQuerySingleOfTStructureTemplate { get; }
    internal abstract string DataServiceActionQueryOfTStructureTemplate { get; }
    internal abstract string NotifyPropertyChangedModifier { get; }
    internal abstract string ClassInheritMarker { get; }
    internal abstract string ParameterSeparator { get; }
    internal abstract string KeyParameterSeparator { get; }
    internal abstract string KeyDictionaryItemSeparator { get; }
    internal abstract string SystemNullableStructureTemplate { get; }
    internal abstract string ICollectionOfTStructureTemplate { get; }
    internal abstract string DataServiceCollectionStructureTemplate { get; }
    internal abstract string DataServiceQueryStructureTemplate { get; }
    internal abstract string DataServiceQuerySingleStructureTemplate { get; }
    internal abstract string ObservableCollectionStructureTemplate { get; }
    internal abstract string ObjectModelCollectionStructureTemplate { get; }
    internal abstract string DataServiceCollectionConstructorParameters { get; }
    internal abstract string NewModifier { get; }
    internal abstract string GeoTypeInitializePattern { get; }
    internal abstract string ObjectTypeName { get; }
    internal abstract string Int32TypeName { get; }
    internal abstract string StringTypeName { get; }
    internal abstract string BinaryTypeName { get; }
    internal abstract string DecimalTypeName { get; }
    internal abstract string Int16TypeName { get; }
    internal abstract string SingleTypeName { get; }
    internal abstract string BooleanTypeName { get; }
    internal abstract string DoubleTypeName { get; }
    internal abstract string GuidTypeName { get; }
    internal abstract string ByteTypeName { get; }
    internal abstract string Int64TypeName { get; }
    internal abstract string SByteTypeName { get; }
    internal abstract string DataServiceStreamLinkTypeName { get; }
    internal abstract string GeographyTypeName { get; }
    internal abstract string GeographyPointTypeName { get; }
    internal abstract string GeographyLineStringTypeName { get; }
    internal abstract string GeographyPolygonTypeName { get; }
    internal abstract string GeographyCollectionTypeName { get; }
    internal abstract string GeographyMultiPolygonTypeName { get; }
    internal abstract string GeographyMultiLineStringTypeName { get; }
    internal abstract string GeographyMultiPointTypeName { get; }
    internal abstract string GeometryTypeName { get; }
    internal abstract string GeometryPointTypeName { get; }
    internal abstract string GeometryLineStringTypeName { get; }
    internal abstract string GeometryPolygonTypeName { get; }
    internal abstract string GeometryCollectionTypeName { get; }
    internal abstract string GeometryMultiPolygonTypeName { get; }
    internal abstract string GeometryMultiLineStringTypeName { get; }
    internal abstract string GeometryMultiPointTypeName { get; }
    internal abstract string DateTypeName { get; }
    internal abstract string DateTimeOffsetTypeName { get; }
    internal abstract string DurationTypeName { get; }
    internal abstract string TimeOfDayTypeName { get; }
    internal abstract string XmlConvertClassName { get; }
    internal abstract string EnumTypeName { get; }
    internal abstract string DictionaryInterfaceName { get; }
    internal abstract string DictionaryTypeName { get; }
    internal abstract HashSet<string> LanguageKeywords { get; }
    internal abstract string FixPattern { get; }
    internal abstract string EnumUnderlyingTypeMarker { get; }
    internal abstract string ConstantExpressionConstructorWithType { get; }
    internal abstract string TypeofFormatter { get; }
    internal abstract string UriOperationParameterConstructor { get; }
    internal abstract string UriEntityOperationParameterConstructor { get; }
    internal abstract string BodyOperationParameterConstructor { get; }
    internal abstract string DictionaryConstructor { get; }
    internal abstract string BaseEntityType { get; }
    internal abstract string OverloadsModifier { get; }
    internal abstract string ODataVersion { get; }
    internal abstract string ParameterDeclarationTemplate { get; }
    internal abstract string DictionaryItemConstructor { get; }
    internal abstract string ContainerPropertyBase { get; }
    internal abstract string ContainerPropertyAttribute { get; }
    #endregion Get Language specific keyword names.

    #region Language specific write methods.
    internal abstract void WriteFileHeader();
    internal abstract void WriteNamespaceStart(string fullNamespace);
    internal abstract void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description);
    internal abstract void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName);
    internal abstract void WriteKeyAsSegmentUrlConvention();
    internal abstract void WriteInitializeResolveName();
    internal abstract void WriteInitializeResolveType();
    internal abstract void WriteClassEndForEntityContainerConstructor();
    internal abstract void WriteMethodStartForResolveTypeFromName();
    internal abstract void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveTypeFromName();
    internal abstract void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace);
    internal abstract void WriteResolveType(string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveNameFromType(bool modelHasInheritance);
    internal abstract void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext = true);
    internal abstract void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext = true);
    internal abstract void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName);
    internal abstract void WriteGeneratedEdmModel(string escapedEdmxString);
    internal abstract void WriteClassEndForEntityContainer();
    internal abstract void WriteSummaryCommentForStructuredType(string typeName, string description);
    internal abstract void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString);
    internal abstract void WriteEntityTypeAttribute();
    internal abstract void WriteEntitySetAttribute(string entitySetName);
    internal abstract void WriteEntityHasStreamAttribute();
    internal abstract void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName);
    internal abstract void WriteSummaryCommentForStaticCreateMethod(string typeName);
    internal abstract void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName);
    internal abstract void WriteDeclarationStartForStaticCreateMethod(string typeName,string fixedTypeName );
    internal abstract void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater);
    internal abstract void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName);
    internal abstract void WriteParameterNullCheckForStaticCreateMethod(string parameterName);
    internal abstract void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName);
    internal abstract void WriteMethodEndForStaticCreateMethod(string instanceName);
    internal abstract void WritePropertyForStructuredType(PropertyOptions propertyOptions);
    internal abstract void WriteINotifyPropertyChangedImplementation();
    internal abstract void WriteClassEndForStructuredType();
    internal abstract void WriteNamespaceEnd();
    internal abstract void WriteEnumFlags();
    internal abstract void WriteSummaryCommentForEnumType(string enumName, string description);
    internal abstract void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType);
    internal abstract void WriteMemberForEnumType(string member, string originalMemberName, bool last);
    internal abstract void WriteEnumEnd();
    internal abstract void WritePropertyRootNamespace(string containerName, string fullNamespace);
    internal abstract void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteConstructorForSingleType(string singleTypeName, string baseTypeName);
    internal abstract void WriteExtensionMethodsStart();
    internal abstract void WriteExtensionMethodsEnd();
    internal abstract void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems);
    internal abstract void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName);
    internal abstract void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description);
    internal abstract void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description);
    internal abstract void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description);
    protected abstract void WriteDescriptionSummary(string description, bool isClass = false);
    protected abstract void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false);
    protected abstract void WriteStringLengthAttribute(int maxLength, string errorMessage);
    protected abstract void WriteRequiredAttribute(string errorMessage);
    #endregion Language specific write methods.

    internal HashSet<EdmPrimitiveTypeKind> ClrReferenceTypes { get {
        if (clrReferenceTypes == null)
        {
            clrReferenceTypes = new HashSet<EdmPrimitiveTypeKind>()
            {
                EdmPrimitiveTypeKind.String, EdmPrimitiveTypeKind.Binary, EdmPrimitiveTypeKind.Geography, EdmPrimitiveTypeKind.Stream,
                EdmPrimitiveTypeKind.GeographyPoint, EdmPrimitiveTypeKind.GeographyLineString, EdmPrimitiveTypeKind.GeographyPolygon,
                EdmPrimitiveTypeKind.GeographyCollection, EdmPrimitiveTypeKind.GeographyMultiPolygon, EdmPrimitiveTypeKind.GeographyMultiLineString,
                EdmPrimitiveTypeKind.GeographyMultiPoint, EdmPrimitiveTypeKind.Geometry, EdmPrimitiveTypeKind.GeometryPoint,
                EdmPrimitiveTypeKind.GeometryLineString, EdmPrimitiveTypeKind.GeometryPolygon, EdmPrimitiveTypeKind.GeometryCollection,
                EdmPrimitiveTypeKind.GeometryMultiPolygon, EdmPrimitiveTypeKind.GeometryMultiLineString, EdmPrimitiveTypeKind.GeometryMultiPoint
            };
        }
        return clrReferenceTypes;
    } }
    private HashSet<EdmPrimitiveTypeKind> clrReferenceTypes;

    internal string ClassAccessModifier {
        get {
            return this.context.MakeTypesInternal ? this.InternalAccessModifier : this.PublicAccessModifier;
        }
    }

    /// <summary>
    /// Generates code for the OData client.
    /// </summary>
    /// <returns>The generated code for the OData client.</returns>
    public override string TransformText()
    {
        context.MultipleFilesManager.StartHeader();
        this.WriteFileHeader();
        context.MultipleFilesManager.EndBlock();
        this.WriteNamespaces();
        context.MultipleFilesManager.GenerateFiles(context.GenerateMultipleFiles, null, null, null, false, false);
        return context.MultipleFilesManager.Template.ToString();
    }

    internal void WriteNamespaces()
    {
        foreach(string fullNamespace in context.NamespacesInModel)
        {
            this.WriteNamespace(fullNamespace);
        }
    }

    internal string GetFileNameForMultipleFilesGeneration(IEdmSchemaElement schemaElement)
    {
        IEdmSchemaElement[] schemaElementsInModel = this.context.NamespacesInModel.SelectMany(n => this.context.GetSchemaElements(n)).ToArray();
        string fileExtension = this.context.TargetLanguage == LanguageOption.VB ? ".vb" : ".cs";
        if (schemaElementsInModel.Count(e => e.Name.Equals(schemaElement.Name)) > 1)
        {
            return $"{schemaElement.FullName()}{fileExtension}";
        }

        return $"{schemaElement.Name}{fileExtension}";
    }

    internal void WriteNamespace(string fullNamespace)
    {
        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));

        IEdmSchemaElement[] schemaElementsInModel = this.context.NamespacesInModel.SelectMany(n => this.context.GetSchemaElements(n)).ToArray();
        IEdmSchemaElement[] schemaElements = this.context.GetSchemaElements(fullNamespace).ToArray();
        if (schemaElements.OfType<IEdmEntityContainer>().Any()) {
            IEdmEntityContainer container = schemaElements.OfType<IEdmEntityContainer>().Single();
            this.WriteEntityContainer(container, fullNamespace);
        }

        Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap = new Dictionary<IEdmStructuredType, List<IEdmOperation>>();
        foreach (IEdmOperation operation in schemaElements.OfType<IEdmOperation>())
        {
            if (operation.IsBound)
            {
                IEdmType edmType = operation.Parameters.First().Type.Definition;
                IEdmStructuredType edmStructuredType = edmType as IEdmStructuredType;
                if (edmStructuredType != null)
                {
                    List<IEdmOperation> operationList;
                    if (!boundOperationsMap.TryGetValue(edmStructuredType, out operationList))
                    {
                        operationList = new List<IEdmOperation>();
                    }

                    operationList.Add(operation);
                    boundOperationsMap[edmStructuredType] = operationList;
                }
            }
        }

        Dictionary<IEdmStructuredType, List<IEdmStructuredType>> structuredBaseTypeMap = new Dictionary<IEdmStructuredType, List<IEdmStructuredType>>();
        foreach(IEdmSchemaType type in schemaElements.OfType<IEdmSchemaType>())
        {
            if (type is IEdmEnumType enumType)
            {
                if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(enumType.FullName()))
                {
                    continue;
                }

                if(context.GenerateMultipleFiles)
                {
                    string fileName = GetFileNameForMultipleFilesGeneration(enumType);
                    context.MultipleFilesManager.StartNewFile(fileName, false);
                    this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                }

                this.WriteEnumType(enumType);

                if(context.GenerateMultipleFiles)
                {
                    this.WriteNamespaceEnd();
                    context.MultipleFilesManager.EndBlock();
                }
            }
            else
            {
                if (type is IEdmComplexType complexType)
                {
                    if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(complexType.FullName()))
                    {
                        continue;
                    }

                    if(context.GenerateMultipleFiles)
                    {
                        string fileName = GetFileNameForMultipleFilesGeneration(complexType);
                        context.MultipleFilesManager.StartNewFile(fileName, false);
                        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                    }

                    this.WriteComplexType(complexType, boundOperationsMap);

                    if(context.GenerateMultipleFiles)
                    {
                        this.WriteNamespaceEnd();
                        context.MultipleFilesManager.EndBlock();
                    }
                }
                else if (type is IEdmEntityType entityType)
                {
                    if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entityType.FullName()))
                    {
                        continue;
                    }

                    if(context.GenerateMultipleFiles)
                    {
                        string fileName = GetFileNameForMultipleFilesGeneration(entityType);
                        context.MultipleFilesManager.StartNewFile(fileName, false);
                        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                    }

                    this.WriteEntityType(entityType, boundOperationsMap);

                    if(context.GenerateMultipleFiles)
                    {
                        this.WriteNamespaceEnd();
                        context.MultipleFilesManager.EndBlock();
                    }
                }

                IEdmStructuredType structuredType = type as IEdmStructuredType;
                if (structuredType?.BaseType != null)
                {
                    List<IEdmStructuredType> derivedTypes;
                    if (!structuredBaseTypeMap.TryGetValue(structuredType.BaseType, out derivedTypes))
                    {
                       structuredBaseTypeMap[structuredType.BaseType] = new List<IEdmStructuredType>();
                    }

                    structuredBaseTypeMap[structuredType.BaseType].Add(structuredType);
                }
            }
        }

        if (schemaElements.OfType<IEdmEntityType>().Any() ||
            schemaElements.OfType<IEdmOperation>().Any(o => o.IsBound))
        {
            if(context.GenerateMultipleFiles)
            {
                string ns = this.context.NamespacesInModel.Length > 1 ? $"{fullNamespace}." : string.Empty;
                string fileExtension = this.context.TargetLanguage == LanguageOption.VB ? ".vb" : ".cs";
                context.MultipleFilesManager.StartNewFile($"{ns}ExtensionMethods{fileExtension}", false);
                this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
            }

            this.WriteExtensionMethodsStart();

            foreach (IEdmEntityType type in schemaElements.OfType<IEdmEntityType>())
            {

                if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(type.FullName()))
                {
                    continue;
                }

                string entityTypeName = type.Name;
                entityTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
                string entityTypeFullName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName), this);
                string returnTypeName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName + this.SingleSuffix), this);

                var keyProperties = type.Key();
                if(keyProperties != null && keyProperties.Any())
                {
                    List<string> keyParameters = new List<string>();
                    List<string> keyDictionaryItems = new List<string>();
                    List<string> keyNames = new List<string>();
                    foreach (IEdmProperty key in keyProperties)
                    {
                        string typeName = Utils.GetClrTypeName(key.Type, this.context.UseDataServiceCollection, this, this.context);
                        string keyName = Utils.CamelCase(key.Name);
                        keyNames.Add(keyName);
                        keyParameters.Add(string.Format(CultureInfo.InvariantCulture, this.ParameterDeclarationTemplate, typeName, this.GetFixedName(keyName)));
                        keyDictionaryItems.Add(string.Format(CultureInfo.InvariantCulture, this.DictionaryItemConstructor, "\"" + key.Name + "\"", this.GetFixedName(keyName)));
                    }

                    string keyParametersString = string.Join(this.KeyParameterSeparator, keyParameters);
                    string keyDictionaryItemsString = string.Join(this.KeyDictionaryItemSeparator, keyDictionaryItems);
                    this.WriteByKeyMethods(entityTypeFullName, returnTypeName, keyNames, keyParametersString, keyDictionaryItemsString);
                }

                IEdmEntityType current = (IEdmEntityType)type.BaseType;
                while (current != null)
                {
                    string baseTypeName = current.Name;
                    baseTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(baseTypeName) : baseTypeName;
                    baseTypeName = context.GetPrefixedFullName(current, GetFixedName(baseTypeName), this);
                    this.WriteCastToMethods(baseTypeName, entityTypeName, entityTypeFullName, returnTypeName);
                    current = (IEdmEntityType)current.BaseType;
                }
            }

            HashSet<string> boundOperations = new HashSet<string>(StringComparer.Ordinal);
            foreach (IEdmFunction function in schemaElements.OfType<IEdmFunction>())
            {
                if (function.IsBound)
                {
                    IEdmTypeReference edmTypeReference = function.Parameters.First().Type;

                    if (this.context.ExcludedBoundOperations?.Contains($"{function.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                    {
                        continue;
                    }

                    if(this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(edmTypeReference.FullName()))
                    {
                        continue;
                    }

                    string functionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(function.Name) : function.Name;
                    string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                    bool useEntityReference;
                    this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                    string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                    string fixedFunctionName = GetFixedName(functionName);
                    string func = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedFunctionName, sourceTypeName, parameterTypes );

                    if (!boundOperations.Contains(func))
                    {
                        boundOperations.Add(func);

                        if (function.ReturnType.IsCollection())
                        {
                            this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value);
                        }
                        else
                        {
                            this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value);
                        }
                    }

                    IEdmStructuredType structuredType;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        structuredType = (IEdmStructuredType)collectionType.ElementType.Definition;
                    }
                    else
                    {
                        structuredType = (IEdmStructuredType)edmTypeReference.Definition;
                    }

                    List<IEdmStructuredType> derivedTypes;
                        if (structuredBaseTypeMap.TryGetValue(structuredType, out derivedTypes))
                    {
                        foreach (IEdmStructuredType type in derivedTypes)
                        {
                            IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                            List<IEdmTypeReference> currentParameters = function.Parameters.Select(p => p.Type).ToList();
                            currentParameters[0] = derivedTypeReference;

                            sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                            string currentFunc = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedFunctionName, sourceTypeName, parameterTypes );
                            if (!boundOperations.Contains(currentFunc))
                            {
                                boundOperations.Add(currentFunc);

                                if (function.ReturnType.IsCollection())
                                {
                                    this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value);
                                }
                                else
                                {
                                    this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value);
                                }
                            }
                        }
                    }
                }
            }

            foreach (IEdmAction action in schemaElements.OfType<IEdmAction>())
            {
                if (action.IsBound)
                {
                    IEdmTypeReference edmTypeReference = action.Parameters.First().Type;

                    if (this.context.ExcludedBoundOperations?.Contains($"{action.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                    {
                        continue;
                    }

                    if(this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(edmTypeReference.FullName()))
                    {
                        continue;
                    }

                    string actionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(action.Name) : action.Name;
                    string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                    bool useEntityReference;
                    this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName;
                    if (action.ReturnType != null)
                    {
                        returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                        if (action.ReturnType.IsCollection())
                        {
                            returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
                        }
                        else
                        {
                            returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                        }
                    }
                    else
                    {
                        returnTypeName = this.DataServiceActionQueryTypeName;
                    }

                    string fixedActionName = GetFixedName(actionName);
                    string ac = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedActionName, sourceTypeName, parameterTypes );
                    if (!boundOperations.Contains(ac))
                    {
                        boundOperations.Add(ac);
                        this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value);
                    }

                    IEdmStructuredType structuredType;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        structuredType = (IEdmStructuredType)collectionType.ElementType.Definition;
                    }
                    else
                    {
                        structuredType = (IEdmStructuredType)edmTypeReference.Definition;
                    }

                    List<IEdmStructuredType> derivedTypes;
                    if (structuredBaseTypeMap.TryGetValue(structuredType, out derivedTypes))
                    {
                        foreach (IEdmStructuredType type in derivedTypes)
                        {
                            IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                            List<IEdmTypeReference> currentParameters = action.Parameters.Select(p => p.Type).ToList();
                            currentParameters[0] = derivedTypeReference;

                            sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                            string currentAc = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedActionName, sourceTypeName, parameterTypes );
                            if (!boundOperations.Contains(currentAc))
                            {
                                boundOperations.Add(currentAc);
                                this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value);
                            }
                        }
                    }
                }
            }

            this.WriteExtensionMethodsEnd();
            if(context.GenerateMultipleFiles)
            {
                this.WriteNamespaceEnd();
                context.MultipleFilesManager.EndBlock();
            }
        }

        this.WriteNamespaceEnd();
    }

    internal bool HasBoundOperations(IEnumerable<IEdmOperation> operations)
    {
        foreach (IEdmOperation opeartion in operations)
        {
            if (opeartion.IsBound)
            {
                return true;
            }
        }

        return false;
    }

    internal void WriteEntityContainer(IEdmEntityContainer container, string fullNamespace)
    {
        string camelCaseContainerName = container.Name;
        string path = this.context.MetadataFilePath;
        bool useTempFile = !String.IsNullOrEmpty(path);
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }

        this.WriteClassStartForEntityContainer(container.Name, camelCaseContainerName, GetFixedName(camelCaseContainerName), GetDescriptionAnnotation(container)?.Value);
        this.WriteEntityContainerConstructor(container);

        if (this.context.NeedResolveNameFromType)
        {
            this.WritePropertyRootNamespace(GetFixedName(camelCaseContainerName), this.context.GetPrefixedNamespace(fullNamespace, this, false, false));
        }

        this.WriteResolveTypeFromName();
        this.WriteResolveNameFromType(camelCaseContainerName, fullNamespace);

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entitySetElementType.FullName()))
            {
                continue;
            }

            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            IDictionary<string, string> revisionAnnotations = new Dictionary<string, string>();

            this.WriteContextEntitySetProperty(camelCaseEntitySetName, GetFixedName(camelCaseEntitySetName), entitySet.Name, GetFixedName(entitySetElementTypeName), GetDescriptionAnnotation(entitySet)?.Value, GetRevisionAnnotations(entitySet));
            List<IEdmNavigationSource> edmNavigationSourceList = null;
            if (!this.context.ElementTypeToNavigationSourceMap.TryGetValue(entitySet.EntityType(), out edmNavigationSourceList))
            {
                edmNavigationSourceList = new List<IEdmNavigationSource>();
                this.context.ElementTypeToNavigationSourceMap.Add(entitySet.EntityType(), edmNavigationSourceList);
            }

            edmNavigationSourceList.Add(entitySet);
        }

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entitySetElementType.FullName()))
            {
                continue;
            }

            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(/*IsLanguageCaseSensitive*/true);
            string parameterName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(entitySetElementType.Name));

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            this.WriteContextAddToEntitySetMethod(camelCaseEntitySetName, entitySet.Name, GetFixedName(entitySetElementTypeName), parameterName);
        }

        foreach (IEdmSingleton singleton in container.Singletons())
        {
            IEdmEntityType singletonElementType = singleton.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(singletonElementType.FullName()))
            {
                continue;
            }

            string singletonElementTypeName = GetElementTypeName(singletonElementType, container);
            string camelCaseSingletonName = singleton.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseSingletonName = Customization.CustomizeNaming(camelCaseSingletonName);
            }

            this.WriteContextSingletonProperty(camelCaseSingletonName, GetFixedName(camelCaseSingletonName), singleton.Name, singletonElementTypeName + "Single", GetDescriptionAnnotation(singleton)?.Value, GetRevisionAnnotations(singleton));

            List<IEdmNavigationSource> edmNavigationSourceList = null;
            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(singleton.EntityType(), out edmNavigationSourceList))
            {
                edmNavigationSourceList.Add(singleton);
            }
        }

        string edmx = Utils.SerializeToString(this.context.Edmx);
        if (useTempFile)
        {
            this.WriteGeneratedEdmModel(edmx);
        }
        else // constructing Edmx string
        {
            edmx = edmx.Replace("\"", "\"\"");
            if (this.context.TargetLanguage == LanguageOption.VB)
            {
                this.WriteGeneratedEdmModel(edmx.Replace("\r\n", "\" & _\r\n \""));
            }
            else
            {
                this.WriteGeneratedEdmModel(edmx);
            }
        }

        bool hasOperationImport = container.OperationImports().OfType<IEdmOperationImport>().Any();
        foreach (IEdmFunctionImport functionImport in container.OperationImports().OfType<IEdmFunctionImport>())
        {
            if (this.context.ExcludedOperationImports?.Contains(functionImport.Name) == true)
            {
                continue;
            }

            string parameterString, parameterTypes, parameterExpressionString, parameterValues;
            bool useEntityReference;
            this.GetParameterStrings(false, false, functionImport.Function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
            string returnTypeName = GetSourceOrReturnTypeName(functionImport.Function.ReturnType);
            string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(functionImport.Function.ReturnType, true);
            string fixedContainerName = this.GetFixedName(functionImport.Container.Name);
            bool isCollectionResult = functionImport.Function.ReturnType.IsCollection();
            string functionImportName = functionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                functionImportName = Customization.CustomizeNaming(functionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            if (functionImport.Function.ReturnType.IsCollection())
            {
                this.WriteFunctionImportReturnCollectionResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, parameterString, parameterValues, functionImport.Function.IsComposable, useEntityReference, GetDescriptionAnnotation(functionImport)?.Value, GetRevisionAnnotations(functionImport));
            }
            else
            {
                this.WriteFunctionImportReturnSingleResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, parameterValues, functionImport.Function.IsComposable, functionImport.Function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(functionImport)?.Value, GetRevisionAnnotations(functionImport));
            }
        }

        foreach (IEdmActionImport actionImport in container.OperationImports().OfType<IEdmActionImport>())
        {
            if (this.context.ExcludedOperationImports?.Contains(actionImport.Name) == true)
            {
                continue;
            }

            string parameterString, parameterTypes, parameterExpressionString, parameterValues;
            bool useEntityReference;
            this.GetParameterStrings(false, true, actionImport.Action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
            string returnTypeName = null;
            string fixedContainerName = this.GetFixedName(actionImport.Container.Name);

            if (actionImport.Action.ReturnType != null)
            {
                returnTypeName = GetSourceOrReturnTypeName(actionImport.Action.ReturnType);
                if (actionImport.Action.ReturnType.IsCollection())
                {
                    returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
            }
                else
                {
                    returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                }
            }
            else
            {
                returnTypeName = this.DataServiceActionQueryTypeName;
            }

            string actionImportName = actionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                actionImportName = Customization.CustomizeNaming(actionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            this.WriteActionImport(this.GetFixedName(actionImportName), actionImport.Name, returnTypeName, parameterString, parameterValues, GetDescriptionAnnotation(actionImport)?.Value, GetRevisionAnnotations(actionImport));
        }

        this.WriteClassEndForEntityContainer();
    }

    internal void WriteEntityContainerConstructor(IEdmEntityContainer container)
    {
        string camelCaseContainerName = container.Name;
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }

        this.WriteMethodStartForEntityContainerConstructor(camelCaseContainerName, GetFixedName(camelCaseContainerName));

        if (this.context.UseKeyAsSegmentUrlConvention(container))
        {
            this.WriteKeyAsSegmentUrlConvention();
        }

        if (this.context.NeedResolveNameFromType)
        {
            this.WriteInitializeResolveName();
        }

        if (this.context.NeedResolveTypeFromName)
        {
            this.WriteInitializeResolveType();
        }

        this.WriteClassEndForEntityContainerConstructor();
    }

    internal void WriteResolveTypeFromName()
    {
        if (!this.context.NeedResolveTypeFromName)
        {
            return;
        }

        this.WriteMethodStartForResolveTypeFromName();

        // NOTE: since multiple namespaces can have the same prefix and match the namespace
        // prefix condition, it's important that the prefix check is done is prefix-length
        // order, starting with the longest prefix.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Key.Length).ThenBy(p => p.Key);

        string typeName = this.SystemTypeTypeName + " ";
        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveNamespace(typeName, namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
            typeName = string.Empty;
        }

        this.WriteMethodEndForResolveTypeFromName();
    }

    internal void WriteResolveNameFromType(string containerName, string fullNamespace)
    {
        if (!this.context.NeedResolveNameFromType)
        {
            return;
        }

        this.WriteMethodStartForResolveNameFromType(GetFixedName(containerName), fullNamespace);

        // NOTE: in this case order also matters, but the length of the CLR
        // namespace is what needs to be considered.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Value.Length).ThenBy(p => p.Key);

        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveType(namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
        }

        this.WriteMethodEndForResolveNameFromType(this.context.ModelHasInheritance);
    }

    internal void WritePropertiesForSingleType(IEnumerable<IEdmProperty> properties)
    {
        foreach (IEdmProperty property in properties.Where(i => i.PropertyKind == EdmPropertyKind.Navigation))
        {
            string propertyType;
            string propertyName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name;
            if (property.Type is Microsoft.OData.Edm.EdmCollectionTypeReference)
            {
                propertyType = GetSourceOrReturnTypeName(property.Type);
                WriteContextEntitySetProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, GetDescriptionAnnotation(property)?.Value, GetRevisionAnnotations(property), false);
            }
            else
            {
                propertyType = Utils.GetClrTypeName(property.Type, true, this, this.context, true, isEntitySingleType : true);
                WriteContextSingletonProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, GetDescriptionAnnotation(property)?.Value, GetRevisionAnnotations(property), false);
            }
        }
    }

    internal void WriteEntityType(IEdmEntityType entityType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        string entityTypeName = ((IEdmSchemaElement)entityType).Name;
        entityTypeName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
        this.WriteSummaryCommentForStructuredType(entityTypeName + this.SingleSuffix, GetDescriptionAnnotation(entityType)?.Value);
        this.WriteObsoleteAttribute(GetRevisionAnnotations(entityType), /* isClass */ true);
        this.WriteStructurdTypeDeclaration(entityType,
            this.ClassInheritMarker + string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)),
            this.SingleSuffix);
        string singleTypeName = (this.context.EnableNamingAlias ?
                        Customization.CustomizeNaming(((IEdmSchemaElement)entityType).Name) : ((IEdmSchemaElement)entityType).Name) + this.SingleSuffix;
        this.WriteConstructorForSingleType(GetFixedName(singleTypeName), string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)));
        IEdmEntityType current = entityType;
        while (current != null)
        {
            this.WritePropertiesForSingleType(current.DeclaredProperties);
            current = (IEdmEntityType)current.BaseType;
        }

        this.WriteClassEndForStructuredType();

        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityType.Name) : entityType.Name, GetDescriptionAnnotation(entityType)?.Value);

        if (entityType.Key().Any())
        {
            IEnumerable<string> keyProperties = entityType.Key().Select(k => k.Name);
            this.WriteKeyPropertiesCommentAndAttribute(
                this.context.EnableNamingAlias ? keyProperties.Select(k => Customization.CustomizeNaming(k)) : keyProperties,
                string.Join("\", \"", keyProperties));
        }
        else
        {
            this.WriteEntityTypeAttribute();
        }

        if (this.context.UseDataServiceCollection)
        {
            List<IEdmNavigationSource> navigationSourceList;
            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(entityType, out navigationSourceList))
            {
                if(navigationSourceList.Count == 1)
                {
                    this.WriteEntitySetAttribute(navigationSourceList[0].Name);
                }
            }
        }

        if (entityType.HasStream)
        {
            this.WriteEntityHasStreamAttribute();
        }

        this.WriteObsoleteAttribute(GetRevisionAnnotations(entityType), /* isClass */ true);
        this.WriteStructurdTypeDeclaration(entityType, this.BaseEntityType);
        this.SetPropertyIdentifierMappingsIfNameConflicts(entityType.Name, entityType);
        this.WriteTypeStaticCreateMethod(entityType.Name, entityType);
        this.WritePropertiesForStructuredType(entityType);

        if (entityType.BaseType == null && this.context.UseDataServiceCollection)
        {
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteBoundOperations(entityType, boundOperationsMap);

        this.WriteClassEndForStructuredType();
    }

    internal void WriteComplexType(IEdmComplexType complexType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(complexType.Name) : complexType.Name, GetDescriptionAnnotation(complexType)?.Value);
        this.WriteStructurdTypeDeclaration(complexType, string.Empty);
        this.SetPropertyIdentifierMappingsIfNameConflicts(complexType.Name, complexType);
        this.WriteTypeStaticCreateMethod(complexType.Name, complexType);
        this.WritePropertiesForStructuredType(complexType);

        if (complexType.BaseType == null && this.context.UseDataServiceCollection)
        {
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteClassEndForStructuredType();
    }

    internal void WriteBoundOperations(IEdmStructuredType structuredType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        List<IEdmOperation> operations;
        if (boundOperationsMap.TryGetValue(structuredType, out operations))
        {
            foreach (IEdmFunction function in operations.OfType<IEdmFunction>())
            {
                IEdmTypeReference edmTypeReference = function.Parameters.First().Type;

                if (this.context.ExcludedBoundOperations?.Contains($"{function.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                {
                    continue;
                }

                string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                bool useEntityReference;
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, function, boundOperationsMap);
                this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                string functionName = function.Name;
                if (this.context.EnableNamingAlias)
                {
                    functionName = Customization.CustomizeNaming(functionName);
                }

                if (function.ReturnType.IsCollection())
                {
                    this.WriteBoundFunctionInEntityTypeReturnCollectionResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value, GetRevisionAnnotations(function));
                }
                else
                {
                    this.WriteBoundFunctionInEntityTypeReturnSingleResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value, GetRevisionAnnotations(function));
                }
            }

            foreach (IEdmAction action in operations.OfType<IEdmAction>())
            {
                IEdmTypeReference edmTypeReference = action.Parameters.First().Type;

                if (this.context.ExcludedBoundOperations?.Contains($"{action.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                {
                    continue;
                }

                string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                bool useEntityReference;
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, action, boundOperationsMap);
                this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                string returnTypeName;
                if (action.ReturnType != null)
                {
                    returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                    if (action.ReturnType.IsCollection())
                    {
                        returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
                    }
                    else
                    {
                        returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                    }
                }
                else
                {
                    returnTypeName = this.DataServiceActionQueryTypeName;
                }

                string actionName = action.Name;
                if (this.context.EnableNamingAlias)
                {
                    actionName = Customization.CustomizeNaming(actionName);
                }

                this.WriteBoundActionInEntityType(hideBaseMethod, GetFixedName(actionName), action.Name, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value, GetRevisionAnnotations(action));
            }
        }
    }

    internal bool CheckMethodsInBaseClass(IEdmStructuredType structuredType, IEdmOperation operation, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        if (structuredType != null)
        {
            List<IEdmOperation> operations;
            if (boundOperationsMap.TryGetValue(structuredType, out operations))
            {
                foreach (IEdmOperation op in operations)
                {
                    if (this.context.TargetLanguage == LanguageOption.VB)
                    {
                        if (operation.Name == op.Name)
                        {
                            return true;
                        }
                    }

                    List<IEdmOperationParameter> targetParameter = operation.Parameters.ToList();
                    List<IEdmOperationParameter> checkParameter = op.Parameters.ToList();
                    if (operation.Name == op.Name && targetParameter.Count == checkParameter.Count)
                    {
                        bool areSame = true;
                        for (int i = 1; i < targetParameter.Count; ++i)
                        {
                            var targetParameterType = targetParameter[i].Type;
                            var checkParameterType = checkParameter[i].Type;
                            if (!targetParameterType.Definition.Equals(checkParameterType.Definition)
                                || targetParameterType.IsNullable != checkParameterType.IsNullable)
                            {
                                areSame = false;
                                break;
                            }
                        }

                        if (areSame)
                        {
                            return true;
                        }
                    }
                }
            }

            return CheckMethodsInBaseClass(structuredType.BaseType, operation, boundOperationsMap);
        }

        return false;
    }

    internal void WriteEnumType(IEdmEnumType enumType)
    {
        this.WriteSummaryCommentForEnumType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(enumType.Name) : enumType.Name, GetDescriptionAnnotation(enumType)?.Value);
        if (enumType.IsFlags)
        {
            this.WriteEnumFlags();
        }

        string underlyingType = string.Empty;
        if (enumType.UnderlyingType != null && enumType.UnderlyingType.PrimitiveKind != EdmPrimitiveTypeKind.Int32)
        {
            underlyingType = Utils.GetClrTypeName(enumType.UnderlyingType, this);
            underlyingType = this.EnumUnderlyingTypeMarker + underlyingType;
        }

        this.WriteEnumDeclaration(this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(enumType.Name)) : GetFixedName(enumType.Name), enumType.Name, underlyingType);
        this.WriteMembersForEnumType(enumType.Members);
        this.WriteEnumEnd();
    }

    internal void WriteStructurdTypeDeclaration(IEdmStructuredType structuredType, string baseEntityType, string typeNameSuffix = null)
    {
        string abstractModifier = structuredType.IsAbstract && typeNameSuffix == null ? this.AbstractModifier : string.Empty;
        string baseTypeName = baseEntityType;

        if (typeNameSuffix == null)
        {
            if (structuredType.BaseType == null)
            {
                if (this.context.UseDataServiceCollection)
                {
                    if (this.context.TargetLanguage == LanguageOption.CSharp)
                    {
                        baseTypeName += string.IsNullOrEmpty(baseTypeName) ? this.ClassInheritMarker : ", ";
                    }

                    baseTypeName += this.NotifyPropertyChangedModifier;
                }
            }
            else
            {
                IEdmSchemaElement baseType = (IEdmSchemaElement)structuredType.BaseType;
                string baseTypeFixedName = this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(baseType.Name)) : GetFixedName(baseType.Name);
                baseTypeName = ((IEdmSchemaElement)structuredType).Namespace == baseType.Namespace ? baseTypeFixedName : this.context.GetPrefixedFullName(baseType, baseTypeFixedName, this);
                baseTypeName = this.ClassInheritMarker + baseTypeName;
            }
        }

        string structuredTypeName = this.context.EnableNamingAlias ?
            Customization.CustomizeNaming(((IEdmSchemaElement)structuredType).Name) : ((IEdmSchemaElement)structuredType).Name;
        this.WriteClassStartForStructuredType(abstractModifier, GetFixedName(structuredTypeName + typeNameSuffix), ((IEdmSchemaElement)structuredType).Name + typeNameSuffix, baseTypeName);
    }

    internal string GetSourceOrReturnTypeName(IEdmTypeReference typeReference, bool isEntitySingleType = false)
    {
        IEdmCollectionType edmCollectionType = typeReference.Definition as IEdmCollectionType;
        bool addNullableTemplate = true;
        if (edmCollectionType != null)
        {
            typeReference = edmCollectionType.ElementType;
            addNullableTemplate = false;
        }

        return Utils.GetClrTypeName(typeReference, this.context.UseDataServiceCollection, this, this.context, addNullableTemplate, isEntitySingleType:isEntitySingleType);
    }

    internal void GetParameterStrings(bool isBound, bool isAction, IEdmOperationParameter[] parameters, out string parameterString, out string parameterTypes, out string parameterExpressionString, out string parameterValues,  out bool useEntityReference)
    {
        parameterString = string.Empty;
        parameterExpressionString = string.Empty;
        parameterTypes = string.Empty;
        parameterValues = string.Empty;
        useEntityReference = false;

        int n = parameters.Count();
        for (int i = isBound ? 1 : 0; i < n; ++i)
        {
            IEdmOperationParameter param = parameters[i];
            if (i == (isBound ? 1 : 0))
            {
                if (this.context.TargetLanguage == LanguageOption.CSharp)
                {
                    parameterExpressionString += "\r\n                        ";
                }
                else
                {
                    parameterExpressionString += "\r\n                            ";
                }
            }

            string typeName = Utils.GetClrTypeName(param.Type, this.context.UseDataServiceCollection, this, this.context, true, true, true);
            if (this.context.TargetLanguage == LanguageOption.CSharp)
            {
                parameterString += typeName;
                parameterString += (" " + GetFixedName(param.Name));
            }
            else if (this.context.TargetLanguage == LanguageOption.VB)
            {
                parameterString += GetFixedName(param.Name);
                parameterString += (this.EnumUnderlyingTypeMarker + typeName);
            }

            parameterString += i == n - 1 ? string.Empty : ", ";
            parameterTypes += string.Format(CultureInfo.InvariantCulture, this.TypeofFormatter, typeName) + ", ";
            parameterExpressionString += this.GetParameterExpressionString(param, typeName) + ", ";

            if (i != (isBound ? 1 : 0))
            {
                parameterValues += ",\r\n                    ";
            }

            if (isAction)
            {
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.BodyOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
            else  if (param.Type.IsEntity() || (param.Type.IsCollection() && param.Type.AsCollection().ElementType().IsEntity()))
            {
                useEntityReference = true;
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.UriEntityOperationParameterConstructor, param.Name, GetFixedName(param.Name),"useEntityReference");
            }
            else
            {
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.UriOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
        }
    }

    internal string GetParameterExpressionString(IEdmOperationParameter param, string typeName)
    {
        string clrTypeName;
        IEdmType edmType = param.Type.Definition;
        IEdmPrimitiveType edmPrimitiveType = edmType as IEdmPrimitiveType;
        if (edmPrimitiveType != null)
        {
            clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, this);
            if (param.Type.IsNullable && !this.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind))
            {
                clrTypeName += "?";
            }

            return string.Format(CultureInfo.InvariantCulture, this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), clrTypeName);
        }

        return string.Format(CultureInfo.InvariantCulture, this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), typeName);
    }

    // This is to solve duplicate names between property and type
    internal void SetPropertyIdentifierMappingsIfNameConflicts(string typeName, IEdmStructuredType structuredType)
    {
        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        // PropertyName in VB is case-insensitive.
        bool isLanguageCaseSensitive = this.context.TargetLanguage == LanguageOption.CSharp;

        // In VB, it is allowed that a type has a property whose name is same with the type's name
        bool allowPropertyNameSameWithTypeName = this.context.TargetLanguage == LanguageOption.VB;

        Func<string, string> customizePropertyName = (name) => { return this.context.EnableNamingAlias ? Customization.CustomizeNaming(name) : name; };

        var propertyGroups = structuredType.Properties()
            .GroupBy(p => isLanguageCaseSensitive ? customizePropertyName(p.Name) : customizePropertyName(p.Name).ToUpperInvariant());

        // If the group contains more than one property, or the property in the group has the same name with the type (only for C#), we need to rename the property
        var propertyToBeRenamedGroups = propertyGroups.Where(g => g.Count() > 1 || !allowPropertyNameSameWithTypeName && g.Key == typeName);

        var knownIdentifiers = propertyGroups.Select(g => customizePropertyName(g.First().Name)).ToList();
        if(!allowPropertyNameSameWithTypeName && !knownIdentifiers.Contains(typeName))
        {
            knownIdentifiers.Add(typeName);
        }
        UniqueIdentifierService uniqueIdentifierService =
            new UniqueIdentifierService(knownIdentifiers, isLanguageCaseSensitive);

        IdentifierMappings.Clear();
        foreach (IGrouping<string, IEdmProperty> g in propertyToBeRenamedGroups)
        {
            bool hasPropertyNameSameWithCustomizedPropertyName = false;
            int itemCount = g.Count();
            for (int i = 0; i < itemCount; i++)
            {
                var property = g.ElementAt(i);
                var customizedPropertyName = customizePropertyName(property.Name);

                if(this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                {
                    hasPropertyNameSameWithCustomizedPropertyName = true;
                }

                if(isLanguageCaseSensitive)
                {
                    // If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group
                    if(customizedPropertyName != typeName
                        && (customizedPropertyName == property.Name
                            || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1)))
                    {
                        continue;
                    }
                }
                else
                {
                    // When EnableNamingAlias = true, If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group.
                    if((this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                        || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1))
                    {
                        continue;
                    }
                }
                var renamedPropertyName = uniqueIdentifierService.GetUniqueIdentifier(customizedPropertyName);
                    IdentifierMappings.Add(property.Name, renamedPropertyName);
            }
        }
    }

    internal void WriteTypeStaticCreateMethod(string typeName, IEdmStructuredType structuredType)
    {
        Debug.Assert(structuredType != null, "structuredType != null");
        if (structuredType.IsAbstract)
        {
            return;
        }

        Func<IEdmProperty, bool> hasDefault = p => p.PropertyKind == EdmPropertyKind.Structural && ((IEdmStructuralProperty)p).DefaultValueString != null;

        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        IEnumerable<IEdmProperty> parameters = structuredType.Properties()
            .Where(p => !p.Type.IsNullable && !p.Type.IsCollection() && !hasDefault(p));
        if (!parameters.Any())
        {
            return;
        }

        this.WriteSummaryCommentForStaticCreateMethod(typeName);

        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService( /*IsLanguageCaseSensitive*/true);
        string instanceName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(typeName));
        KeyValuePair<IEdmProperty, string>[] propertyToParameterNamePairs = parameters
            .Select(p =>
                new KeyValuePair<IEdmProperty, string>(p,
                    uniqueIdentifierService.GetUniqueParameterName(
                        IdentifierMappings.ContainsKey(p.Name) ? IdentifierMappings[p.Name] : p.Name)))
            .ToArray();

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            string propertyName = propertyToParameterNamePair.Key.Name;
            propertyName = IdentifierMappings.ContainsKey(propertyName) ?
                IdentifierMappings[propertyName] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(propertyName) : propertyName);
            this.WriteParameterCommentForStaticCreateMethod(propertyToParameterNamePair.Value, propertyName);
        }

        propertyToParameterNamePairs = propertyToParameterNamePairs
            .Select(p => p = new KeyValuePair<IEdmProperty, string>(p.Key, GetFixedName(p.Value)))
            .ToArray();

        this.WriteDeclarationStartForStaticCreateMethod(typeName, GetFixedName(typeName));
        this.WriteStaticCreateMethodParameters(propertyToParameterNamePairs);
        this.WriteDeclarationEndForStaticCreateMethod(GetFixedName(typeName), instanceName);

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            IEdmProperty property = propertyToParameterNamePair.Key;
            string parameterName = propertyToParameterNamePair.Value;

            Debug.Assert(!property.Type.IsCollection(), "!property.Type.IsCollection()");
            Debug.Assert(!property.Type.IsNullable, "!property.Type.IsNullable");

            // The static create method only sets non-nullable properties. We should add the null check if the type of the property is not a clr ValueType.
            // For now we add the null check if the property type is non-primitive. We should add the null check for non-ValueType primitives in the future.
            if (!property.Type.IsPrimitive() && !property.Type.IsEnum())
            {
                this.WriteParameterNullCheckForStaticCreateMethod(parameterName);
            }

            var uniqIdentifier = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);
            this.WritePropertyValueAssignmentForStaticCreateMethod(instanceName,
                GetFixedName(uniqIdentifier),
                parameterName);
        }

        this.WriteMethodEndForStaticCreateMethod(instanceName);
    }

    internal void WriteStaticCreateMethodParameters(KeyValuePair<IEdmProperty, string>[] propertyToParameterPairs)
    {
        if (propertyToParameterPairs.Length == 0)
        {
            return;
        }

        // If the number of parameters are greater than 5, we put them in separate lines.
        string parameterSeparator = propertyToParameterPairs.Length > 5 ? this.ParameterSeparator : ", ";
        for (int idx = 0; idx < propertyToParameterPairs.Length; idx++)
        {
            KeyValuePair<IEdmProperty, string> propertyToParameterPair = propertyToParameterPairs[idx];

            string parameterType = Utils.GetClrTypeName(propertyToParameterPair.Key.Type, this.context.UseDataServiceCollection, this, this.context);
            string parameterName = propertyToParameterPair.Value;
            if (idx == propertyToParameterPairs.Length - 1)
            {
                // No separator after the last parameter.
                parameterSeparator = string.Empty;
            }

            this.WriteParameterForStaticCreateMethod(parameterType, GetFixedName(parameterName), parameterSeparator);
        }
    }

    internal void WritePropertiesForStructuredType(IEdmStructuredType structuredType)
    {
         bool useDataServiceCollection = this.context.UseDataServiceCollection;
         IEnumerable<IEdmProperty> properties = structuredType.DeclaredProperties;

        var propertyInfos = properties.Select(property =>
        {
            string propertyName = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);

            return new
                {
                    PropertyType = Utils.GetClrTypeName(property.Type, useDataServiceCollection, this, this.context),
                    PropertyVanillaName = property.Name,
                    PropertyName = propertyName,
                    FixedPropertyName = GetFixedName(propertyName),
                    PrivatePropertyName = "_" + propertyName,
                    PropertyInitializationValue = Utils.GetPropertyInitializationValue(property, useDataServiceCollection, this, this.context),
                    PropertyAttribute = string.Empty,
                    PropertyDescription = GetDescriptionAnnotation(property)?.Value,
                    PropertyMaxLength = property.Type.AsString()?.MaxLength,
                    IsNullable = property.Type.IsNullable,
                    RevisionAnnotations = GetRevisionAnnotations(property)
                };
        }).ToList();

        // NOTE: If structured type has a base type and that base type is open, then the dynamic properties property is emitted on the client base type
        if (structuredType.IsOpen && (structuredType.BaseType == null || (structuredType.BaseType != null && !structuredType.BaseType.IsOpen)))
        {
            string containerPropertyName = GetContainerPropertyName(structuredType);

            string containerPropertyAttribute = string.Empty;
            if (this.context.EmitContainerPropertyAttribute)
            {
                containerPropertyAttribute = this.ContainerPropertyAttribute;
            }

            // Add empty dictionary to the anonymous type
            IDictionary<string, string> emptyDict = new Dictionary<string, string>();

            propertyInfos.Add(new
            {
                PropertyType = string.Format(this.DictionaryInterfaceName, this.StringTypeName, this.ObjectTypeName),
                PropertyVanillaName = containerPropertyName,
                PropertyName = containerPropertyName,
                FixedPropertyName = containerPropertyName,
                PrivatePropertyName = "_" + containerPropertyName,
                PropertyInitializationValue = string.Format(this.DictionaryConstructor, this.StringTypeName, this.ObjectTypeName),
                PropertyAttribute = containerPropertyAttribute,
                PropertyDescription = string.Empty,
                PropertyMaxLength = (int?)null,
                IsNullable = true,
                RevisionAnnotations = emptyDict
            });
        }

        // Private name should not confict with field name
        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(propertyInfos.Select(_ => _.FixedPropertyName),
            this.context.TargetLanguage == LanguageOption.CSharp);

        foreach (var propertyInfo in propertyInfos)
        {
            string privatePropertyName = uniqueIdentifierService.GetUniqueIdentifier("_" + propertyInfo.PropertyName);

            this.WritePropertyForStructuredType(new PropertyOptions {
                PropertyType = propertyInfo.PropertyType,
                OriginalPropertyName = propertyInfo.PropertyVanillaName,
                PropertyName = propertyInfo.PropertyName,
                FixedPropertyName = propertyInfo.FixedPropertyName,
                PrivatePropertyName = privatePropertyName,
                PropertyInitializationValue = propertyInfo.PropertyInitializationValue,
                PropertyAttribute = propertyInfo.PropertyAttribute,
                PropertyDescription = propertyInfo.PropertyDescription,
                PropertyMaxLength = propertyInfo.PropertyMaxLength,
                WriteOnPropertyChanged = useDataServiceCollection,
                IsNullable = propertyInfo.IsNullable,
                RevisionAnnotations = propertyInfo.RevisionAnnotations
            });
        }
    }

    internal void WriteMembersForEnumType(IEnumerable<IEdmEnumMember> members)
    {
        int n = members.Count();
        for (int idx = 0; idx < n; ++idx)
        {
            IEdmEnumMember member = members.ElementAt(idx);
            string value = string.Empty;
            if (member.Value != null)
            {
                IEdmEnumMemberValue integerValue = member.Value as IEdmEnumMemberValue;
                if (integerValue != null)
                {
                    value = " = " + integerValue.Value.ToString(CultureInfo.InvariantCulture);
                }
            }

            string memberName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(member.Name) : member.Name;
            this.WriteMemberForEnumType(GetFixedName(memberName) + value, member.Name, idx == n - 1);
        }
    }

    internal string GetFixedName(string originalName)
    {
        string fixedName = originalName;

        if (this.LanguageKeywords.Contains(fixedName))
        {
            fixedName = string.Format(CultureInfo.InvariantCulture, this.FixPattern, fixedName);
        }

        return fixedName;
    }

    internal string GetElementTypeName(IEdmEntityType elementType, IEdmEntityContainer container)
    {
        string elementTypeName = elementType.Name;

        if (this.context.EnableNamingAlias)
        {
            elementTypeName = Customization.CustomizeNaming(elementTypeName);
        }

        if (elementType.Namespace != container.Namespace)
        {
            elementTypeName = this.context.GetPrefixedFullName(elementType, GetFixedName(elementTypeName), this);
        }

        return elementTypeName;
    }

    /// <summary>
    /// Returns a non-conflicting name for the container property.
    /// The preferred name for the container property will be suffixed with an integer
    /// in the odd case that there exists a declared property with a similar name
    /// </summary>
    private string GetContainerPropertyName(IEdmStructuredType structuredType)
    {
        int suffix = 2;
        bool conflict = true;
        string containerPropertyTemp = ContainerPropertyBase;

        do
        {
            IEdmStructuredType tempType = structuredType;

            while(tempType != null)
            {
                conflict = tempType.DeclaredProperties.Any(p => p.Name.Equals(containerPropertyTemp, StringComparison.Ordinal));
                if (conflict)
                {
                    break;
                }
                tempType = tempType.BaseType;
            }

            if (conflict)
            {
                containerPropertyTemp = ContainerPropertyBase + suffix.ToString();
                suffix++;
            }
        } while(conflict);

        return containerPropertyTemp;
    }

    /// <summary>
    /// Searches through model's vocabulary annotations and returns annotation of term 'Description' if present
    /// </summary>
    private IEdmStringConstantExpression GetDescriptionAnnotation(IEdmVocabularyAnnotatable model)
    {
        return model.VocabularyAnnotations(this.context.EdmModel).Where(x => x.Term.Name == "Description")
            .Select(x => x.Value).FirstOrDefault() as IEdmStringConstantExpression;
    }

    /// <summary>
    /// Searches through model's vocabulary annotations and returns dictionary of term 'Revisions' annotation kinds.
    /// </summary>
    private IDictionary<string,string> GetRevisionAnnotations(IEdmVocabularyAnnotatable schemaElement)
    {
        IEnumerable<IEdmExpression> collection = schemaElement.VocabularyAnnotations(this.context.EdmModel).Where(x => x.Term.FullName() == "Org.OData.Core.V1.Revisions")
            .Select(x => x.Value);

        IDictionary<string, string> revisionsAnnotation = new Dictionary<string, string>();

        IEdmCollectionExpression semanticElement = collection?.FirstOrDefault() as IEdmCollectionExpression;

        if (semanticElement != null)
        {
            foreach (IEdmRecordExpression element in semanticElement.Elements)
            {
                string description = (element?.Properties.Where(x => x.Name == "Description").Select(x => x.Value).FirstOrDefault() as IEdmStringConstantExpression)?.Value;

                if (string.IsNullOrEmpty(description))
                {
                    throw new Exception("Description property is missing from the Annotation Xml");
                }

                IEdmEnumMemberExpression revisionKind = element?.Properties.Where(x => x.Name == "Kind").Select(x => x.Value).FirstOrDefault() as IEdmEnumMemberExpression;

                if (revisionKind == null)
                {
                    throw new Exception("Kind property is missing from the Annotation Xml");
                }

                string name = revisionKind.EnumMembers.FirstOrDefault().Name;
                revisionsAnnotation.Add(name, description);
            }
        }

        return revisionsAnnotation;

    }
}

/// <summary>
/// Base class for text transformation
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "11.0.0.0")]
public abstract class TemplateBase
{
    #region Fields
    private global::System.Text.StringBuilder generationEnvironmentField;
    private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
    private global::System.Collections.Generic.List<int> indentLengthsField;
    private string currentIndentField = "";
    private bool endsWithNewline;
    private global::System.Collections.Generic.IDictionary<string, object> sessionField;
    #endregion
    #region Properties
    /// <summary>
    /// The string builder that generation-time code is using to assemble generated output
    /// </summary>
    protected System.Text.StringBuilder GenerationEnvironment
    {
        get
        {
            if ((this.generationEnvironmentField == null))
            {
                this.generationEnvironmentField = new global::System.Text.StringBuilder();
            }
            return this.generationEnvironmentField;
        }
        set
        {
            this.generationEnvironmentField = value;
        }
    }
    /// <summary>
    /// The error collection for the generation process
    /// </summary>
    public System.CodeDom.Compiler.CompilerErrorCollection Errors
    {
        get
        {
            if ((this.errorsField == null))
            {
                this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
            }
            return this.errorsField;
        }
    }
    /// <summary>
    /// A list of the lengths of each indent that was added with PushIndent
    /// </summary>
    private System.Collections.Generic.List<int> indentLengths
    {
        get
        {
            if ((this.indentLengthsField == null))
            {
                this.indentLengthsField = new global::System.Collections.Generic.List<int>();
            }
            return this.indentLengthsField;
        }
    }
    /// <summary>
    /// Gets the current indent we use when adding lines to the output
    /// </summary>
    public string CurrentIndent
    {
        get
        {
            return this.currentIndentField;
        }
    }
    /// <summary>
    /// Current transformation session
    /// </summary>
    public virtual global::System.Collections.Generic.IDictionary<string, object> Session
    {
        get
        {
            return this.sessionField;
        }
        set
        {
            this.sessionField = value;
        }
    }
    #endregion

    /// <summary>
    /// Create the template output
    /// </summary>
    public abstract string TransformText();

    #region Transform-time helpers
    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void Write(string textToAppend)
    {
        if (string.IsNullOrEmpty(textToAppend))
        {
            return;
        }
        // If we're starting off, or if the previous text ended with a newline,
        // we have to append the current indent first.
        if (((this.GenerationEnvironment.Length == 0)
                    || this.endsWithNewline))
        {
            this.GenerationEnvironment.Append(this.currentIndentField);
            this.endsWithNewline = false;
        }
        // Check if the current text ends with a newline
        if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
        {
            this.endsWithNewline = true;
        }
        // This is an optimization. If the current indent is "", then we don't have to do any
        // of the more complex stuff further down.
        if ((this.currentIndentField.Length == 0))
        {
            this.GenerationEnvironment.Append(textToAppend);
            return;
        }
        // Everywhere there is a newline in the text, add an indent after it
        textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
        // If the text ends with a newline, then we should strip off the indent added at the very end
        // because the appropriate indent will be added when the next time Write() is called
        if (this.endsWithNewline)
        {
            this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
        }
        else
        {
            this.GenerationEnvironment.Append(textToAppend);
        }
    }
    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void WriteLine(string textToAppend)
    {
        this.Write(textToAppend);
        this.GenerationEnvironment.AppendLine();
        this.endsWithNewline = true;
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void Write(string format, params object[] args)
    {
        this.Write(string.Format(CultureInfo.InvariantCulture, format, args));
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void WriteLine(string format, params object[] args)
    {
        this.WriteLine(string.Format(CultureInfo.InvariantCulture, format, args));
    }
    /// <summary>
    /// Raise an error
    /// </summary>
    public void Error(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Raise a warning
    /// </summary>
    public void Warning(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        error.IsWarning = true;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Increase the indent
    /// </summary>
    public void PushIndent(string indent)
    {
        if ((indent == null))
        {
            throw new global::System.ArgumentNullException("indent");
        }
        this.currentIndentField = (this.currentIndentField + indent);
        this.indentLengths.Add(indent.Length);
    }
    /// <summary>
    /// Remove the last indent that was added with PushIndent
    /// </summary>
    public string PopIndent()
    {
        string returnValue = "";
        if ((this.indentLengths.Count > 0))
        {
            int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
            this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
            if ((indentLength > 0))
            {
                returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
            }
        }
        return returnValue;
    }
    /// <summary>
    /// Remove any indentation
    /// </summary>
    public void ClearIndent()
    {
        this.indentLengths.Clear();
        this.currentIndentField = "";
    }
    #endregion
    #region ToString Helpers
    /// <summary>
    /// Utility class to produce culture-oriented representation of an object as a string.
    /// </summary>
    public class ToStringInstanceHelper
    {
        private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
        /// <summary>
        /// Gets or sets format provider to be used by ToStringWithCulture method.
        /// </summary>
        public System.IFormatProvider FormatProvider
        {
            get
            {
                return this.formatProviderField ;
            }
            set
            {
                if ((value != null))
                {
                    this.formatProviderField  = value;
                }
            }
        }
        /// <summary>
        /// This is called from the compile/run appdomain to convert objects within an expression block to a string
        /// </summary>
        public string ToStringWithCulture(object objectToConvert)
        {
            if ((objectToConvert == null))
            {
                throw new global::System.ArgumentNullException("objectToConvert");
            }
            System.Type t = objectToConvert.GetType();
            System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                        typeof(System.IFormatProvider)});
            if ((method == null))
            {
                return objectToConvert.ToString();
            }
            else
            {
                return ((string)(method.Invoke(objectToConvert, new object[] {
                            this.formatProviderField })));
            }
        }
    }
    private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
    /// <summary>
    /// Helper to produce culture-oriented representation of an object as a string
    /// </summary>
    public ToStringInstanceHelper ToStringHelper
    {
        get
        {
            return this.toStringHelperField;
        }
    }
    #endregion
}

/// <summary>
/// Service making names within a scope unique. Initialize a new instance for every scope.
/// </summary>
internal sealed class UniqueIdentifierService
{
    // This is the list of keywords we check against when creating parameter names from propert.
    // If a name matches this keyword we prefix it.
    private static readonly string[] Keywords = new string[] {"class", "event"};

    /// <summary>
    /// Hash set to detect identifier collision.
    /// </summary>
    private readonly HashSet<string> knownIdentifiers;

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="identifiers">identifiers used to detect collision.</param>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(IEnumerable<string> identifiers, bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(identifiers ?? Enumerable.Empty<string>(), caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Given an identifier, makes it unique within the scope by adding
    /// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
    /// </summary>
    /// <param name="identifier">Identifier. Must not be null or empty.</param>
    /// <returns>Identifier adjusted to be unique within the scope.</returns>
    internal string GetUniqueIdentifier(string identifier)
    {
        Debug.Assert(!string.IsNullOrEmpty(identifier), "identifier is null or empty");

        // find a unique name by adding suffix as necessary
        int numberOfConflicts = 0;
        string uniqueIdentifier = identifier;
        while (this.knownIdentifiers.Contains(uniqueIdentifier))
        {
            ++numberOfConflicts;
            uniqueIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
        }

        // remember the identifier in this scope
        Debug.Assert(!this.knownIdentifiers.Contains(uniqueIdentifier), "we just made it unique");
        this.knownIdentifiers.Add(uniqueIdentifier);

        return uniqueIdentifier;
    }

    /// <summary>
    /// Fix up the given parameter name and make it unique.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <returns>Fixed parameter name.</returns>
    internal string GetUniqueParameterName(string name)
    {
        name = Utils.CamelCase(name);

        // FxCop consider 'iD' as violation, we will change any property that is 'id'(case insensitive) to 'ID'
        if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
        {
            name = "ID";
        }

        return this.GetUniqueIdentifier(name);
    }
}

/// <summary>
/// Utility class.
/// </summary>
internal static class Utils
{
    /// <summary>
    /// Serializes the xml element to a string.
    /// </summary>
    /// <param name="xml">The xml element to serialize.</param>
    /// <returns>The string representation of the xml.</returns>
    internal static string SerializeToString(XElement xml)
    {
        // because comment nodes can contain special characters that are hard to embed in VisualBasic, remove them here
        xml.DescendantNodes().OfType<XComment>().Remove();

        var stringBuilder = new StringBuilder();
        using (var writer = XmlWriter.Create(
            stringBuilder,
            new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                NewLineHandling = NewLineHandling.Replace,
                Indent = true,
            }))
        {
            xml.WriteTo(writer);
        }

        return stringBuilder.ToString();
    }

    /// <summary>
    /// Changes the text to use camel case, which lower case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in camel case</returns>
    internal static string CamelCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Changes the text to use pascal case, which upper case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in pascal case</returns>
    internal static string PascalCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Gets the clr type name from the give type reference.
    /// </summary>
    /// <param name="edmTypeReference">The type reference in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <param name="addNullableTemplate">This flag indicates whether to return the type name in nullable format</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by global prefix</param>
    /// <param name="isOperationParameter">This flag indicates whether the edmTypeReference is for an operation parameter</param>
    /// <returns>The clr type name of the type reference.</returns>
    internal static string GetClrTypeName(IEdmTypeReference edmTypeReference, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context, bool addNullableTemplate = true, bool needGlobalPrefix = true, bool isOperationParameter = false, bool isEntitySingleType = false)
    {
        IEdmType edmType = edmTypeReference.Definition;
        if (edmType is IEdmPrimitiveType edmPrimitiveType)
        {
            var clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, clientTemplate);
            if (edmTypeReference.IsNullable && !clientTemplate.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind) && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmComplexType edmComplexType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmComplexType,
                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmComplexType.Name)) : clientTemplate.GetFixedName(edmComplexType.Name), clientTemplate);
            return clrTypeName;
        }
        if (edmType is IEdmEnumType edmEnumType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmEnumType,
                context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEnumType.Name)) : clientTemplate.GetFixedName(edmEnumType.Name), clientTemplate, needGlobalPrefix);
            if (edmTypeReference.IsNullable && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmEntityType edmEntityType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmEntityType,
                context.EnableNamingAlias
                ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEntityType.Name) + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty))
                : clientTemplate.GetFixedName(edmEntityType.Name + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty)),
                clientTemplate);
            return clrTypeName;
        }
        if (edmType is IEdmTypeDefinition edmTypeDefinition)
        {
            var underlyingType = edmTypeDefinition.UnderlyingType;
            var clrTypeName = Utils.GetClrTypeName(underlyingType, clientTemplate);
            if (edmTypeReference.IsNullable && !clientTemplate.ClrReferenceTypes.Contains(underlyingType.PrimitiveKind) && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmCollectionType edmCollectionType)
        {
            string clrTypeName = null;
            IEdmTypeReference elementTypeReference = edmCollectionType.ElementType;
            IEdmPrimitiveType primitiveElementType = elementTypeReference.Definition as IEdmPrimitiveType;
            if (primitiveElementType != null)
            {
                clrTypeName = Utils.GetClrTypeName(primitiveElementType, clientTemplate);
            }
            else
            {
                IEdmSchemaElement schemaElement = (IEdmSchemaElement)elementTypeReference.Definition;
                clrTypeName = context.GetPrefixedFullName(schemaElement,
                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(schemaElement.Name)) : clientTemplate.GetFixedName(schemaElement.Name), clientTemplate);
            }

            string collectionTypeName = isOperationParameter
                                            ? clientTemplate.ICollectionOfTStructureTemplate
                                            : (useDataServiceCollection
                                                ? (elementTypeReference.TypeKind() == EdmTypeKind.Entity
                                                    ? clientTemplate.DataServiceCollectionStructureTemplate
                                                    : clientTemplate.ObservableCollectionStructureTemplate)
                                                : clientTemplate.ObjectModelCollectionStructureTemplate);

            clrTypeName = string.Format(CultureInfo.InvariantCulture, collectionTypeName, clrTypeName);
            return clrTypeName;
        }

        var errors = edmTypeReference.Errors().Select(e => e.ErrorMessage);
        throw new Exception(
            $"Could not get CLR type name for EDM type '{edmTypeReference.FullName()}'{System.Environment.NewLine}{string.Join(global::System.Environment.NewLine, errors)}");
    }

    /// <summary>
    /// Gets the value expression to initualize the property with.
    /// </summary>
    /// <param name="property">The property in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <returns>The value expression to initualize the property with.</returns>
    internal static string GetPropertyInitializationValue(IEdmProperty property, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context)
    {
        IEdmTypeReference edmTypeReference = property.Type;
        IEdmCollectionTypeReference edmCollectionTypeReference = edmTypeReference as IEdmCollectionTypeReference;
        if (edmCollectionTypeReference == null)
        {
            IEdmStructuralProperty structuredProperty = property as IEdmStructuralProperty;
            if (structuredProperty != null)
            {
                if (!string.IsNullOrEmpty(structuredProperty.DefaultValueString))
                {
                    string valueClrType = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                    string defaultValue = structuredProperty.DefaultValueString;
                    bool isCSharpTemplate = clientTemplate is ODataClientCSharpTemplate;
                    if (edmTypeReference.Definition.TypeKind == EdmTypeKind.Enum)
                    {
                        var enumValues = defaultValue.Split(',');
                        string fullenumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                        string enumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context, false, false);
                        List<string> customizedEnumValues = new List<string>();
                        foreach(var enumValue in enumValues)
                        {
                            string currentEnumValue = enumValue.Trim();
                            int indexFirst = currentEnumValue.IndexOf('\'') + 1;
                            int indexLast = currentEnumValue.LastIndexOf('\'');
                            if (indexFirst > 0 && indexLast > indexFirst)
                            {
                                currentEnumValue = currentEnumValue.Substring(indexFirst, indexLast - indexFirst);
                            }

                            var customizedEnumValue = context.EnableNamingAlias ? Customization.CustomizeNaming(currentEnumValue) : currentEnumValue;
                            if (isCSharpTemplate)
                            {
                                currentEnumValue = "(" + fullenumTypeName + ")" + clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + customizedEnumValue  + "\")";
                            }
                            else
                            {
                                currentEnumValue = clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + currentEnumValue  + "\")";
                            }
                            customizedEnumValues.Add(currentEnumValue);
                        }
                        if (isCSharpTemplate)
                        {
                            return string.Join(" | ", customizedEnumValues);
                        }
                        else
                        {
                            return string.Join(" Or ", customizedEnumValues);
                        }
                    }

                    if (valueClrType.Equals(clientTemplate.StringTypeName))
                    {
                        defaultValue = "\"" + defaultValue + "\"";
                    }
                    else if (valueClrType.Equals(clientTemplate.BooleanTypeName))
                    {
                        // EDMX specifies boolean defaults with capital letter, C# needs this string to be lower case.
                        if (isCSharpTemplate)
                            defaultValue = defaultValue.ToLower();
                    }
                    else if (valueClrType.Equals(clientTemplate.BinaryTypeName))
                    {
                        defaultValue = "System.Text.Encoding.UTF8.GetBytes(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.SingleTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "f";
                        }
                        else
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "F";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.DecimalTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            // decimal in C# must be initialized with 'm' at the end, like Decimal dec = 3.00m
                            defaultValue = defaultValue.EndsWith("m", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "m";
                        }
                        else
                        {
                            // decimal in VB must be initialized with 'D' at the end, like Decimal dec = 3.00D
                            defaultValue = defaultValue.ToLower(CultureInfo.InvariantCulture).Replace("m", "D");
                            defaultValue = defaultValue.EndsWith("D", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "D";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.GuidTypeName)
                        | valueClrType.Equals(clientTemplate.DateTimeOffsetTypeName)
                        | valueClrType.Equals(clientTemplate.DateTypeName)
                        | valueClrType.Equals(clientTemplate.TimeOfDayTypeName))
                    {
                        defaultValue = valueClrType + ".Parse(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.DurationTypeName))
                    {
                        defaultValue = clientTemplate.XmlConvertClassName + ".ToTimeSpan(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Contains("Microsoft.Spatial"))
                    {
                        defaultValue = string.Format(CultureInfo.InvariantCulture, clientTemplate.GeoTypeInitializePattern, valueClrType, defaultValue);
                    }

                    return defaultValue;
                }
                else
                {
                    // doesn't have a default value
                    return null;
                }
            }
            else
            {
                // only structured property has default value
                return null;
            }
        }
        else
        {
            string constructorParameters;
            if (edmCollectionTypeReference.ElementType().IsEntity() && useDataServiceCollection)
            {
                constructorParameters = clientTemplate.DataServiceCollectionConstructorParameters;
            }
            else
            {
                constructorParameters = "()";
            }

            string clrTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
            return clientTemplate.NewModifier + clrTypeName + constructorParameters;
        }
    }

    /// <summary>
    /// Gets the corresponding nullable type name for the given clr type
    /// </summary>
    /// <param name="clrTypeName">Original CLR type name.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <returns>The nullable version of the specified type name.</returns>
    internal static string GetNullableClrTypeName(string clrTypeName, ODataClientTemplate clientTemplate)
    {
        return string.Format(CultureInfo.InvariantCulture, clientTemplate.SystemNullableStructureTemplate, clrTypeName);
    }

    /// <summary>
    /// Gets the clr type name from the give Edm primitive type.
    /// </summary>
    /// <param name="edmPrimitiveType">The Edm primitive type in question.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <returns>The clr type name of the Edm primitive type.</returns>
    internal static string GetClrTypeName(IEdmPrimitiveType edmPrimitiveType, ODataClientTemplate clientTemplate)
    {
        EdmPrimitiveTypeKind kind = edmPrimitiveType.PrimitiveKind;

        string type="UNKNOWN";
        if (kind==EdmPrimitiveTypeKind.Int32)
        {
            type= clientTemplate.Int32TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.String)
        {
            type= clientTemplate.StringTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Binary)
        {
            type= clientTemplate.BinaryTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Decimal)
        {
            type= clientTemplate.DecimalTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Int16)
        {
            type= clientTemplate.Int16TypeName;
        }
        else if(kind==EdmPrimitiveTypeKind.Single)
        {
            type= clientTemplate.SingleTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Boolean)
        {
            type= clientTemplate.BooleanTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Double)
        {
            type= clientTemplate.DoubleTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Guid)
        {
            type= clientTemplate.GuidTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Byte)
        {
            type= clientTemplate.ByteTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Int64)
        {
            type= clientTemplate.Int64TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.SByte)
        {
            type= clientTemplate.SByteTypeName;
        }
        else if (kind == EdmPrimitiveTypeKind.Stream)
        {
            type= clientTemplate.DataServiceStreamLinkTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Geography)
        {
            type= clientTemplate.GeographyTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPoint)
        {
            type= clientTemplate.GeographyPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyLineString)
        {
            type= clientTemplate.GeographyLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPolygon)
        {
            type= clientTemplate.GeographyPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyCollection)
        {
            type= clientTemplate.GeographyCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPolygon)
        {
            type= clientTemplate.GeographyMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiLineString)
        {
            type= clientTemplate.GeographyMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPoint)
        {
            type= clientTemplate.GeographyMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Geometry)
        {
            type= clientTemplate.GeometryTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPoint)
        {
            type= clientTemplate.GeometryPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryLineString)
        {
            type= clientTemplate.GeometryLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPolygon)
        {
            type= clientTemplate.GeometryPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryCollection)
        {
            type= clientTemplate.GeometryCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPolygon)
        {
            type= clientTemplate.GeometryMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiLineString)
        {
            type= clientTemplate.GeometryMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPoint)
        {
            type= clientTemplate.GeometryMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.DateTimeOffset)
        {
            type= clientTemplate.DateTimeOffsetTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Duration)
        {
            type= clientTemplate.DurationTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Date)
        {
            type= clientTemplate.DateTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.TimeOfDay)
        {
            type= clientTemplate.TimeOfDayTypeName;
        }
        else
        {
            throw new Exception("Type "+kind.ToString()+" is unrecognized");
        }

        return type;
    }
}

public sealed class ODataClientCSharpTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientCSharpTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix { get {return "global::"; } }
    internal override string SystemTypeTypeName { get { return "global::System.Type"; } }
    internal override string AbstractModifier { get { return " abstract"; } }
    internal override string PublicAccessModifier { get { return "public"; } }
    internal override string InternalAccessModifier { get { return "internal"; } }
    internal override string DataServiceActionQueryTypeName { get { return "global::Microsoft.OData.Client.DataServiceActionQuery"; } }
    internal override string DataServiceActionQuerySingleOfTStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceActionQuerySingle<{0}>"; } }
    internal override string DataServiceActionQueryOfTStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceActionQuery<{0}>"; } }
    internal override string NotifyPropertyChangedModifier { get { return "global::System.ComponentModel.INotifyPropertyChanged"; } }
    internal override string ClassInheritMarker { get { return " : "; } }
    internal override string ParameterSeparator { get { return ", \r\n                    "; } }
    internal override string KeyParameterSeparator { get { return ", \r\n            "; } }
    internal override string KeyDictionaryItemSeparator { get { return ", \r\n                "; } }
    internal override string SystemNullableStructureTemplate { get { return "global::System.Nullable<{0}>"; } }
    internal override string ICollectionOfTStructureTemplate { get { return "global::System.Collections.Generic.ICollection<{0}>"; } }
    internal override string DataServiceCollectionStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceCollection<{0}>"; } }
    internal override string DataServiceQueryStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceQuery<{0}>"; } }
    internal override string DataServiceQuerySingleStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceQuerySingle<{0}>"; } }
    internal override string ObservableCollectionStructureTemplate { get { return "global::System.Collections.ObjectModel.ObservableCollection<{0}>"; } }
    internal override string ObjectModelCollectionStructureTemplate { get { return "global::System.Collections.ObjectModel.Collection<{0}>"; } }
    internal override string DataServiceCollectionConstructorParameters { get { return "(null, global::Microsoft.OData.Client.TrackingMode.None)"; } }
    internal override string NewModifier { get { return "new "; } }
    internal override string GeoTypeInitializePattern { get { return "global::Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(false).Read<{0}>(new global::System.IO.StringReader(\"{1}\"))"; } }
    internal override string ObjectTypeName { get { return "object"; } }
    internal override string Int32TypeName { get { return "int"; } }
    internal override string StringTypeName { get { return "string"; } }
    internal override string BinaryTypeName { get { return "byte[]"; } }
    internal override string DecimalTypeName { get { return "decimal"; } }
    internal override string Int16TypeName { get { return "short"; } }
    internal override string SingleTypeName { get { return "float"; } }
    internal override string BooleanTypeName { get { return "bool"; } }
    internal override string DoubleTypeName { get { return "double"; } }
    internal override string GuidTypeName { get { return "global::System.Guid"; } }
    internal override string ByteTypeName { get { return "byte"; } }
    internal override string Int64TypeName { get { return "long"; } }
    internal override string SByteTypeName { get { return "sbyte"; } }
    internal override string DataServiceStreamLinkTypeName { get { return "global::Microsoft.OData.Client.DataServiceStreamLink"; } }
    internal override string GeographyTypeName { get { return "global::Microsoft.Spatial.Geography"; } }
    internal override string GeographyPointTypeName { get { return "global::Microsoft.Spatial.GeographyPoint"; } }
    internal override string GeographyLineStringTypeName { get { return "global::Microsoft.Spatial.GeographyLineString"; } }
    internal override string GeographyPolygonTypeName { get { return "global::Microsoft.Spatial.GeographyPolygon"; } }
    internal override string GeographyCollectionTypeName { get { return "global::Microsoft.Spatial.GeographyCollection"; } }
    internal override string GeographyMultiPolygonTypeName { get { return "global::Microsoft.Spatial.GeographyMultiPolygon"; } }
    internal override string GeographyMultiLineStringTypeName { get { return "global::Microsoft.Spatial.GeographyMultiLineString"; } }
    internal override string GeographyMultiPointTypeName { get { return "global::Microsoft.Spatial.GeographyMultiPoint"; } }
    internal override string GeometryTypeName { get { return "global::Microsoft.Spatial.Geometry"; } }
    internal override string GeometryPointTypeName { get { return "global::Microsoft.Spatial.GeometryPoint"; } }
    internal override string GeometryLineStringTypeName { get { return "global::Microsoft.Spatial.GeometryLineString"; } }
    internal override string GeometryPolygonTypeName { get { return "global::Microsoft.Spatial.GeometryPolygon"; } }
    internal override string GeometryCollectionTypeName { get { return "global::Microsoft.Spatial.GeometryCollection"; } }
    internal override string GeometryMultiPolygonTypeName { get { return "global::Microsoft.Spatial.GeometryMultiPolygon"; } }
    internal override string GeometryMultiLineStringTypeName { get { return "global::Microsoft.Spatial.GeometryMultiLineString"; } }
    internal override string GeometryMultiPointTypeName { get { return "global::Microsoft.Spatial.GeometryMultiPoint"; } }
    internal override string DateTypeName { get { return "global::Microsoft.OData.Edm.Date"; } }
    internal override string DateTimeOffsetTypeName { get { return "global::System.DateTimeOffset"; } }
    internal override string DurationTypeName { get { return "global::System.TimeSpan"; } }
    internal override string TimeOfDayTypeName { get { return "global::Microsoft.OData.Edm.TimeOfDay"; } }
    internal override string XmlConvertClassName { get { return "global::System.Xml.XmlConvert"; } }
    internal override string EnumTypeName { get { return "global::System.Enum"; } }
    internal override string DictionaryInterfaceName { get { return "global::System.Collections.Generic.IDictionary<{0}, {1}>"; } }
    internal override string DictionaryTypeName { get { return "global::System.Collections.Generic.Dictionary<{0}, {1}>"; } }
    internal override string FixPattern { get { return "@{0}"; } }
    internal override string EnumUnderlyingTypeMarker { get { return " : "; } }
    internal override string ConstantExpressionConstructorWithType { get { return "global::System.Linq.Expressions.Expression.Constant({0}, typeof({1}))"; } }
    internal override string TypeofFormatter { get { return "typeof({0})"; } }
    internal override string UriOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})"; } }
    internal override string UriEntityOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})"; } }
    internal override string BodyOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})"; } }
    internal override string DictionaryConstructor { get { return "new global::System.Collections.Generic.Dictionary<{0}, {1}>()"; } }
    internal override string BaseEntityType { get { return " : global::Microsoft.OData.Client.BaseEntityType"; } }
    internal override string OverloadsModifier { get { return "new "; } }
    internal override string ODataVersion { get { return "global::Microsoft.OData.ODataVersion.V4"; } }
    internal override string ParameterDeclarationTemplate { get { return "{0} {1}"; } }
    internal override string DictionaryItemConstructor { get { return "{{ {0}, {1} }}"; } }
    internal override string ContainerPropertyBase { get { return "DynamicProperties"; } }
    internal override string ContainerPropertyAttribute { get { return "[global::Microsoft.OData.Client.ContainerProperty]"; } }
    internal override HashSet<string> LanguageKeywords { get {
        if (CSharpKeywords == null)
        {
            CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
            {
                "abstract", "as", "base", "byte", "bool", "break", "case", "catch", "char", "checked", "class", "const", "continue",
                "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "for",
                "foreach", "finally", "fixed", "float", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
                "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "string", "short", "sizeof", "stackalloc", "static", "struct", "switch",
                "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "volatile",
                "void", "while"
            };
        }
        return CSharpKeywords;
    } }
    private HashSet<string> CSharpKeywords;

    internal override void WriteFileHeader()
    {
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generation date: <#= DateTime.Now.ToString(global::System.Globalization.CultureInfo.CurrentCulture) #>
<#+
    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {
#>
namespace <#= fullNamespace #>
{
<#+
    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {containerName} in the schema." : description, true);
        if (this.context.EnableNamingAlias)
        {
#>
    [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalContainerName #>")]
<#+
        }
#>
    <#= ClassAccessModifier #> partial class <#= fixedContainerName #> : global::Microsoft.OData.Client.DataServiceContext
    {
<#+
    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {
#>
        /// <summary>
        /// Initialize a new <#= containerName #> object.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        public <#= fixedContainerName #>(global::System.Uri serviceRoot) :
                this(serviceRoot, global::Microsoft.OData.Client.ODataProtocolVersion.V4)
        {
        }

        /// <summary>
        /// Initialize a new <#= containerName #> object.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        public <#= fixedContainerName #>(global::System.Uri serviceRoot, global::Microsoft.OData.Client.ODataProtocolVersion protocolVersion) :
                base(serviceRoot, protocolVersion)
        {
<#+
    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {
#>
            this.UrlKeyDelimiter = global::Microsoft.OData.Client.DataServiceUrlKeyDelimiter.Slash;
<#+
    }

    internal override void WriteInitializeResolveName()
    {
#>
            this.ResolveName = new global::System.Func<global::System.Type, string>(this.ResolveNameFromType);
<#+
    }

    internal override void WriteInitializeResolveType()
    {
#>
            this.ResolveType = new global::System.Func<string, global::System.Type>(this.ResolveTypeFromName);
<#+
    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {
#>
            this.OnContextCreated();
            this.Format.LoadServiceModel = GeneratedEdmModel.GetInstance;
            this.Format.UseJson();
        }
        partial void OnContextCreated();
<#+
    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {
#>
        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        protected global::System.Type ResolveTypeFromName(string typeName)
        {
<#+
    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {
#>
            <#= typeName #>resolvedType = this.DefaultResolveType(typeName, "<#= fullNamespace #>", "<#= languageDependentNamespace #>");
            if ((resolvedType != null))
            {
                return resolvedType;
            }
<#+
    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {
#>
            return null;
        }
<#+
    }

    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {

    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {
#>
        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        protected string ResolveNameFromType(global::System.Type clientType)
        {
<#+
        if (this.context.EnableNamingAlias)
        {
#>
            global::Microsoft.OData.Client.OriginalNameAttribute originalNameAttribute = (global::Microsoft.OData.Client.OriginalNameAttribute)global::System.Linq.Enumerable.SingleOrDefault(global::Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, typeof(global::Microsoft.OData.Client.OriginalNameAttribute), true));
<#+
        }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {
#>
            if (clientType.Namespace.Equals("<#= languageDependentNamespace #>", global::System.StringComparison.Ordinal))
            {
<#+
        if (this.context.EnableNamingAlias)
        {
#>
                if (originalNameAttribute != null)
                {
                    return string.Concat("<#= fullNamespace #>.", originalNameAttribute.OriginalName);
                }
<#+
        }
#>
                return string.Concat("<#= fullNamespace #>.", clientType.Name);
            }
<#+
    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {
#>
            if (originalNameAttribute != null)
            {
                return clientType.Namespace + "." + originalNameAttribute.OriginalName;
            }
<#+
        }
#>
            return <#= modelHasInheritance ? "clientType.FullName" : "null" #>;
        }
<#+
    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {
#>
        /// <summary>
        /// Initialize a new <#= singleTypeName #> object.
        /// </summary>
        public <#= singleTypeName #>(global::Microsoft.OData.Client.DataServiceContext context, string path)
            : base(context, path) {}

        /// <summary>
        /// Initialize a new <#= singleTypeName #> object.
        /// </summary>
        public <#= singleTypeName #>(global::Microsoft.OData.Client.DataServiceContext context, string path, bool isComposable)
            : base(context, path, isComposable) {}

        /// <summary>
        /// Initialize a new <#= singleTypeName #> object.
        /// </summary>
        public <#= singleTypeName #>(<#= baseTypeName #> query)
            : base(query) {}

<#+
    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {entitySetName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalEntitySetName #>")]
<#+
        }
#>
        public virtual global::Microsoft.OData.Client.DataServiceQuery<<#= entitySetElementTypeName #>> <#= entitySetFixedName #>
        {
            get
            {
<#+
        if (!inContext)
        {
#>
                if (!this.IsComposable)
                {
                    throw new global::System.NotSupportedException("The previous function is not composable.");
                }
<#+
        }
#>
                if ((this._<#= entitySetName #> == null))
                {
                    this._<#= entitySetName #> = <#= inContext ? "base" : "Context" #>.CreateQuery<<#= entitySetElementTypeName #>>(<#= inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")" #>);
                }
                return this._<#= entitySetName #>;
            }
        }
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        private global::Microsoft.OData.Client.DataServiceQuery<<#= entitySetElementTypeName #>> _<#= entitySetName #>;
<#+
    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {singletonName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalSingletonName #>")]
<#+
        }
#>
        public virtual <#= singletonElementTypeName #> <#= singletonFixedName #>
        {
            get
            {
<#+
        if (!inContext)
        {
#>
                if (!this.IsComposable)
                {
                    throw new global::System.NotSupportedException("The previous function is not composable.");
                }
<#+
        }
#>
                if ((this._<#= singletonName #> == null))
                {
                    this._<#= singletonName #> = new <#= singletonElementTypeName #>(<#= inContext ? "this" : "this.Context" #>, <#= inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")" #>);
                }
                return this._<#= singletonName #>;
            }
        }
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        private <#= singletonElementTypeName #> _<#= singletonName #>;
<#+
    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {
        WriteDescriptionSummary($"There are no comments for {entitySetName} in the schema.");
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        public virtual void AddTo<#= entitySetName #>(<#= typeName #> <#= parameterName #>)
        {
            base.AddObject("<#= originalEntitySetName #>", <#= parameterName #>);
        }
<#+
    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {
        string path = this.context.MetadataFilePath;
        string relativePath = this.context.MetadataFileRelativePath;
        if(!String.IsNullOrEmpty(path))
        {
            using (StreamWriter writer = new StreamWriter(path, false))
            {
                writer.WriteLine(escapedEdmxString);
            }
        }

        bool useTempFile = !String.IsNullOrEmpty(path) && System.IO.File.Exists(path);
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        private abstract class GeneratedEdmModel
        {
<#+
        if (this.context.ReferencesMap != null)
        {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::System.Collections.Generic.Dictionary<string, string> ReferencesMap = new global::System.Collections.Generic.Dictionary<string, string>()
                {
<#+
            foreach(var reference in this.context.ReferencesMap)
            {
#>
                    {@"<#= reference.Key.OriginalString.Replace("\"", "\"\"") #>", @"<#= Utils.SerializeToString(reference.Value).Replace("\"", "\"\"") #>"},
<#+
            }
#>
                };
<#+
        }
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::Microsoft.OData.Edm.IEdmModel ParsedModel = LoadModelFromString();

<#+
            if (useTempFile)
            {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private const string filePath = @"<#= relativePath #>";
<#+
            }
            else
            {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private const string Edmx = @"<#= escapedEdmxString #>";
<#+
            }
#>

            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            public static global::Microsoft.OData.Edm.IEdmModel GetInstance()
            {
                return ParsedModel;
            }
<#+
        if (this.context.ReferencesMap != null)
        {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::System.Xml.XmlReader getReferencedModelFromMap(global::System.Uri uri)
            {
                string referencedEdmx;
                if (ReferencesMap.TryGetValue(uri.OriginalString, out referencedEdmx))
                {
                    return CreateXmlReader(referencedEdmx);
                }

                return null;
            }
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFromString()
            {
                <#+
                if (useTempFile)
                {
#>
                global::System.Xml.XmlReader reader = CreateXmlReader();
<#+
                }
                else
                {
#>
                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);
<#+
                }
#>
                try
                {
                    return global::Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, getReferencedModelFromMap);
                }
                finally
                {
                    ((global::System.IDisposable)(reader)).Dispose();
                }
            }
<#+
        }
        else
        {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFromString()
            {
<#+
                if (useTempFile)
                {
#>
                global::System.Xml.XmlReader reader = CreateXmlReader();
<#+
                }
                else
                {
#>
                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);
<#+
                }
#>
                try
                {
                    global::System.Collections.Generic.IEnumerable<global::Microsoft.OData.Edm.Validation.EdmError> errors;
                    global::Microsoft.OData.Edm.IEdmModel edmModel;

                    if (!global::Microsoft.OData.Edm.Csdl.CsdlReader.TryParse(reader, <#= this.context.IgnoreUnexpectedElementsAndAttributes ? "true" : "false" #>, out edmModel, out errors))
                    {
	                    global::System.Text.StringBuilder errorMessages = new global::System.Text.StringBuilder();
	                    foreach (var error in errors)
	                    {
		                    errorMessages.Append(error.ErrorMessage);
		                    errorMessages.Append("; ");
	                    }
	                    throw new global::System.InvalidOperationException(errorMessages.ToString());
                    }

                    return edmModel;
                }
                finally
                {
                    ((global::System.IDisposable)(reader)).Dispose();
                }
            }
<#+
        }
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::System.Xml.XmlReader CreateXmlReader(string edmxToParse)
            {
                return global::System.Xml.XmlReader.Create(new global::System.IO.StringReader(edmxToParse));
            }

<#+
        if (useTempFile)
        {
#>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
            private static global::System.Xml.XmlReader CreateXmlReader()
            {
                try
                {
                    var assembly = global::System.Reflection.Assembly.GetExecutingAssembly();
                    var resourcePath = global::System.Linq.Enumerable.Single(assembly.GetManifestResourceNames(), str => str.EndsWith(filePath));
                    global::System.IO.Stream stream = assembly.GetManifestResourceStream(resourcePath);
                    return global::System.Xml.XmlReader.Create(new global::System.IO.StreamReader(stream));
                }
                catch(global::System.Xml.XmlException e)
                {
                    throw new global::System.Xml.XmlException("Failed to create an XmlReader from the stream. Check if the resource exists.", e);
                }
            }
<#+
        }
#>
        }
<#+
    }

    internal override void WriteClassEndForEntityContainer()
    {
#>
    }
<#+
    }

    internal override void WriteSummaryCommentForStructuredType(string typeName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {typeName} in the schema." : description, true);
    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {
#>
    /// <KeyProperties>
<#+
        foreach (string key in keyProperties)
        {
#>
    /// <#= key #>
<#+
        }
#>
    /// </KeyProperties>
    [global::Microsoft.OData.Client.Key("<#= keyString #>")]
<#+
    }

    internal override void WriteEntityTypeAttribute()
    {
#>
    [global::Microsoft.OData.Client.EntityType()]
<#+
    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {
#>
    [global::Microsoft.OData.Client.EntitySet("<#= entitySetName #>")]
<#+
    }

    internal override void WriteEntityHasStreamAttribute()
    {
#>
    [global::Microsoft.OData.Client.HasStream()]
<#+
    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
        {
#>
    [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalTypeName #>")]
<#+
        }
#>
    <#= ClassAccessModifier #><#= abstractModifier #> partial class <#= typeName #><#= baseTypeName #>
    {
<#+
    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {
#>
        /// <summary>
        /// Create a new <#= typeName #> object.
        /// </summary>
<#+
    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {
#>
        /// <param name="<#= parameterName #>">Initial value of <#= propertyName #>.</param>
<#+
    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        public static <#= fixedTypeName #> Create<#= typeName #>(<#+
    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {
#><#= parameterTypeName #> <#= parameterName #><#= parameterSeparater #><#+
    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {
          #>)
        {
            <#= typeName #> <#= instanceName #> = new <#= typeName #>();
<#+
    }

    internal override void  WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {
#>
            if ((<#= parameterName #> == null))
            {
                throw new global::System.ArgumentNullException("<#= parameterName #>");
            }
<#+
    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {
#>
            <#= instanceName #>.<#= propertyName #> = <#= parameterName #>;
<#+
    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {
#>
            return <#= instanceName #>;
        }
<#+
    }

    internal override void WritePropertyForStructuredType(PropertyOptions propertyOptions)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(propertyOptions.PropertyDescription) ? $"There are no comments for Property {propertyOptions.PropertyName} in the schema." : propertyOptions.PropertyDescription);
        WriteObsoleteAttribute(propertyOptions.RevisionAnnotations);
#>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]

<#+
        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(propertyOptions.OriginalPropertyName))
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= propertyOptions.OriginalPropertyName #>")]
<#+
        }

        if (propertyOptions.PropertyMaxLength != null)
        {
            WriteStringLengthAttribute((int)propertyOptions.PropertyMaxLength, $"{propertyOptions.PropertyName} cannot be longer than {propertyOptions.PropertyMaxLength} characters.");
        }

        if (!propertyOptions.IsNullable)
        {
            WriteRequiredAttribute($"{propertyOptions.PropertyName} is required.");
        }
#>

<#+
        if (!string.IsNullOrEmpty(propertyOptions.PropertyAttribute))
        {
#>
        <#= propertyOptions.PropertyAttribute #>
<#+
        }
#>
        public virtual <#= propertyOptions.PropertyType #> <#= propertyOptions.FixedPropertyName #>
        {
            get
            {
                return this.<#= propertyOptions.PrivatePropertyName #>;
            }
            set
            {
                this.On<#= propertyOptions.PropertyName #>Changing(value);
                this.<#= propertyOptions.PrivatePropertyName #> = value;
                this.On<#= propertyOptions.PropertyName #>Changed();
<#+
        if (propertyOptions.WriteOnPropertyChanged)
        {
#>
                this.OnPropertyChanged("<#= propertyOptions.OriginalPropertyName #>");
<#+
        }
#>
            }
        }
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        private <#= propertyOptions.PropertyType #> <#= propertyOptions.PrivatePropertyName #><#= propertyOptions.PropertyInitializationValue != null ? " = " + propertyOptions.PropertyInitializationValue : string.Empty #>;
        partial void On<#= propertyOptions.PropertyName #>Changing(<#= propertyOptions.PropertyType #> value);
        partial void On<#= propertyOptions.PropertyName #>Changed();
<#+
    }

    internal override void WriteINotifyPropertyChangedImplementation()
    {
#>
        /// <summary>
        /// This event is raised when the value of the property is changed
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        public event global::System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        /// <summary>
        /// The value of the property is changed
        /// </summary>
        /// <param name="property">property name</param>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")]
        protected virtual void OnPropertyChanged(string property)
        {
            if ((this.PropertyChanged != null))
            {
                this.PropertyChanged(this, new global::System.ComponentModel.PropertyChangedEventArgs(property));
            }
        }
<#+
    }

    internal override void WriteClassEndForStructuredType()
    {
#>
    }
<#+
    }

    internal override void WriteEnumFlags()
    {
#>
    [global::System.Flags]
<#+
    }

    internal override void WriteSummaryCommentForEnumType(string enumName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {enumName} in the schema." : description, true);
    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
        {
#>
    [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalEnumName #>")]
<#+
        }
#>
    <#= ClassAccessModifier #> enum <#= enumName #><#= underlyingType #>
    {
<#+
    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalMemberName #>")]
<#+
        }
#>
        <#= member #><#= last ? string.Empty : "," #>
<#+
    }

    internal override void WriteEnumEnd()
    {
#>
    }
<#+
    }

    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public virtual global::Microsoft.OData.Client.DataServiceQuery<<#= returnTypeName #>> <#= functionName #>(<#= parameters #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>)
        {
            return this.CreateFunctionQuery<<#= returnTypeName #>>("", "<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>);
        }
<#+
    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public virtual <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #> <#= functionName #>(<#= parameters #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>)
        {
            return <#= isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>this.CreateFunctionQuerySingle<<#= returnTypeName #>>("", "<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>;
        }
<#+
    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public virtual <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #>global::Microsoft.OData.Client.DataServiceQuery<<#= returnTypeName #>> <#= functionName #>(<#= parameters #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>)
        {
            global::System.Uri requestUri;
            Context.TryGetUri(this, out requestUri);
            return this.Context.CreateFunctionQuery<<#= returnTypeName #>>(string.Join("/", global::System.Linq.Enumerable.Select(global::System.Linq.Enumerable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.Trim('/'))), "<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>);
        }
<#+
    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public virtual <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #> <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #> <#= functionName #>(<#= parameters #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>)
        {
            global::System.Uri requestUri;
            Context.TryGetUri(this, out requestUri);

            return <#= isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>this.Context.CreateFunctionQuerySingle<<#= returnTypeName #>>(string.Join("/", global::System.Linq.Enumerable.Select(global::System.Linq.Enumerable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.Trim('/'))), "<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>;
        }
<#+
        }

    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")]
<#+
        }
#>
        public virtual <#= returnTypeName #> <#= actionName #>(<#= parameters #>)
        {
            return new <#= returnTypeName #>(this, this.BaseUri.OriginalString.Trim('/') + "/<#= originalActionName #>"<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>);
        }
<#+
    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")]
<#+
        }
#>
        public virtual <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #><#= returnTypeName #> <#= actionName #>(<#= parameters #>)
        {
            global::Microsoft.OData.Client.EntityDescriptor resource = Context.EntityTracker.TryGetEntityDescriptor(this);
            if (resource == null)
            {
                throw new global::System.Exception("cannot find entity");
            }

            return new <#= returnTypeName #>(this.Context, resource.EditLink.OriginalString.Trim('/') + "/<#= fullNamespace #>.<#= originalActionName #>"<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>);
        }
<#+
    }

    internal override void WriteExtensionMethodsStart()
    {
#>
    /// <summary>
    /// Class containing all extension methods
    /// </summary>
    <#= ClassAccessModifier #> static class ExtensionMethods
    {
<#+
    }

    internal override void WriteExtensionMethodsEnd()
    {
#>
    }
<#+
    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {
#>
        /// <summary>
        /// Get an entity of type <#= entityTypeName #> as <#= returnTypeName #> specified by key from an entity set
        /// </summary>
        /// <param name="_source">source entity set</param>
        /// <param name="_keys">dictionary with the names and values of keys</param>
        public static <#= returnTypeName #> ByKey(this global::Microsoft.OData.Client.DataServiceQuery<<#= entityTypeName #>> _source, global::System.Collections.Generic.IDictionary<string, object> _keys)
        {
            return new <#= returnTypeName #>(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.GetKeyString(_source.Context, _keys)));
        }
        /// <summary>
        /// Get an entity of type <#= entityTypeName #> as <#= returnTypeName #> specified by key from an entity set
        /// </summary>
        /// <param name="_source">source entity set</param>
<#+
        foreach (var key in keys)
        {
#>
        /// <param name="<#= key #>">The value of <#= key #></param>
<#+
        }
#>
        public static <#= returnTypeName #> ByKey(this global::Microsoft.OData.Client.DataServiceQuery<<#= entityTypeName #>> _source,
            <#= keyParameters #>)
        {
            global::System.Collections.Generic.IDictionary<string, object> _keys = new global::System.Collections.Generic.Dictionary<string, object>
            {
                <#= keyDictionaryItems #>
            };
            return new <#= returnTypeName #>(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.GetKeyString(_source.Context, _keys)));
        }
<#+
    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {
#>
        /// <summary>
        /// Cast an entity of type <#= baseTypeName #> to its derived type <#= derivedTypeFullName #>
        /// </summary>
        /// <param name="_source">source entity</param>
        public static <#= returnTypeName #> CastTo<#= derivedTypeName #>(this global::Microsoft.OData.Client.DataServiceQuerySingle<<#= baseTypeName #>> _source)
        {
            global::Microsoft.OData.Client.DataServiceQuerySingle<<#= derivedTypeFullName #>> query = _source.CastTo<<#= derivedTypeFullName #>>();
            return new <#= returnTypeName #>(_source.Context, query.GetPath(null));
        }
<#+
    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public static <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #> <#= functionName #>(this <#= boundTypeName #> _source<#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #><#= useEntityReference ? ", bool useEntityReference = false" : string.Empty #>)
        {
            if (!_source.IsComposable)
            {
                throw new global::System.NotSupportedException("The previous function is not composable.");
            }

            return <#= isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>_source.CreateFunctionQuerySingle<<#= returnTypeName #>>("<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>;
        }
<#+
    }

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")]
<#+
        }
#>
        public static global::Microsoft.OData.Client.DataServiceQuery<<#= returnTypeName #>> <#= functionName #>(this <#= boundTypeName #> _source<#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #><#= useEntityReference ? ", bool useEntityReference = true" : string.Empty #>)
        {
            if (!_source.IsComposable)
            {
                throw new global::System.NotSupportedException("The previous function is not composable.");
            }

            return _source.CreateFunctionQuery<<#= returnTypeName #>>("<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable.ToString().ToLower(CultureInfo.InvariantCulture) #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>);
        }
<#+
    }

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {
#>
        [global::Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")]
<#+
        }
#>
        public static <#= returnTypeName #> <#= actionName #>(this <#= boundSourceType #> _source<#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #>)
        {
            if (!_source.IsComposable)
            {
                throw new global::System.NotSupportedException("The previous function is not composable.");
            }

            return new <#= returnTypeName #>(_source.Context, _source.AppendRequestUri("<#= fullNamespace #>.<#= originalActionName #>")<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>);
        }
<#+
    }

    protected override void WriteDescriptionSummary(string description, bool isClass = false)
    {
        if (isClass)
        {
#>
    /// <summary>
    /// <#= description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n    ///") #>
    /// </summary>
<#+
        }
        else
        {
#>
        /// <summary>
        /// <#= description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n        ///") #>
        /// </summary>
<#+
        }
    }

    protected override void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false)
    {
        if (!revisionAnnotations.TryGetValue(deprecated, out string revisionDescription))
        {
           return;
        }

        if (isClass)
        {
#>
    [global::System.ObsoleteAttribute("<#= revisionDescription #>")]
<#+
        }
        else
        {
#>
        [global::System.ObsoleteAttribute("<#= revisionDescription #>")]
<#+
        }
    }

    protected override void WriteStringLengthAttribute(int maxLength, string errorMessage)
    {
#>
        [global::System.ComponentModel.DataAnnotations.StringLengthAttribute(<#=maxLength#>, ErrorMessage = "<#=errorMessage#>")]
<#+
    }

    protected override void WriteRequiredAttribute(string errorMessage)
    {
#>
        [global::System.ComponentModel.DataAnnotations.RequiredAttribute(ErrorMessage = "<#=errorMessage#>")]
<#+
    }

    internal override void WriteNamespaceEnd()
    {
#>
}
<#+
    }
}

public sealed class ODataClientVBTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The cotion context.</param>
    public ODataClientVBTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix { get { return string.Empty; } }
    internal override string SystemTypeTypeName { get { return "Global.System.Type"; } }
    internal override string AbstractModifier { get { return " MustInherit"; } }
    internal override string PublicAccessModifier { get { return "Public"; } }
    internal override string InternalAccessModifier { get { return "Friend"; } }
    internal override string DataServiceActionQueryTypeName { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery"; } }
    internal override string DataServiceActionQuerySingleOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuerySingle(Of {0})"; } }
    internal override string DataServiceActionQueryOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery(Of {0})"; } }
    internal override string NotifyPropertyChangedModifier { get { return "\r\n        Implements Global.System.ComponentModel.INotifyPropertyChanged"; } }
    internal override string ClassInheritMarker { get { return "\r\n        Inherits "; } }
    internal override string ParameterSeparator { get { return ",  _\r\n                    "; } }
    internal override string KeyParameterSeparator { get { return ",  _\r\n            "; } }
    internal override string KeyDictionaryItemSeparator { get { return ",  _\r\n                "; } }
    internal override string SystemNullableStructureTemplate { get { return "Global.System.Nullable(Of {0})"; } }
    internal override string ICollectionOfTStructureTemplate { get { return "Global.System.Collections.Generic.ICollection(Of {0})"; } }
    internal override string DataServiceCollectionStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceCollection(Of {0})"; } }
    internal override string DataServiceQueryStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuery(Of {0})"; } }
    internal override string DataServiceQuerySingleStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuerySingle(Of {0})"; } }
    internal override string ObservableCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.ObservableCollection(Of {0})"; } }
    internal override string ObjectModelCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.Collection(Of {0})"; } }
    internal override string DataServiceCollectionConstructorParameters { get { return "(Nothing, Global.Microsoft.OData.Client.TrackingMode.None)"; } }
    internal override string NewModifier { get { return "New "; } }
    internal override string GeoTypeInitializePattern { get { return "Global.Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(False).Read(Of {0})(New Global.System.IO.StringReader(\"{1}\"))"; } }
    internal override string ObjectTypeName { get { return "Object"; } }
    internal override string Int32TypeName { get { return "Integer"; } }
    internal override string StringTypeName { get { return "String"; } }
    internal override string BinaryTypeName { get { return "Byte()"; } }
    internal override string DecimalTypeName { get { return "Decimal"; } }
    internal override string Int16TypeName { get { return "Short"; } }
    internal override string SingleTypeName { get { return "Single"; } }
    internal override string BooleanTypeName { get { return "Boolean"; } }
    internal override string DoubleTypeName { get { return "Double"; } }
    internal override string GuidTypeName { get { return "Global.System.Guid"; } }
    internal override string ByteTypeName { get { return "Byte"; } }
    internal override string Int64TypeName { get { return "Long"; } }
    internal override string SByteTypeName { get { return "SByte"; } }
    internal override string DataServiceStreamLinkTypeName { get { return "Global.Microsoft.OData.Client.DataServiceStreamLink"; } }
    internal override string GeographyTypeName { get { return "Global.Microsoft.Spatial.Geography"; } }
    internal override string GeographyPointTypeName { get { return "Global.Microsoft.Spatial.GeographyPoint"; } }
    internal override string GeographyLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyLineString"; } }
    internal override string GeographyPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyPolygon"; } }
    internal override string GeographyCollectionTypeName { get { return "Global.Microsoft.Spatial.GeographyCollection"; } }
    internal override string GeographyMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPolygon"; } }
    internal override string GeographyMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiLineString"; } }
    internal override string GeographyMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPoint"; } }
    internal override string GeometryTypeName { get { return "Global.Microsoft.Spatial.Geometry"; } }
    internal override string GeometryPointTypeName { get { return "Global.Microsoft.Spatial.GeometryPoint"; } }
    internal override string GeometryLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryLineString"; } }
    internal override string GeometryPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryPolygon"; } }
    internal override string GeometryCollectionTypeName { get { return "Global.Microsoft.Spatial.GeometryCollection"; } }
    internal override string GeometryMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPolygon"; } }
    internal override string GeometryMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiLineString"; } }
    internal override string GeometryMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPoint"; } }
    internal override string DateTypeName { get { return "Global.Microsoft.OData.Edm.Date"; } }
    internal override string DateTimeOffsetTypeName { get { return "Global.System.DateTimeOffset"; } }
    internal override string DurationTypeName { get { return "Global.System.TimeSpan"; } }
    internal override string TimeOfDayTypeName { get { return "Global.Microsoft.OData.Edm.TimeOfDay"; } }
    internal override string XmlConvertClassName { get { return "Global.System.Xml.XmlConvert"; } }
    internal override string EnumTypeName { get { return "Global.System.Enum"; } }
    internal override string DictionaryInterfaceName { get { return "Global.System.Collections.Generic.IDictionary(Of {0}, {1})"; } }
    internal override string DictionaryTypeName { get { return "Global.System.Collections.Generic.Dictionary(Of {0}, {1})"; } }
    internal override string FixPattern { get { return "[{0}]"; } }
    internal override string EnumUnderlyingTypeMarker { get { return " As "; } }
    internal override string ConstantExpressionConstructorWithType { get { return "Global.System.Linq.Expressions.Expression.Constant({0}, GetType({1}))"; } }
    internal override string TypeofFormatter { get { return "GetType({0})"; } }
    internal override string UriOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})"; } }
    internal override string UriEntityOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})"; } }
    internal override string BodyOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})"; } }
    internal override string DictionaryConstructor { get { return "New Global.System.Collections.Generic.Dictionary(Of {0}, {1})"; } }
    internal override string BaseEntityType { get { return "\r\n        Inherits Global.Microsoft.OData.Client.BaseEntityType"; } }
    internal override string OverloadsModifier { get { return "Overloads "; } }
    internal override string ODataVersion { get { return "Global.Microsoft.OData.ODataVersion.V4"; } }
    internal override string ParameterDeclarationTemplate { get { return "{1} As {0}"; } }
    internal override string DictionaryItemConstructor { get { return "{{ {0}, {1} }}"; } }
    internal override string ContainerPropertyBase { get { return "DynamicProperties"; } }
    internal override string ContainerPropertyAttribute { get { return "<Global.Microsoft.OData.Client.ContainerProperty>"; } }
    internal override HashSet<string> LanguageKeywords { get {
        if (VBKeywords == null)
        {
            VBKeywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "AddHandler", "AddressOf", "Alias", "And", "AndAlso", "As", "Boolean", "ByRef", "Byte", "ByVal",
                "Call", "Case", "Catch", "CBool", "", "CByte", "CChar", "CDate", "CDbl", "CDec", "Char",
                "CInt", "Class", "CLng", "CObj", "Const", "Continue", "CSByte", "CShort", "CSng", "CStr",
                "CType", "CUInt", "CULng", "CUShort", "Date", "Decimal", "Declare", "Default", "Delegate", "Dim",
                "DirectCast", "Do", "Double", "Each", "Else", "ElseIf", "End", "EndIf", "Enum", "Erase",
                "Error", "Event", "Exit", "False", "Finally", "For", "Friend", "Function", "Get", "GetType",
                "GetXMLNamespace", "Global", "GoSub", "GoTo", "Handles", "If", "Implements", "Imports", "In", "Inherits",
                "Integer", "Interface", "Is", "IsNot", "Let", "Lib", "Like", "Long", "Loop", "Me",
                "Mod", "Module", "MustInherit", "MustOverride", "MyBase", "MyClass", "Namespace", "Narrowing", "New", "Next",
                "Not", "Nothing", "NotInheritable", "NotOverridable", "Object", "Of", "On", "Operator", "Option", "Optional",
                "Or", "OrElse", "Out", "Overloads", "Overridable", "Overrides", "ParamArray", "Partial", "Private", "Property",
                "Protected", "Public", "RaiseEvent", "ReadOnly", "ReDim", "REM", "RemoveHandler", "Resume", "Return", "SByte",
                "Select", "Set", "Shadows", "Shared", "Short", "Single", "Static", "Step", "Stop", "String",
                "Structure", "Sub", "SyncLock", "Then", "Throw", "To", "True", "Try", "TryCast", "TypeOf",
                "UInteger", "ULong", "UShort", "Using", "Variant", "Wend", "When", "While", "Widening", "With",
                "WithEvents", "WriteOnly", "Xor"
            };
        }
        return VBKeywords;
    } }
    private HashSet<string> VBKeywords;

    internal override void WriteFileHeader()
    {
#>'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:<#= Environment.Version #>
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On


'Generation date: <#= DateTime.Now.ToString(System.Globalization.CultureInfo.CurrentCulture) #>
<#+
    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {
#>
Namespace <#= fullNamespace #>
<#+
    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {containerName} in the schema." : description, true);
        if (this.context.EnableNamingAlias)
        {
#>
    <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalContainerName #>")>  _
<#+
        }
#>
    Partial <#= ClassAccessModifier #> Class <#= fixedContainerName #>
        Inherits Global.Microsoft.OData.Client.DataServiceContext
<#+
    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {
#>
        ''' <summary>
        ''' Initialize a new <#= containerName #> object.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Public Sub New(ByVal serviceRoot As Global.System.Uri)
            Me.New(serviceRoot, Global.Microsoft.OData.Client.ODataProtocolVersion.V4)
        End Sub

        ''' <summary>
        ''' Initialize a new <#= containerName #> object.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Public Sub New(ByVal serviceRoot As Global.System.Uri, ByVal protocolVersion As Global.Microsoft.OData.Client.ODataProtocolVersion)
            MyBase.New(serviceRoot, protocolVersion)
<#+
    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {
#>
            Me.UrlKeyDelimiter = Global.Microsoft.OData.Client.DataServiceUrlKeyDelimiter.Slash
<#+
    }

    internal override void WriteInitializeResolveName()
    {
#>
            Me.ResolveName = AddressOf Me.ResolveNameFromType
<#+
    }

    internal override void WriteInitializeResolveType()
    {
#>
            Me.ResolveType = AddressOf Me.ResolveTypeFromName
<#+
    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {
#>
            Me.OnContextCreated
            Me.Format.LoadServiceModel = AddressOf GeneratedEdmModel.GetInstance
            Me.Format.UseJson()
        End Sub
        Partial Private Sub OnContextCreated()
        End Sub
<#+
    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {
#>
        ''' <summary>
        ''' Since the namespace configured for this service reference
        ''' in Visual Studio is different from the one indicated in the
        ''' server schema, use type-mappers to map between the two.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Protected Function ResolveTypeFromName(ByVal typeName As String) As Global.System.Type
<#+
    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {
        if (!string.IsNullOrEmpty(typeName))
        {
#>
            Dim resolvedType As <#= typeName #>= Me.DefaultResolveType(typeName, "<#= fullNamespace #>", String.Concat(ROOTNAMESPACE, "<#= languageDependentNamespace #>"))
<#+
        }
        else
        {
#>
            resolvedType = Me.DefaultResolveType(typeName, "<#= fullNamespace #>", String.Concat(ROOTNAMESPACE, "<#= languageDependentNamespace #>"))
<#+
        }
#>
            If (Not (resolvedType) Is Nothing) Then
                Return resolvedType
            End If
<#+
    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {
#>
            Return Nothing
        End Function
<#+
    }

    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Private Shared ROOTNAMESPACE As String = GetType(<#= containerName #>).Namespace.Remove(GetType(<#= containerName #>).Namespace.LastIndexOf("<#= fullNamespace #>"))
<#+
    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {
#>
        ''' <summary>
        ''' Since the namespace configured for this service reference
        ''' in Visual Studio is different from the one indicated in the
        ''' server schema, use type-mappers to map between the two.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Protected Function ResolveNameFromType(ByVal clientType As Global.System.Type) As String
<#+
        if (this.context.EnableNamingAlias)
        {
#>
            Dim originalNameAttribute As Global.Microsoft.OData.Client.OriginalNameAttribute =
                CType(Global.System.Linq.Enumerable.SingleOrDefault(Global.Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, GetType(Global.Microsoft.OData.Client.OriginalNameAttribute), true)), Global.Microsoft.OData.Client.OriginalNameAttribute)
<#+
    }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {
#>
            If clientType.Namespace.Equals(String.Concat(ROOTNAMESPACE, "<#= languageDependentNamespace #>"), Global.System.StringComparison.OrdinalIgnoreCase) Then
<#+
        if (this.context.EnableNamingAlias)
        {
#>
                If (Not (originalNameAttribute) Is Nothing) Then
                    Return String.Concat("<#= fullNamespace #>.", originalNameAttribute.OriginalName)
                End If
<#+
        }
#>
                Return String.Concat("<#= fullNamespace #>.", clientType.Name)
            End If
<#+
    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {
#>
            If (Not (originalNameAttribute) Is Nothing) Then
                Dim fullName As String = clientType.FullName.Substring(ROOTNAMESPACE.Length)
                Return fullName.Remove(fullName.LastIndexOf(clientType.Name)) + originalNameAttribute.OriginalName
            End If
<#+
        }
#>
            Return <#= modelHasInheritance ? "clientType.FullName.Substring(ROOTNAMESPACE.Length)" : "Nothing" #>
        End Function
<#+
    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {
#>
        ''' <summary>
        ''' Initialize a new <#= singleTypeName #> object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String)
            MyBase.New(context, path)
        End Sub

        ''' <summary>
        ''' Initialize a new <#= singleTypeName #> object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String, ByVal isComposable As Boolean)
            MyBase.New(context, path, isComposable)
        End Sub

        ''' <summary>
        ''' Initialize a new <#= singleTypeName #> object.
        ''' </summary>
        Public Sub New(ByVal query As <#= baseTypeName #>)
            MyBase.New(query)
        End Sub
<#+
    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {entitySetName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalEntitySetName #>")>  _
<#+
        }
#>
        Public Overridable ReadOnly Property <#= entitySetFixedName #>() As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= entitySetElementTypeName #>)
            Get
<#+
        if (!inContext)
        {
#>
                If Not Me.IsComposable Then
                    Throw New Global.System.NotSupportedException("The previous function is not composable.")
                End If
<#+
        }
#>
                If (Me._<#= entitySetName #> Is Nothing) Then
                    Me._<#= entitySetName #> = <#= inContext ? "MyBase" : "Context"#>.CreateQuery(Of <#= entitySetElementTypeName #>)(<#= inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")" #>)
                End If
                Return Me._<#= entitySetName #>
            End Get
        End Property
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Private _<#= entitySetName #> As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= entitySetElementTypeName #>)
<#+
    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {singletonName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalSingletonName #>")>  _
<#+
        }
#>
        Public Overridable ReadOnly Property <#= singletonFixedName #>() As <#= singletonElementTypeName #>
            Get
<#+
        if (!inContext)
        {
#>
                If Not Me.IsComposable Then
                    Throw New Global.System.NotSupportedException("The previous function is not composable.")
                End If
<#+
        }
#>
                If (Me._<#= singletonName #> Is Nothing) Then
                    Me._<#= singletonName #> = New <#= singletonElementTypeName #>(<#= inContext ? "Me" : "Me.Context" #>, <#= inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")" #>)
                End If
                Return Me._<#= singletonName #>
            End Get
        End Property
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Private _<#= singletonName #> As <#= singletonElementTypeName #>
<#+
    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {
        WriteDescriptionSummary($"There are no comments for {entitySetName} in the schema.");
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Public Overridable Sub AddTo<#= entitySetName #>(ByVal <#= parameterName #> As <#= typeName #>)
            MyBase.AddObject("<#= originalEntitySetName #>", <#= parameterName #>)
        End Sub
<#+
    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {
        string path = this.context.MetadataFilePath;
        string relativePath = this.context.MetadataFileRelativePath;
        if(!String.IsNullOrEmpty(path))
        {
            using (StreamWriter writer = new StreamWriter(path, false))
            {
                writer.WriteLine(escapedEdmxString);
            }
        }

        bool useTempFile = !String.IsNullOrEmpty(path) && System.IO.File.Exists(path);
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Private MustInherit Class GeneratedEdmModel
<#+
        if (this.context.ReferencesMap != null)
        {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared ReferencesMap As Global.System.Collections.Generic.Dictionary(Of String, String) = New Global.System.Collections.Generic.Dictionary(Of String, String) From
                {
<#+
            int count = this.context.ReferencesMap.Count();
            foreach(var reference in this.context.ReferencesMap)
            {
#>
                    {"<#= reference.Key.OriginalString.Replace("\"", "\"\"") #>", "<#= Utils.SerializeToString(reference.Value).Replace("\"", "\"\"").Replace("\r\n", "\" & _\r\n \"") #>"}<#= (--count>0?",":"")#>
<#+
            }
#>
                }
<#+
        }
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared ParsedModel As Global.Microsoft.OData.Edm.IEdmModel = LoadModelFromString
<#+
            if (useTempFile)
            {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Const filePath As String = "<#= relativePath #>"
<#+
            }
            else
            {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Const Edmx As String = "<#= escapedEdmxString #>"
<#+
            }
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Public Shared Function GetInstance() As Global.Microsoft.OData.Edm.IEdmModel
                Return ParsedModel
            End Function
<#+
        if (this.context.ReferencesMap != null)
        {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared Function getReferencedModelFromMap(ByVal uri As Global.System.Uri) As Global.System.Xml.XmlReader
                Dim referencedEdmx As String = Nothing
                If (ReferencesMap.TryGetValue(uri.OriginalString, referencedEdmx)) Then
                    Return CreateXmlReader(referencedEdmx)
                End If
                Return Nothing
            End Function
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared Function LoadModelFromString() As Global.Microsoft.OData.Edm.IEdmModel
<#+
                if (useTempFile)
                {
#>
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader()
<#+
                }
                else
                {
#>
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)
<#+
                }
#>
                Try
                    Return Global.Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, AddressOf getReferencedModelFromMap)
                Finally
                    CType(reader,Global.System.IDisposable).Dispose
                End Try
            End Function
<#+
        }
        else
        {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared Function LoadModelFromString() As Global.Microsoft.OData.Edm.IEdmModel
<#+
                if (useTempFile)
                {
#>
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader()
<#+
                }
                else
                {
#>
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)
<#+
                }
#>
                Try
                    Dim errors As Global.System.Collections.Generic.IEnumerable(Of Global.Microsoft.OData.Edm.Validation.EdmError) = Nothing
                    Dim edmModel As Global.Microsoft.OData.Edm.IEdmModel = Nothing
                    If Not Global.Microsoft.OData.Edm.Csdl.CsdlReader.TryParse(reader, <#= this.context.IgnoreUnexpectedElementsAndAttributes ? "True" : "False" #>, edmModel, errors) Then
                        Dim errorMessages As Global.System.Text.StringBuilder = New Global.System.Text.StringBuilder()
                        For Each err As Global.Microsoft.OData.Edm.Validation.EdmError In errors
                            errorMessages.Append(err.ErrorMessage)
                            errorMessages.Append("; ")
                        Next
                        Throw New Global.System.InvalidOperationException(errorMessages.ToString())
                    End If

                    Return edmModel
                Finally
                    CType(reader, Global.System.IDisposable).Dispose()
                End Try
            End Function
<#+
        }
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared Function CreateXmlReader(ByVal edmxToParse As String) As Global.System.Xml.XmlReader
                Return Global.System.Xml.XmlReader.Create(New Global.System.IO.StringReader(edmxToParse))
            End Function
<#+
        if (useTempFile)
        {
#>
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
            Private Shared Function CreateXmlReader() As Global.System.Xml.XmlReader
                Try
                    Dim assembly As Global.System.Reflection.Assembly = Global.System.Reflection.Assembly.GetExecutingAssembly()
                    Dim resourcePath As Global.System.String = Global.System.Linq.Enumerable.Single(assembly.GetManifestResourceNames(), Function(str) str.EndsWith(filePath))
                    Dim stream As Global.System.IO.Stream = assembly.GetManifestResourceStream(resourcePath)
                    Return Global.System.Xml.XmlReader.Create(New Global.System.IO.StreamReader(stream))
                Catch e As Global.System.Xml.XmlException
                    Throw New Global.System.Xml.XmlException("Failed to create an XmlReader from the stream. Check if the resource exists.", e)
                End Try
            End Function
<#+
        }
#>
        End Class
<#+
    }

    internal override void WriteClassEndForEntityContainer()
    {
#>
    End Class
<#+
    }

    internal override void WriteSummaryCommentForStructuredType(string typeName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {typeName} in the schema." : description, true);
    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {
#>
    ''' <KeyProperties>
<#+
        foreach (string key in keyProperties)
        {
#>
    ''' <#= key #>
<#+
        }
#>
    ''' </KeyProperties>
    <Global.Microsoft.OData.Client.Key("<#= keyString #>")>  _
<#+
    }

    internal override void WriteEntityTypeAttribute()
    {
#>
    <Global.Microsoft.OData.Client.EntityType()>  _
<#+
    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {
#>
    <Global.Microsoft.OData.Client.EntitySet("<#= entitySetName #>")>  _
<#+
    }

    internal override void WriteEntityHasStreamAttribute()
    {
#>
    <Global.Microsoft.OData.Client.HasStream()>  _
<#+
    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
    {
#>
    <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalTypeName #>")>  _
<#+
        }
#>
    Partial <#= ClassAccessModifier #><#= abstractModifier #> Class <#= typeName #><#= baseTypeName #>
<#+
    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {
#>
        ''' <summary>
        ''' Create a new <#= typeName #> object.
        ''' </summary>
<#+
    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {
#>
        ''' <param name="<#= parameterName #>">Initial value of <#= propertyName #>.</param>
<#+
    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Public Shared Function Create<#= typeName #>(<#+

    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {
#>ByVal <#= parameterName #> As <#= parameterTypeName #><#= parameterSeparater #><#+
    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {
          #>) As <#= typeName #>
            Dim <#= instanceName #> As <#= typeName #> = New <#= typeName #>()
<#+
    }

    internal override void  WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {
#>
            If (<#= parameterName #> Is Nothing) Then
                Throw New Global.System.ArgumentNullException("<#= parameterName #>")
            End If
<#+
    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {
#>
            <#= instanceName #>.<#= propertyName #> = <#= parameterName #>
<#+
    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {
#>
            Return <#= instanceName #>
        End Function
<#+
    }

    internal override void WritePropertyForStructuredType(PropertyOptions propertyOptions)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(propertyOptions.PropertyDescription) ? $"There are no comments for Property {propertyOptions.PropertyName} in the schema." : propertyOptions.PropertyDescription);
        WriteObsoleteAttribute(propertyOptions.RevisionAnnotations);
#>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
<#+
        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(propertyOptions.OriginalPropertyName))
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= propertyOptions.OriginalPropertyName #>")>  _
<#+
        }

        if (propertyOptions.PropertyMaxLength != null)
        {
            WriteStringLengthAttribute((int)propertyOptions.PropertyMaxLength, $"{propertyOptions.PropertyName} cannot be longer than {propertyOptions.PropertyMaxLength} characters.");
        }

        if (!propertyOptions.IsNullable)
        {
            WriteRequiredAttribute($"{propertyOptions.PropertyName} is required.");
        }
#>
<#+
        if (!string.IsNullOrEmpty(propertyOptions.PropertyAttribute))
        {
#>
        <#= propertyOptions.PropertyAttribute #>  _
<#+
        }
#>
        Public Overridable Property <#= propertyOptions.FixedPropertyName #>() As <#= propertyOptions.PropertyType #>
            Get
                Return Me.<#= propertyOptions.PrivatePropertyName #>
            End Get
            Set
                Me.On<#= propertyOptions.PropertyName #>Changing(value)
                Me.<#= propertyOptions.PrivatePropertyName #> = value
                Me.On<#= propertyOptions.PropertyName #>Changed
<#+
        if (propertyOptions.WriteOnPropertyChanged)
        {
#>
                Me.OnPropertyChanged("<#= propertyOptions.OriginalPropertyName #>")
<#+
        }
#>
            End Set
        End Property
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
<#+
        string constructorString = string.Empty;
        if (!string.IsNullOrEmpty(propertyOptions.PropertyInitializationValue))
        {
            constructorString = " = " + propertyOptions.PropertyInitializationValue;
        }
#>
        Private <#= propertyOptions.PrivatePropertyName #> As <#= propertyOptions.PropertyType #><#= constructorString #>
        Partial Private Sub On<#= propertyOptions.PropertyName #>Changing(ByVal value As <#= propertyOptions.PropertyType #>)
        End Sub
        Partial Private Sub On<#= propertyOptions.PropertyName #>Changed()
        End Sub
<#+
    }

    internal override void WriteINotifyPropertyChangedImplementation()
    {
#>
        ''' <summary>
        ''' This event is raised when the value of the property is changed
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Public Event PropertyChanged As Global.System.ComponentModel.PropertyChangedEventHandler Implements Global.System.ComponentModel.INotifyPropertyChanged.PropertyChanged
        ''' <summary>
        ''' The value of the property is changed
        ''' </summary>
        ''' <param name="property">property name</param>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.OData.Client.Design.T4", "<#=T4Version#>")>  _
        Protected Overridable Sub OnPropertyChanged(ByVal [property] As String)
            If (Not (Me.PropertyChangedEvent) Is Nothing) Then
                RaiseEvent PropertyChanged(Me, New Global.System.ComponentModel.PropertyChangedEventArgs([property]))
            End If
        End Sub
<#+
    }

    internal override void WriteClassEndForStructuredType()
    {
#>
    End Class
<#+
    }

    internal override void WriteEnumFlags()
    {
#>
    <Global.System.Flags()>
<#+
    }

    internal override void WriteSummaryCommentForEnumType(string enumName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {enumName} in the schema." : description, true);
    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
    {
#>
    <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalEnumName #>")>  _
<#+
        }
#>
    <#= ClassAccessModifier #> Enum <#= enumName #><#= underlyingType #>
<#+
    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalMemberName #>")>  _
<#+
        }
#>
        <#= member #>
<#+
    }

    internal override void WriteEnumEnd()
    {
#>
    End Enum
<#+
    }

    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Overridable Function <#= functionName #>(<#= parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= returnTypeName #>)
            Return Me.CreateFunctionQuery(Of <#= returnTypeName #>)("", "/<#= originalFunctionName #>", <#= isComposable #> <#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Overridable Function <#= functionName #>(<#= parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #>
            Return <#= isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>Me.CreateFunctionQuerySingle(<#= "Of " + returnTypeName #>)("", "/<#= originalFunctionName #>", <#= isComposable #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>
        End Function
<#+
    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Overridable <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #>Function <#= functionName #>(<#= parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= returnTypeName #>)
            Dim requestUri As Global.System.Uri = Nothing
            Context.TryGetUri(Me, requestUri)
            Return Me.Context.CreateFunctionQuery(Of <#= returnTypeName #>)("", String.Join("/", Global.System.Linq.Enumerable.Select(Global.System.Linq.Enumerable.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function(s) s.Trim("/"C))) + "/<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Overridable <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #>Function <#= functionName #>(<#= parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #>
            Dim requestUri As Global.System.Uri = Nothing
            Context.TryGetUri(Me, requestUri)
            Return <#= isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>Me.Context.CreateFunctionQuerySingle(<#= "Of " + returnTypeName #>)(String.Join("/", Global.System.Linq.Enumerable.Select(Global.System.Linq.Enumerable.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function(s) s.Trim("/"C))), "/<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>
        End Function
<#+
    }

    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")>  _
<#+
        }
#>
        Public Overridable Function <#= actionName #>(<#= parameters #>) As <#= returnTypeName #>
            Return New <#= returnTypeName #>(Me, Me.BaseUri.OriginalString.Trim("/"C) + "/<#= originalActionName #>"<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")>  _
<#+
        }
#>
        Public Overridable <#= hideBaseMethod ? this.OverloadsModifier : string.Empty #>Function <#= actionName #>(<#= parameters #>) As <#= returnTypeName #>
            Dim resource As Global.Microsoft.OData.Client.EntityDescriptor = Context.EntityTracker.TryGetEntityDescriptor(Me)
            If resource Is Nothing Then
                Throw New Global.System.Exception("cannot find entity")
            End If

            Return New <#= returnTypeName #>(Me.Context, resource.EditLink.OriginalString.Trim("/"C) + "/<#= fullNamespace #>.<#= originalActionName #>"<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    internal override void WriteExtensionMethodsStart()
    {
#>
    ''' <summary>
    ''' Class containing all extension methods
    ''' </summary>
    <#= ClassAccessModifier #> Module ExtensionMethods
<#+
    }

    internal override void WriteExtensionMethodsEnd()
    {
#>
    End Module
<#+
    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {
#>
        ''' <summary>
        ''' Get an entity of type <#= entityTypeName #> as <#= returnTypeName #> specified by key from an entity set
        ''' </summary>
        ''' <param name="_source">source entity set</param>
        ''' <param name="_keys">dictionary with the names and values of keys</param>
        <Global.System.Runtime.CompilerServices.Extension()>
        Public Function ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= entityTypeName #>), ByVal _keys As Global.System.Collections.Generic.IDictionary(Of String, Object)) As <#= returnTypeName #>
            Return New <#= returnTypeName #>(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.GetKeyString(_source.Context, _keys)))
        End Function
        ''' <summary>
        ''' Get an entity of type <#= entityTypeName #> as <#= returnTypeName #> specified by key from an entity set
        ''' </summary>
        ''' <param name="_source">source entity set</param>
<#+
        foreach (var key in keys)
        {
#>
        ''' <param name="<#= key #>">The value of <#= key #></param>
<#+
        }
#>
        <Global.System.Runtime.CompilerServices.Extension()>
        Public Function ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= entityTypeName #>),
            <#= keyParameters #>) As <#= returnTypeName #>
            Dim _keys As Global.System.Collections.Generic.IDictionary(Of String, Object) = New Global.System.Collections.Generic.Dictionary(Of String, Object)() From
            {
                <#= keyDictionaryItems #>
            }
            Return New <#= returnTypeName #>(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.GetKeyString(_source.Context, _keys)))
        End Function
<#+
    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {
#>
        ''' <summary>
        ''' Cast an entity of type <#= baseTypeName #> to its derived type <#= derivedTypeFullName #>
        ''' </summary>
        ''' <param name="_source">source entity</param>
        <Global.System.Runtime.CompilerServices.Extension()>
        Public Function CastTo<#= derivedTypeName #>(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuerySingle(Of <#= baseTypeName #>)) As <#= returnTypeName #>
            Dim query As Global.Microsoft.OData.Client.DataServiceQuerySingle(Of <#= derivedTypeFullName #>) = _source.CastTo(Of <#= derivedTypeFullName #>)()
            Return New <#= returnTypeName #>(_source.Context, query.GetPath(Nothing))
        End Function
<#+
    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
#>
        <Global.System.Runtime.CompilerServices.Extension()>
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Function <#= functionName #>(ByVal _source As <#= boundTypeName #><#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As <#= isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName) #>
            If Not _source.IsComposable Then
                Throw New Global.System.NotSupportedException("The previous function is not composable.")
            End If

            Return <#= isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty #>_source.CreateFunctionQuerySingle(<#= "Of " + returnTypeName #>)("<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)<#= isReturnEntity ? ")" : string.Empty #>
        End Function
<#+
    }

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
#>
        <Global.System.Runtime.CompilerServices.Extension()>
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalFunctionName #>")>  _
<#+
        }
#>
        Public Function <#= functionName #>(ByVal _source As <#= boundTypeName #><#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #><#= useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty #>) As Global.Microsoft.OData.Client.DataServiceQuery(Of <#= returnTypeName #>)
            If Not _source.IsComposable Then
                Throw New Global.System.NotSupportedException("The previous function is not composable.")
            End If

            Return _source.CreateFunctionQuery(Of <#= returnTypeName #>)("<#= fullNamespace #>.<#= originalFunctionName #>", <#= isComposable #><#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
#>
        <Global.System.Runtime.CompilerServices.Extension()>
<#+
        if (this.context.EnableNamingAlias)
        {
#>
        <Global.Microsoft.OData.Client.OriginalNameAttribute("<#= originalActionName #>")>  _
<#+
        }
#>
        Public Function <#= actionName #>(ByVal _source As <#= boundSourceType #><#= string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters #>) As <#= returnTypeName #>
            If Not _source.IsComposable Then
                Throw New Global.System.NotSupportedException("The previous function is not composable.")
            End If
            Return New <#= returnTypeName #>(_source.Context, _source.AppendRequestUri("<#= fullNamespace #>.<#= originalActionName #>")<#= string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues #>)
        End Function
<#+
    }

    protected override void WriteDescriptionSummary(string description, bool isClass = false)
    {
        if (isClass)
        {
#>
    ''' <summary>
    ''' <#= description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n    \'\'\'") #>
    ''' </summary>
<#+
        }
        else
        {
#>
        ''' <summary>
        ''' <#= description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n        \'\'\'") #>
        ''' </summary>
<#+
        }
    }

    protected override void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false)
    {
        if (!revisionAnnotations.TryGetValue(deprecated, out string revisionDescription))
        {
           return;
        }

        if (isClass)
        {
#>
    <Global.System.ObsoleteAttribute("<#= revisionDescription #>")>  _
<#+
        }
        else
        {
#>
        <Global.System.ObsoleteAttribute("<#= revisionDescription #>")>  _
<#+
        }
    }

    protected override void WriteStringLengthAttribute(int maxLength, string errorMessage)
    {
#>
        <Global.System.ComponentModel.DataAnnotations.StringLengthAttribute(<#=maxLength#>)>  _
<#+
    }

    protected override void WriteRequiredAttribute(string errorMessage)
    {
#>
        <Global.System.ComponentModel.DataAnnotations.RequiredAttribute()>  _
<#+
    }

    internal override void WriteNamespaceEnd()
    {
#>
End Namespace
<#+
    }
}
#>
