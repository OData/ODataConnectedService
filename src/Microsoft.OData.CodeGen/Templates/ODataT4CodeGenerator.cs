// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.OData.CodeGen.Templates
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Xml;
    using System.Xml.Linq;
    using System.Collections.Generic;
    using Microsoft.OData.Edm.Csdl;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Edm.Validation;
    using Microsoft.OData.Edm.Vocabularies;
    using Microsoft.OData.Edm.Vocabularies.V1;
    using Microsoft.OData.Edm.Vocabularies.Community.V1;
    using Microsoft.OData.CodeGen.FileHandling;
    using Microsoft.OData.CodeGen.Logging;
    using System.Text;
    using System.Net;
    using System.Security;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class ODataT4CodeGenerator : ODataT4CodeGeneratorBase
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {

/*
//---------------------------------------------------------------------------------
// <copyright file="ODataT4CodeGenerator.ttinclude" company=".NET Foundation">
//      Copyright (c) .NET Foundation and Contributors.  All rights reserved.
//      See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------------------
*/

/*
//----------------------------------------------------------------------------------
// <copyright file="ODataT4CodeGenFilesManager.ttinclude" company=".NET Foundation">
//      Copyright (c) .NET Foundation and Contributors.  All rights reserved. 
//      See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------------------
*/

    CodeGenerationContext context;
    if (!string.IsNullOrWhiteSpace(this.Edmx))
    {
        context = new CodeGenerationContext(this.Edmx, this.NamespacePrefix)
        {
            UseDataServiceCollection = this.UseDataServiceCollection,
            TargetLanguage = this.TargetLanguage,
            EnableNamingAlias = this.EnableNamingAlias,
            IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
            MetadataFilePath = this.MetadataFilePath,
            MetadataFileRelativePath = this.MetadataFileRelativePath,
            MakeTypesInternal = this.MakeTypesInternal,
            MultipleFilesManager = new FilesManager(null),
            GenerateMultipleFiles = this.GenerateMultipleFiles,
            ExcludedOperationImports = this.ExcludedOperationImports,
            ExcludedBoundOperations = this.ExcludedBoundOperations,
            ExcludedSchemaTypes = this.ExcludedSchemaTypes,
            EmitContainerPropertyAttribute = this.EmitContainerPropertyAttribute
        };
    }
    else
    {
        this.ApplyParametersFromCommandLine();
        if (string.IsNullOrEmpty(metadataDocumentUri))
        {
            this.ApplyParametersFromConfigurationClass();
        }

        WebProxy proxy = null;
        if(this.IncludeWebProxy)
        {
            proxy = new WebProxy(this.WebProxyHost,true);

            if(this.IncludeWebProxyNetworkCredentials)
            {
               NetworkCredential  credentials = new NetworkCredential(this.WebProxyNetworkCredentialsUsername,
               this.WebProxyNetworkCredentialsPassword,
               this.WebProxyNetworkCredentialsDomain);
               proxy.Credentials = credentials;
            }

        }

        context = new CodeGenerationContext(new Uri(this.MetadataDocumentUri, UriKind.Absolute), this.NamespacePrefix, proxy, this.CustomHttpHeaders)
        {
            UseDataServiceCollection = this.UseDataServiceCollection,
            TargetLanguage = this.TargetLanguage,
            EnableNamingAlias = this.EnableNamingAlias,
            IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
            MetadataFilePath = this.MetadataFilePath,
            MetadataFileRelativePath = this.MetadataFileRelativePath,
            MakeTypesInternal = this.MakeTypesInternal,
            MultipleFilesManager = new FilesManager(null),
            GenerateMultipleFiles = this.GenerateMultipleFiles,
            ExcludedOperationImports = this.ExcludedOperationImports,
            ExcludedBoundOperations = this.ExcludedBoundOperations,
            ExcludedSchemaTypes = this.ExcludedSchemaTypes,
            EmitContainerPropertyAttribute = this.EmitContainerPropertyAttribute
        };
    }

     this.MultipleFilesManager = context.MultipleFilesManager;

    if(this.GetReferencedModelReaderFunc != null)
    {
        context.GetReferencedModelReaderFunc = this.GetReferencedModelReaderFunc;
    }

    ODataClientTemplate template;
    switch(this.TargetLanguage)
    {
        case LanguageOption.CSharp:
            template = new ODataClientCSharpTemplate(context);
            break;
        case LanguageOption.VB:
            template = new ODataClientVBTemplate(context);
            break;

        default:
            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, "Code gen for the target language '{0}' is not supported.", this.TargetLanguage.ToString()));
    }


            this.Write(this.ToStringHelper.ToStringWithCulture(template.TransformText()));

    foreach (string warning in context.Warnings)
    {
        this.Warning(warning);
    }

            return this.GenerationEnvironment.ToString();
        }
        private global::Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost hostValue;
        /// <summary>
        /// The current host for the text templating engine
        /// </summary>
        public virtual global::Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost Host
        {
            get
            {
                return this.hostValue;
            }
            set
            {
                this.hostValue = value;
            }
        }

public static class Configuration
{
	// The URI of the metadata document. The value must be set to a valid service document URI or a local file path
    // eg : "http://services.odata.org/V4/OData/OData.svc/", "File:///C:/Odata.edmx", or @"C:\Odata.edmx"
    // ### Notice ### If the OData service requires authentication for accessing the metadata document, the value of
    // MetadataDocumentUri has to be set to a local file path, or the client code generation process will fail.
	public const string MetadataDocumentUri = "";

	// The use of DataServiceCollection enables entity and property tracking. The value must be set to true or false.
	public const bool UseDataServiceCollection = true;

	// The namespace of the client code generated. It replaces the original namespace in the metadata document,
    // unless the model has several namespaces.
	public const string NamespacePrefix = "$rootnamespace$";

	// The target language of the generated client code. The value must be set to "CSharp" or "VB".
	public const string TargetLanguage = "OutputLanguage";

	// The path for the temporary file where the metadata xml document can be stored. Use this if your metadata is too big to be stored in a string literal. Ensure that you have write permission for this path.
	// For example - "C:\\temp\\Test.xml"
	public const string MetadataFilePath = "";

	// The relative path for the MetadataFilePath.
	public const string MetadataFileRelativePath = "";

	// This flag indicates whether to enable naming alias. The value must be set to true or false.
	public const bool EnableNamingAlias = true;

	// This flag indicates whether to ignore unexpected elements and attributes in the metadata document and generate
	// the client code if any. The value must be set to true or false.
	public const bool IgnoreUnexpectedElementsAndAttributes = true;

	// If set to true, generated types will have an "internal" class modifier ("Friend" in VB) instead of "public"
	// thereby making them invisible outside the assembly
	public const bool MakeTypesInternal = false;

	//This files indicates whether to generate the files into multiple files or single.
    //If set to true then multiple files will be generated. Otherwise only a single file is generated.
    public const bool GenerateMultipleFiles = false;

	// (Optional) Custom http headers as a multiline string
	public const string CustomHttpHeaders = "";

	// Comma-separated list of the names of operation imports to exclude from the generated code
	public const string ExcludedOperationImports = "";

	// Comma-separated list of the names of bound operations to exclude from the generated code
	public const string ExcludedBoundOperations = "";

    // Comma-separated list of the names of entity types to exclude from the generated code
	public const string ExcludedSchemaTypes = "";
}

public static class Customization
{
	/// <summary>
	/// Changes the text to use upper camel case, which upper case for the first character.
	/// </summary>
	/// <param name="text">Text to convert.</param>
	/// <returns>The converted text in upper camel case</returns>
	internal static string CustomizeNaming(string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return text;
		}

		if (text.Length == 1)
		{
			return Char.ToUpperInvariant(text[0]).ToString(CultureInfo.InvariantCulture);
		}

		return Char.ToUpperInvariant(text[0]) + text.Substring(1);
	}

	/// <summary>
	/// Changes the namespace to use upper camel case, which upper case for the first character of all segments.
	/// </summary>
	/// <param name="fullNamespace">Namespace to convert.</param>
	/// <returns>The converted namespace in upper camel case</returns>
	internal static string CustomizeNamespace(string fullNamespace)
	{
		if (string.IsNullOrEmpty(fullNamespace))
		{
			return fullNamespace;
		}

		string[] segs = fullNamespace.Split('.');
		string upperNamespace = string.Empty;
		int n = segs.Length;
		for (int i = 0; i < n; ++i)
		{
			upperNamespace += Customization.CustomizeNaming(segs[i]);
			upperNamespace += (i == n - 1 ? string.Empty : ".");
		}

		return upperNamespace;
	}
}


/// <summary>
/// The string for the edmx content.
/// </summary>
public string Edmx
{
    get;
    set;
}

/// <summary>
/// The Uri string to the metadata document.
/// </summary>
public string MetadataDocumentUri
{
    get
    {
        return this.metadataDocumentUri;
    }

    set
    {
        value = Uri.UnescapeDataString(value);
        Uri uri;
        if (!Uri.TryCreate(value, UriKind.Absolute, out uri))
        {
            // ********************************************************************************************************
            // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
            // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
            // value then hit Ctrl-S to save the .tt file to refresh the code generation.
            // ********************************************************************************************************
            throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" is not a valid MetadataDocumentUri because is it not a valid absolute Uri. The MetadataDocumentUri must be set to an absolute Uri referencing the $metadata endpoint of an OData service.", value));
        }

        if (uri.Scheme == "http" || uri.Scheme == "https")
        {
            value = uri.Scheme + "://" + uri.Authority + uri.AbsolutePath;
            value = value.TrimEnd('/');
            if (!value.EndsWith("$metadata"))
            {
                value += "/$metadata";
            }
        }

        this.metadataDocumentUri = value;
    }
}

private string metadataDocumentUri;

/// <summary>
/// The Func to get referenced model's XmlReader. Must have value when the this.Edmx xml or this.metadataDocumentUri's model has referneced model.
/// </summary>
public Func<Uri, WebProxy, IList<string>, XmlReader> GetReferencedModelReaderFunc
{
    get;
    set;
}

/// <summary>
/// The NamespacePrefix is used as the only namespace for types in the same namespace as the default container,
/// and as a prefix for the namespace from the model for everything else. If this argument is null, the
/// namespaces from the model are used for all types.
/// </summary>
public string NamespacePrefix
{
    get
    {
        return this.namespacePrefix;
    }

    set
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            this.namespacePrefix = null;
        }
        else
        {
            this.namespacePrefix = value;
        }
    }
}

private string namespacePrefix;

/// <summary>
/// true to use DataServiceCollection in the generated code, false otherwise.
/// </summary>
public bool UseDataServiceCollection
{
    get;
    set;
}

/// <summary>
/// Specifies which specific .Net Framework language the generated code will target.
/// </summary>
public LanguageOption TargetLanguage
{
    get;
    set;
}

/// <summary>
/// true to use Upper camel case for all class and property names, false otherwise.
/// </summary>
public bool EnableNamingAlias
{
    get;
    set;
}

/// <summary>
/// true to ignore unknown elements or attributes in metadata, false otherwise.
/// </summary>
public bool IgnoreUnexpectedElementsAndAttributes
{
    get;
    set;
}

/// <summary>
/// true to use the "internal" access modifier ("Friend" in VB) on generated types,
/// otherwise "public" is used
/// </summary>
public bool MakeTypesInternal
{
    get;
    set;
}

private IEnumerable<string> excludedOperationImports = new List<string>();

/// <summary>
/// list of operation imports to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedOperationImports
{
    get
    {
        return excludedOperationImports;
    }

    set
    {
        excludedOperationImports = value;
    }
}

private IEnumerable<string> excludedBoundOperations = new List<string>();

/// <summary>
/// list of bound operations to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedBoundOperations
{
    get
    {
        return excludedBoundOperations;
    }

    set
    {
        excludedBoundOperations = value;
    }
}

private IEnumerable<string> excludedSchemaTypes = new List<string>();

/// <summary>
/// List of entity types to exclude from the generated code
/// </summary>
public IEnumerable <string> ExcludedSchemaTypes
{
    get
    {
        return excludedSchemaTypes;
    }

    set
    {
        excludedSchemaTypes = value;
    }
}

/// <summary>
/// The path for the file where the metadata xml document can be stored.
/// </summary>
public string MetadataFilePath
{
    get;
    set;
}

/// <summary>
/// The relative path for the file where the metadata xml document can be stored.
/// </summary>
public string MetadataFileRelativePath
{
    get;
    set;
}

/// <summary>
/// Object instance of a file manager responsible for splitting generating multiple files.
/// </summary>
public FilesManager MultipleFilesManager
{
    get;
    set;
}

/// <summary>
/// The web proxy host address
/// </summary>
public string WebProxyHost
{
    get;
    set;
}

/// <summary>
/// true to generate multiple files, false generate a single file.
/// </summary>
public bool GenerateMultipleFiles
{
    get;
    set;
}
/// <summary>
/// Boolean to show if we should include the web proxy
/// </summary>
public bool IncludeWebProxy
{
    get;
    set;
}

/// <summary>
/// Boolean to show if we should include the web proxy network credentials
/// </summary>
public bool IncludeWebProxyNetworkCredentials
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials domain
/// </summary>
public string WebProxyNetworkCredentialsDomain
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials username
/// </summary>
public string WebProxyNetworkCredentialsUsername
{
    get;
    set;
}

/// <summary>
/// The web proxy host network credentials password
/// </summary>
public string WebProxyNetworkCredentialsPassword
{
    get;
    set;
}

/// <summary>
/// true to emit container property attribute on dynamic property container, false otherwise
/// </summary>
public bool EmitContainerPropertyAttribute
{
    get;
    internal set;
}

/// <summary>
/// Generate code targeting a specific .Net Framework language.
/// </summary>
public enum LanguageOption
{
    /// <summary>Generate code for C# language.</summary>
    CSharp = 0,

    /// <summary>Generate code for Visual Basic language.</summary>
    VB = 1,
}

/// <summary>
/// Stores Custom Http Headers to be added to the WebRequest.Headers property.
/// </summary>
public virtual IList<string> CustomHttpHeaders
{
    get;
    set;
}

/// <summary>
/// Set the UseDataServiceCollection property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetUseDataServiceCollectionFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the UseDataServiceCollection parameter because it is not a valid boolean value.", inputValue));
    }

    this.UseDataServiceCollection = boolValue;
}

/// <summary>
/// Tries to set the TargetLanguage property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetTargetLanguageFromString(string inputValue)
{
    LanguageOption option;
    if (!Enum.TryParse(inputValue, true, out option))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the TargetLanguage parameter because it is not a valid LanguageOption. The supported LanguageOptions are \"CSharp\" and \"VB\".", inputValue));
    }

    this.TargetLanguage = option;
}

/// <summary>
/// Set the EnableNamingAlias property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetEnableNamingAliasFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the EnableNamingAlias parameter because it is not a valid boolean value.", inputValue));
    }

    this.EnableNamingAlias = boolValue;
}

/// <summary>
/// Set the IgnoreUnexpectedElementsAndAttributes property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(string inputValue)
{
    bool boolValue;
    if (!bool.TryParse(inputValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the IgnoreUnexpectedElementsAndAttributes parameter because it is not a valid boolean value.", inputValue));
    }

    this.IgnoreUnexpectedElementsAndAttributes = boolValue;
}

/// <summary>
/// Set the MakeTypesInternal property with the given value.
/// </summary>
/// <param name="inputValue">The value to set.</param>
public void ValidateAndSetMakeTypesInternalFromString(string inputValue)
{
    bool parsedValue;
    if (!bool.TryParse(inputValue, out parsedValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The value \"{0}\" cannot be assigned to the MakeTypesInternal parameter because it is not a valid boolean value.", inputValue));
    }

    this.MakeTypesInternal = parsedValue;
}

/// <summary>
/// Validate the supplied custom http header string.
/// </summary>
/// <param name="header">Custom http header string.</param>
public void ValidateCustomHttpHeaderString(string header)
{
    if (!header.Contains(':'))
    {
        throw new ArgumentException("A http header string must have a colon delimeter");
    }
}

/// <summary>
/// Set the CustomHttpHeaders property using supplied custom http headers string.
/// </summary>
/// <param name="headersValue">Custom http headers string.</param>
public void SetCustomHttpHeadersFromString(string headersValue)
{
    if (String.IsNullOrWhiteSpace(headersValue))
    {
        return;
    }

    this.CustomHttpHeaders = new List<string>();

    string[] headerElements = headersValue.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
    foreach (var headerElement in headerElements)
    {
        // Trim header for empty spaces
        var header = headerElement.Trim();
        ValidateCustomHttpHeaderString(header);
        CustomHttpHeaders.Add(header);
    }
}

/// Set the ExcludedOperationImports property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of operation import names</param>
public void ValidateAndSetExcludedOperationImportsFromString(string inputValue)
{
    this.ExcludedOperationImports = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// Set the ExcludedBoundOperations property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of bound operation names</param>
public void ValidateAndSetExcludedBoundOperationsFromString(string inputValue)
{
    this.ExcludedBoundOperations = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// Set the ExcludedSchemaTypes property with the given value.
/// </summary>
/// <param name="inputValue">Comma-separated list of operation import names</param>
public void ValidateAndSetExcludedSchemaTypesFromString(string inputValue)
{
    this.ExcludedSchemaTypes = inputValue.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// <summary>
/// Reads the parameter values from the Configuration class and applies them.
/// </summary>
private void ApplyParametersFromConfigurationClass()
{
    this.MetadataDocumentUri = Configuration.MetadataDocumentUri;
    this.NamespacePrefix = Configuration.NamespacePrefix;
    this.UseDataServiceCollection = Configuration.UseDataServiceCollection;
    this.ValidateAndSetTargetLanguageFromString(Configuration.TargetLanguage);
    this.EnableNamingAlias = Configuration.EnableNamingAlias;
    this.IgnoreUnexpectedElementsAndAttributes = Configuration.IgnoreUnexpectedElementsAndAttributes;
    this.MakeTypesInternal = Configuration.MakeTypesInternal;
    this.MetadataFilePath = Configuration.MetadataFilePath;
    this.MetadataFileRelativePath = Configuration.MetadataFileRelativePath;
    this.GenerateMultipleFiles = Configuration.GenerateMultipleFiles;
    this.SetCustomHttpHeadersFromString(Configuration.CustomHttpHeaders);
    this.ExcludedOperationImports = Configuration.ExcludedOperationImports.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
    this.ExcludedBoundOperations = Configuration.ExcludedBoundOperations.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
    this.ExcludedSchemaTypes = Configuration.ExcludedSchemaTypes.Split(',')
        .Select(s => s.Trim()).Where(s => !string.IsNullOrEmpty(s)).ToList();
}

/// <summary>
/// Reads the parameter values from the command line (TextTransform.exe) and applies them.
/// </summary>
private void ApplyParametersFromCommandLine()
{
    if (this.Host == null)
    {
        return;
    }

    string metadataDocumentUri = this.Host.ResolveParameterValue("notempty", "notempty", "MetadataDocumentUri");
    if (!string.IsNullOrEmpty(metadataDocumentUri))
    {
        this.MetadataDocumentUri = metadataDocumentUri;
    }

    string namespacePrefix = this.Host.ResolveParameterValue("notempty", "notempty", "NamespacePrefix");
    if (!string.IsNullOrEmpty(namespacePrefix))
    {
        this.NamespacePrefix = namespacePrefix;
    }

    string useDataServiceCollection = this.Host.ResolveParameterValue("notempty", "notempty", "UseDataServiceCollection");
    if (!string.IsNullOrEmpty(useDataServiceCollection))
    {
        this.ValidateAndSetUseDataServiceCollectionFromString(useDataServiceCollection);
    }

    string targetLanguage = this.Host.ResolveParameterValue("notempty", "notempty", "TargetLanguage");
    if (!string.IsNullOrEmpty(targetLanguage))
    {
        this.ValidateAndSetTargetLanguageFromString(targetLanguage);
    }

    string enableNamingAlias = this.Host.ResolveParameterValue("notempty", "notempty", "EnableNamingAlias");
    if (!string.IsNullOrEmpty(enableNamingAlias))
    {
        this.ValidateAndSetEnableNamingAliasFromString(enableNamingAlias);
    }

    string ignoreUnexpectedElementsAndAttributes = this.Host.ResolveParameterValue("notempty", "notempty", "IgnoreUnexpectedElementsAndAttributes");
    if (!string.IsNullOrEmpty(ignoreUnexpectedElementsAndAttributes))
    {
        this.ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(ignoreUnexpectedElementsAndAttributes);
    }

    string makeTypesInternal = this.Host.ResolveParameterValue("notempty", "notempty", "MakeTypesInternal");
    if (!string.IsNullOrEmpty(makeTypesInternal))
    {
        this.ValidateAndSetMakeTypesInternalFromString(makeTypesInternal);
    }

    string customHttpHeaders = this.Host.ResolveParameterValue("notempty", "notempty", "CustomHttpHeaders");
    if (!string.IsNullOrEmpty(customHttpHeaders))
    {
        this.SetCustomHttpHeadersFromString(customHttpHeaders);
    }
}

/// <summary>
/// Enable one to mock the requests when fetching metadata
/// </summary>
internal interface IHttpRequestCreator
{
    HttpWebRequest Create(Uri uri);
}
/// <summary>
/// Includes a default http request creator that creates web requests for the client
/// </summary>
internal class DefaultHttpRequestCreator : IHttpRequestCreator
{
    public HttpWebRequest Create(Uri uri)
    {
        return (HttpWebRequest) WebRequest.Create(uri);
    }
}

/// <summary>
/// Context object to provide the model and configuration info to the code generator.
/// </summary>
public class CodeGenerationContext
{
    /// <summary>
    /// The namespace of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermNamespace = "Com.Microsoft.OData.Service.Conventions.V1";

    /// <summary>
    /// The name of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermName = "UrlConventions";

    /// <summary>
    /// The string value for indicating that the key-as-segment convention is being used in annotations and headers.
    /// </summary>
    private const string KeyAsSegmentConventionName = "KeyAsSegment";

    /// <summary>
    /// The XElement for the edmx
    /// </summary>
    private readonly XElement edmx;

    /// <summary>
    /// The namespacePrefix is used as the only namespace in generated code when there's only one schema in edm model,
    /// and as a prefix for the namespace from the model with multiple schemas. If this argument is null, the
    /// namespaces from the model are used for all types.
    /// </summary>
    private readonly string namespacePrefix;

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    private IEdmModel edmModel;

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    private string[] namespacesInModel;

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    private string[] warnings;

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    private bool? modelHasInheritance;

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    private Dictionary<string, string> namespaceMap;

    /// <summary>
    /// Maps the element type of a navigation source to the navigation source.
    /// </summary>
    private Dictionary<IEdmEntityType, List<IEdmNavigationSource>> elementTypeToNavigationSourceMap;

    /// <summary>
    /// HashSet contains the pair of Names and Namespaces of EntityContainers using KeyAsSegment url convention
    /// </summary>
    private HashSet<string> keyAsSegmentContainers;

    /// <summary>
    /// Preconfigured WebProxy for fetching the metadata
    /// </summary>
    private WebProxy webProxy;

    /// <summary>
    /// The metadata uri used for the original source edmx
    /// </summary>
    private Uri metadataUri;

    private  IList<string> customHttpHeaders;
    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    public CodeGenerationContext(Uri metadataUri, string namespacePrefix)
        : this(metadataUri, namespacePrefix, null, null)
    {
    }

    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    /// <param name="proxy">Webproxy instance to use for retriving the metadata</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    public CodeGenerationContext(Uri metadataUri, string namespacePrefix,  WebProxy proxy,  IList<string> CustomHttpHeaders)
        : this(GetEdmxStringFromMetadataPath(metadataUri, proxy, CustomHttpHeaders), namespacePrefix)
    {
        this.metadataUri = metadataUri;
        webProxy = proxy;
        customHttpHeaders = CustomHttpHeaders;
    }
    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="edmx">The string for the edmx.</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    /// when there's only one schema in edm model, and as a prefix for the namespace from the model with multiple
    /// schemas. If this argument is null, the namespaces from the model are used for all types.</param>
    public CodeGenerationContext(string edmx, string namespacePrefix)
    {
        this.edmx = XElement.Parse(edmx);
        this.namespacePrefix = namespacePrefix;
    }

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public XElement Edmx
    {
        get { return this.edmx; }
    }

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public IEdmModel EdmModel
    {
        get
        {
            if (this.edmModel == null)
            {
                Debug.Assert(this.edmx != null, "this.edmx != null");

                IEnumerable<Microsoft.OData.Edm.Validation.EdmError> errors;
                CsdlReaderSettings csdlReaderSettings = new CsdlReaderSettings()
                {
                    GetReferencedModelReaderFunc = this.GetReferencedModelReaderFuncWrapper,
                    IgnoreUnexpectedAttributesAndElements = this.IgnoreUnexpectedElementsAndAttributes
                };
                if (!CsdlReader.TryParse(this.edmx.CreateReader(ReaderOptions.None), Enumerable.Empty<IEdmModel>(), csdlReaderSettings, out this.edmModel, out errors))
                {
                    Debug.Assert(errors != null, "errors != null");
                    throw new InvalidOperationException(errors.FirstOrDefault().ErrorMessage);
                }
                else if (this.IgnoreUnexpectedElementsAndAttributes)
                {
                    if (errors != null && errors.Any())
                    {
                        this.warnings = errors.Select(e => e.ErrorMessage).ToArray();
                    }
                }
            }

            return this.edmModel;
        }
    }

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    public Func<Uri, WebProxy, IList<string>, XmlReader> GetReferencedModelReaderFunc
    {
        get { return getReferencedModelReaderFunc; }
        set { this.getReferencedModelReaderFunc = value; }
    }
    private static IHttpRequestCreator requestCreator;
    internal static IHttpRequestCreator RequestCreator
    {
        get
        {
             if(requestCreator==null)
             {
                requestCreator= new DefaultHttpRequestCreator();
             }
             return  requestCreator;
        }

        set { requestCreator = value;}
    }
    /// <summary>
    /// Basic setting for XmlReader.
    /// </summary>
    private static readonly XmlReaderSettings settings = new XmlReaderSettings() { IgnoreWhitespace = true, XmlResolver = null };

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    private Func<Uri, WebProxy, IList<string>, XmlReader> getReferencedModelReaderFunc = (uri, proxy, headers) => XmlReader.Create(GetEdmxStreamFromUri(uri, proxy, headers), settings);

    /// <summary>
    /// The Wrapper func for user code to overwrite and provide referenced model's stream.
    /// </summary>
    public Func<Uri, XmlReader> GetReferencedModelReaderFuncWrapper
    {
        get
        {
            return (uri) =>
            {
                Uri originalUri = uri;
                if(!uri.IsAbsoluteUri)
                {
                    // In the case that the reference model uri is relative we should create an absolute uri using the metadataUri as the base
                    uri = new Uri(metadataUri, uri.ToString());
                }
                using (XmlReader reader = GetReferencedModelReaderFunc(uri, webProxy, customHttpHeaders))
                {
                    if (reader == null)
                    {
                        return null;
                    }

                    XElement element = XElement.Load(reader);
                    if (this.ReferencesMap == null)
                    {
                        this.ReferencesMap = new Dictionary<Uri, XElement>();
                    }

                    this.ReferencesMap.Add(originalUri, element);
                    return element.CreateReader(ReaderOptions.None);
                }
            };
        }
    }

    /// <summary>
    /// Dictionary that stores uri and referenced xml mapping.
    /// </summary>
    public Dictionary<Uri, XElement> ReferencesMap
    {
        get;
        set;
    }

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    public string[] NamespacesInModel
    {
        get
        {
            if (this.namespacesInModel == null)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.namespacesInModel = GetElementsFromModelTree(this.EdmModel, (m) => m.SchemaElements.Select(e => e.Namespace)).Distinct().ToArray();
            }

            return this.namespacesInModel;
        }
    }

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    public string[] Warnings
    {
        get { return this.warnings ?? (this.warnings = new string[] {}); }
    }

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    public bool ModelHasInheritance
    {
        get
        {
            if (!this.modelHasInheritance.HasValue)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.modelHasInheritance = this.EdmModel.SchemaElementsAcrossModels().OfType<IEdmStructuredType>().Any(t => !t.FullTypeName().StartsWith("Org.OData.Authorization.V1") &&
                            !t.FullTypeName().StartsWith("Org.OData.Capabilities.V1") &&
                            !t.FullTypeName().StartsWith("Org.OData.Core.V1") && t.BaseType != null);
            }

            return this.modelHasInheritance.Value;
        }
    }

    /// <summary>
    /// true if we need to generate the ResolveNameFromType method, false otherwise.
    /// </summary>
    public bool NeedResolveNameFromType
    {
        get    { return this.ModelHasInheritance || this.NamespaceMap.Count > 0 || this.EnableNamingAlias; }
    }

    /// <summary>
    /// true if we need to generate the ResolveTypeFromName method, false otherwise.
    /// </summary>
    public bool NeedResolveTypeFromName
    {
        get { return this.NamespaceMap.Count > 0 || this.EnableNamingAlias; }
    }

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    public Dictionary<string, string> NamespaceMap
    {
        get
        {
            if (this.namespaceMap == null)
            {
                if (!string.IsNullOrEmpty(this.namespacePrefix))
                {
                    if (this.NamespacesInModel.Count() == 1)
                    {
                        IEdmEntityContainer container = this.EdmModel.EntityContainer;
                        string containerNamespace = container == null ? null : container.Namespace;
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => ns == containerNamespace ?
                                    this.namespacePrefix :
                                    this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                    else
                    {
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                }
                else if (this.EnableNamingAlias)
                {
                    this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => Customization.CustomizeNamespace(ns));
                }
                else
                {
                    this.namespaceMap = new Dictionary<string, string>();
                }
            }

            return this.namespaceMap;
        }
    }

    /// <summary>
    /// true to use DataServiceCollection in the generated code, false otherwise.
    /// </summary>
    public bool UseDataServiceCollection
    {
        get;
        set;
    }

	/// <summary>
	/// true to use internal access modifier for generated classes, otherwise they will be made public.
	/// This is useful if you don't want the generated classes to be visible outside the assembly
	/// </summary>
    public bool MakeTypesInternal
    {
        get;
        set;
    }

    /// <summary>
	/// list of operation imports to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedOperationImports
    {
        get;
        set;
    }

    /// <summary>
	/// list of bound operations to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedBoundOperations
    {
        get;
        set;
    }

    /// <summary>
	/// list of entity types to omit from the generated code
	/// </summary>
    public IEnumerable<string> ExcludedSchemaTypes
    {
        get;
        set;
    }

    /// <summary>
    /// Specifies which specific .Net Framework language the generated code will target.
    /// </summary>
    public LanguageOption TargetLanguage
    {
        get;
        set;
    }

    /// <summary>
    /// true to use Upper camel case for all class and property names, false otherwise.
    /// </summary>
    public bool EnableNamingAlias
    {
        get;
        set;
    }

    /// <summary>
    /// true to ignore unknown elements or attributes in metadata, false otherwise.
    /// </summary>
    public bool IgnoreUnexpectedElementsAndAttributes
    {
        get;
        set;
    }

    /// <summary>
    /// true to generate multiple files, false generate a single file.
    /// </summary>
    public bool GenerateMultipleFiles
    {
        get;
        set;
    }

    /// <summary>
    /// The path for the file where the metadata xml document can be stored.
    /// </summary>
    public string MetadataFilePath
    {
        get;
        set;
    }

    /// <summary>
    /// The relative path for the file where the metadata xml document can be stored.
    /// </summary>
    public string MetadataFileRelativePath
    {
        get;
        set;
    }

    /// <summary>
    /// Object instance of a file manager responsible for splitting generating multiple files.
    /// </summary>
    public FilesManager MultipleFilesManager
    {
        get;
        set;
    }

    /// <summary>
    /// Maps the element type of an entity set to the entity set.
    /// </summary>
    public Dictionary<IEdmEntityType, List<IEdmNavigationSource>> ElementTypeToNavigationSourceMap
    {
        get
        {
            return this.elementTypeToNavigationSourceMap ?? (this.elementTypeToNavigationSourceMap = new Dictionary<IEdmEntityType, List<IEdmNavigationSource>>(EqualityComparer<IEdmEntityType>.Default));
        }
    }

    /// <summary>
    /// true to emit container property attribute on dynamic property container, false otherwise.
    /// </summary>
    public bool EmitContainerPropertyAttribute
    {
        get;
        set;
    }

    /// <summary>
    /// true if this EntityContainer need to set the UrlConvention to KeyAsSegment, false otherwise.
    /// </summary>
    public bool UseKeyAsSegmentUrlConvention(IEdmEntityContainer currentContainer)
    {
        if (this.keyAsSegmentContainers == null)
        {
            this.keyAsSegmentContainers = new HashSet<string>();
            Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
            IEnumerable<IEdmVocabularyAnnotation> annotations = this.EdmModel.VocabularyAnnotations;
            foreach(IEdmVocabularyAnnotation valueAnnotation in annotations)
            {
                IEdmEntityContainer container = valueAnnotation.Target as IEdmEntityContainer;
                IEdmTerm valueTerm = valueAnnotation.Term as IEdmTerm;
                IEdmStringConstantExpression expression = valueAnnotation.Value as IEdmStringConstantExpression;
                if (container != null && valueTerm != null && expression != null)
                {
                    if (valueTerm.Namespace == ConventionTermNamespace &&
                        valueTerm.Name == ConventionTermName &&
                        expression.Value == KeyAsSegmentConventionName)
                    {
                        this.keyAsSegmentContainers.Add(container.FullName());
                    }
                }
            }
        }

        return this.keyAsSegmentContainers.Contains(currentContainer.FullName());
    }

    /// <summary>
    /// Gets the enumeration of schema elements with the given namespace.
    /// </summary>
    /// <param name="ns">The namespace of the schema elements to get.</param>
    /// <returns>The enumeration of schema elements with the given namespace.</returns>
    public IEnumerable<IEdmSchemaElement> GetSchemaElements(string ns)
    {
        Debug.Assert(ns != null, "ns != null");
        Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
        return GetElementsFromModelTree(this.EdmModel, m => m.SchemaElements.Where(e => e.Namespace == ns));
    }

    /// <summary>
    /// Gets the namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.
    /// </summary>
    /// <param name="schemaElement">The schema element to get the full name for.</param>
    /// <param name="schemaElementFixedName">The fixed name of this schemaElement.</param>
    /// <param name="template">The current code generate template.</param>
    /// <returns>The namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.</returns>
    public string GetPrefixedFullName(IEdmSchemaElement schemaElement, string schemaElementFixedName, ODataClientTemplate template, bool needGlobalPrefix = true)
    {
        if (schemaElement == null)
        {
            return null;
        }

        return this.GetPrefixedNamespace(schemaElement.Namespace, template, true, needGlobalPrefix) + "." + schemaElementFixedName;
    }

    /// <summary>
    /// Gets the prefixed namespace for the given <paramref name="ns"/>.
    /// </summary>
    /// <param name="ns">The namespace without the prefix.</param>
    /// <param name="template">The current code generate template.</param>
    /// <param name="needFix">The flag indicates whether the namespace need to be fixed now.</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by gloabal prefix.</param>
    /// <returns>The prefixed namespace for the given <paramref name="ns"/>.</returns>
    public string GetPrefixedNamespace(string ns, ODataClientTemplate template, bool needFix, bool needGlobalPrefix)
    {
        if (ns == null)
        {
            return null;
        }

        string prefixedNamespace;
        if (!this.NamespaceMap.TryGetValue(ns, out prefixedNamespace))
        {
            prefixedNamespace = ns;
        }

        if (needFix)
        {
            string[] segments = prefixedNamespace.Split('.');
            prefixedNamespace = string.Empty;
            int n = segments.Length;
            for (int i = 0; i < n; ++i)
            {
                if (template.LanguageKeywords.Contains(segments[i]))
                {
                    prefixedNamespace += string.Format(CultureInfo.InvariantCulture, template.FixPattern, segments[i]);
                }
                else
                {
                    prefixedNamespace += segments[i];
                }

                prefixedNamespace += (i == n - 1 ? string.Empty : ".");
            }
        }

        if (needGlobalPrefix)
        {
            prefixedNamespace = template.GlobalPrefix + prefixedNamespace;
        }

        return prefixedNamespace;
    }

    /// <summary>
    /// Reads the edmx string from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    private static string GetEdmxStringFromMetadataPath(Uri metadataUri, WebProxy proxy, IList<string> customHttpHeaders)
    {
        string content = null;
        using (StreamReader streamReader = new StreamReader(GetEdmxStreamFromUri(metadataUri, proxy ,customHttpHeaders)))
        {
            content = streamReader.ReadToEnd();
        }

        return content;
    }

    /// <summary>
    /// Get the metadata stream from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the stream. The supported scheme are File, http and https.</param>
    private static Stream GetEdmxStreamFromUri(Uri metadataUri, WebProxy proxy, IList<string> customHttpHeaders)
    {
        Debug.Assert(metadataUri != null, "metadataUri != null");
        Stream metadataStream = null;
        if (metadataUri.Scheme == "file")
        {
            metadataStream = new FileStream(Uri.UnescapeDataString(metadataUri.AbsolutePath), FileMode.Open, FileAccess.Read);
        }
        else if (metadataUri.Scheme == "http" || metadataUri.Scheme == "https")
        {
            try
            {
                 HttpWebRequest webRequest = RequestCreator.Create(metadataUri);
                if (customHttpHeaders != null)
                {
                    foreach (var header in customHttpHeaders)
                    {
                        webRequest.Headers.Add(header);
                    }
                }

                if(proxy != null)
                {
                    webRequest.Proxy= proxy;
                }

                WebResponse webResponse = webRequest.GetResponse();
                metadataStream = webResponse.GetResponseStream();

            }
            catch (WebException e)
            {
                HttpWebResponse webResponse = e.Response as HttpWebResponse;
                if (webResponse != null && webResponse.StatusCode == HttpStatusCode.Unauthorized)
                {
                    throw new WebException("Failed to access the metadata document. The OData service requires authentication for accessing it. Please download the metadata, store it into a local file, and set the value of “MetadataDocumentUri” in the .odata.config file to the file path. After that, run custom tool again to generate the OData Client code.");
                }
                else
                {
                    throw e;
                }
            }
        }
        else
        {
            throw new ArgumentException("Only file, http, https schemes are supported for paths to metadata source locations.");
        }

        return metadataStream;
    }

    private static IEnumerable<T> GetElementsFromModelTree<T>(IEdmModel mainModel, Func<IEdmModel, IEnumerable<T>> getElementFromOneModelFunc)
    {
        List<T> ret = new List<T>();
        if(mainModel is EdmCoreModel || mainModel.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null)
        {
            return ret;
        }

        ret.AddRange(getElementFromOneModelFunc(mainModel));
        foreach (var tmp in mainModel.ReferencedModels)
        {
            if (tmp is EdmCoreModel ||
                tmp.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null ||
                tmp.FindDeclaredTerm(CapabilitiesVocabularyConstants.ChangeTracking) != null ||
                tmp.FindDeclaredTerm(AlternateKeysVocabularyConstants.AlternateKeys) != null ||
                tmp.FindDeclaredTerm("Org.OData.Authorization.V1.Authorizations") != null ||
                tmp.FindDeclaredTerm("Org.OData.Validation.V1.DerivedTypeConstraint") != null ||
                tmp.FindDeclaredTerm("Org.OData.Community.V1.UrlEscapeFunction") != null)
            {
                continue;
            }

            ret.AddRange(getElementFromOneModelFunc(tmp));
        }

        return ret;
    }
}

/// <summary>
/// The template class to generate the OData client code.
/// </summary>
public abstract class ODataClientTemplate : TemplateBase
{
    protected const string T4Version  = "#VersionNumber#";

    protected const string deprecated = "Deprecated";

    /// <summary>
    /// The code generation context.
    /// </summary>
    protected readonly CodeGenerationContext context;

    /// <summary>
    /// The Dictionary to store identifier mappings when there are duplicate names between properties and Entity/Complex types
    /// </summary>
    protected Dictionary<string, string> IdentifierMappings = new Dictionary<string, string>(StringComparer.Ordinal);

    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientTemplate(CodeGenerationContext context)
    {
        this.context = context;
        if(context.MultipleFilesManager != null)
        {
            context.MultipleFilesManager.Template = this.GenerationEnvironment;
        }
    }

    internal string SingleSuffix
    {
        get { return "Single"; }
    }

    /// <summary>
    /// Options for <see cref="WritePropertyForStructuredType"/> method.
    /// </summary>
    internal class PropertyOptions
    {
        public string PropertyType { get; set; }
        public string OriginalPropertyName { get; set; }
        public string PropertyName { get; set; }
        public string FixedPropertyName { get; set; }
        public string PrivatePropertyName { get; set; }
        public string PropertyInitializationValue { get; set; }
        public string PropertyAttribute { get; set; }
        public string PropertyDescription { get; set; }
        public int? PropertyMaxLength { get; set; }
        public bool WriteOnPropertyChanged { get; set; }
        public bool IsNullable { get; set; }
        public IDictionary<string, string> RevisionAnnotations { get; set; }

        public override bool Equals(object other)
        {
            if(other == null)
                return false;
            
            if (object.ReferenceEquals(this, other))
                return true;

            if (this.GetType() != other.GetType())
                return false;

            return this.Equals(other as PropertyOptions);
        }

        private bool Equals(PropertyOptions other)
        {
            return
                string.Compare(this.PropertyType, other.PropertyType) == 0 &&
                string.Compare(this.OriginalPropertyName, other.OriginalPropertyName) == 0 &&
                string.Compare(this.PropertyName, other.PropertyName) == 0 &&
                string.Compare(this.FixedPropertyName, other.FixedPropertyName) == 0 &&
                string.Compare(this.PrivatePropertyName, other.PrivatePropertyName) == 0 &&
                string.Compare(this.PropertyInitializationValue, other.PropertyInitializationValue) == 0 &&
                string.Compare(this.PropertyAttribute, other.PropertyAttribute) == 0 &&
                string.Compare(this.PropertyDescription, other.PropertyDescription) == 0 &&
                other.PropertyMaxLength == null
                    ? this.PropertyMaxLength == null
                    : other.PropertyMaxLength.Equals(this.PropertyMaxLength) &&
                other.WriteOnPropertyChanged.Equals(this.WriteOnPropertyChanged) &&
                other.IsNullable.Equals(this.IsNullable) &&
                other.RevisionAnnotations == null
                    ? this.RevisionAnnotations == null
                    : other.RevisionAnnotations.Equals(this.RevisionAnnotations);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    #region Get Language specific keyword names.
    internal abstract string GlobalPrefix { get; }
    internal abstract string SystemTypeTypeName { get; }
    internal abstract string AbstractModifier { get; }
    internal abstract string PublicAccessModifier { get; }
    internal abstract string InternalAccessModifier { get; }
    internal abstract string DataServiceActionQueryTypeName { get; }
    internal abstract string DataServiceActionQuerySingleOfTStructureTemplate { get; }
    internal abstract string DataServiceActionQueryOfTStructureTemplate { get; }
    internal abstract string NotifyPropertyChangedModifier { get; }
    internal abstract string ClassInheritMarker { get; }
    internal abstract string ParameterSeparator { get; }
    internal abstract string KeyParameterSeparator { get; }
    internal abstract string KeyDictionaryItemSeparator { get; }
    internal abstract string SystemNullableStructureTemplate { get; }
    internal abstract string ICollectionOfTStructureTemplate { get; }
    internal abstract string DataServiceCollectionStructureTemplate { get; }
    internal abstract string DataServiceQueryStructureTemplate { get; }
    internal abstract string DataServiceQuerySingleStructureTemplate { get; }
    internal abstract string ObservableCollectionStructureTemplate { get; }
    internal abstract string ObjectModelCollectionStructureTemplate { get; }
    internal abstract string DataServiceCollectionConstructorParameters { get; }
    internal abstract string NewModifier { get; }
    internal abstract string GeoTypeInitializePattern { get; }
    internal abstract string ObjectTypeName { get; }
    internal abstract string Int32TypeName { get; }
    internal abstract string StringTypeName { get; }
    internal abstract string BinaryTypeName { get; }
    internal abstract string DecimalTypeName { get; }
    internal abstract string Int16TypeName { get; }
    internal abstract string SingleTypeName { get; }
    internal abstract string BooleanTypeName { get; }
    internal abstract string DoubleTypeName { get; }
    internal abstract string GuidTypeName { get; }
    internal abstract string ByteTypeName { get; }
    internal abstract string Int64TypeName { get; }
    internal abstract string SByteTypeName { get; }
    internal abstract string DataServiceStreamLinkTypeName { get; }
    internal abstract string GeographyTypeName { get; }
    internal abstract string GeographyPointTypeName { get; }
    internal abstract string GeographyLineStringTypeName { get; }
    internal abstract string GeographyPolygonTypeName { get; }
    internal abstract string GeographyCollectionTypeName { get; }
    internal abstract string GeographyMultiPolygonTypeName { get; }
    internal abstract string GeographyMultiLineStringTypeName { get; }
    internal abstract string GeographyMultiPointTypeName { get; }
    internal abstract string GeometryTypeName { get; }
    internal abstract string GeometryPointTypeName { get; }
    internal abstract string GeometryLineStringTypeName { get; }
    internal abstract string GeometryPolygonTypeName { get; }
    internal abstract string GeometryCollectionTypeName { get; }
    internal abstract string GeometryMultiPolygonTypeName { get; }
    internal abstract string GeometryMultiLineStringTypeName { get; }
    internal abstract string GeometryMultiPointTypeName { get; }
    internal abstract string DateTypeName { get; }
    internal abstract string DateTimeOffsetTypeName { get; }
    internal abstract string DurationTypeName { get; }
    internal abstract string TimeOfDayTypeName { get; }
    internal abstract string XmlConvertClassName { get; }
    internal abstract string EnumTypeName { get; }
    internal abstract string DictionaryInterfaceName { get; }
    internal abstract string DictionaryTypeName { get; }
    internal abstract HashSet<string> LanguageKeywords { get; }
    internal abstract string FixPattern { get; }
    internal abstract string EnumUnderlyingTypeMarker { get; }
    internal abstract string ConstantExpressionConstructorWithType { get; }
    internal abstract string TypeofFormatter { get; }
    internal abstract string UriOperationParameterConstructor { get; }
    internal abstract string UriEntityOperationParameterConstructor { get; }
    internal abstract string BodyOperationParameterConstructor { get; }
    internal abstract string DictionaryConstructor { get; }
    internal abstract string BaseEntityType { get; }
    internal abstract string OverloadsModifier { get; }
    internal abstract string ODataVersion { get; }
    internal abstract string ParameterDeclarationTemplate { get; }
    internal abstract string DictionaryItemConstructor { get; }
    internal abstract string ContainerPropertyBase { get; }
    internal abstract string ContainerPropertyAttribute { get; }
    #endregion Get Language specific keyword names.

    #region Language specific write methods.
    internal abstract void WriteFileHeader();
    internal abstract void WriteNamespaceStart(string fullNamespace);
    internal abstract void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description);
    internal abstract void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName);
    internal abstract void WriteKeyAsSegmentUrlConvention();
    internal abstract void WriteInitializeResolveName();
    internal abstract void WriteInitializeResolveType();
    internal abstract void WriteClassEndForEntityContainerConstructor();
    internal abstract void WriteMethodStartForResolveTypeFromName();
    internal abstract void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveTypeFromName();
    internal abstract void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace);
    internal abstract void WriteResolveType(string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveNameFromType(bool modelHasInheritance);
    internal abstract void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext = true);
    internal abstract void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext = true);
    internal abstract void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName);
    internal abstract void WriteGeneratedEdmModel(string escapedEdmxString);
    internal abstract void WriteClassEndForEntityContainer();
    internal abstract void WriteSummaryCommentForStructuredType(string typeName, string description);
    internal abstract void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString);
    internal abstract void WriteEntityTypeAttribute();
    internal abstract void WriteEntitySetAttribute(string entitySetName);
    internal abstract void WriteEntityHasStreamAttribute();
    internal abstract void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName);
    internal abstract void WriteSummaryCommentForStaticCreateMethod(string typeName);
    internal abstract void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName);
    internal abstract void WriteDeclarationStartForStaticCreateMethod(string typeName,string fixedTypeName );
    internal abstract void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater);
    internal abstract void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName);
    internal abstract void WriteParameterNullCheckForStaticCreateMethod(string parameterName);
    internal abstract void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName);
    internal abstract void WriteMethodEndForStaticCreateMethod(string instanceName);
    internal abstract void WritePropertyForStructuredType(PropertyOptions propertyOptions);
    internal abstract void WriteINotifyPropertyChangedImplementation();
    internal abstract void WriteClassEndForStructuredType();
    internal abstract void WriteNamespaceEnd();
    internal abstract void WriteEnumFlags();
    internal abstract void WriteSummaryCommentForEnumType(string enumName, string description);
    internal abstract void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType);
    internal abstract void WriteMemberForEnumType(string member, string originalMemberName, bool last);
    internal abstract void WriteEnumEnd();
    internal abstract void WritePropertyRootNamespace(string containerName, string fullNamespace);
    internal abstract void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations);
    internal abstract void WriteConstructorForSingleType(string singleTypeName, string baseTypeName);
    internal abstract void WriteExtensionMethodsStart();
    internal abstract void WriteExtensionMethodsEnd();
    internal abstract void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems);
    internal abstract void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName);
    internal abstract void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description);
    internal abstract void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description);
    internal abstract void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description);
    protected abstract void WriteDescriptionSummary(string description, bool isClass = false);
    protected abstract void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false);
    protected abstract void WriteStringLengthAttribute(int maxLength, string errorMessage);
    protected abstract void WriteRequiredAttribute(string errorMessage);
    #endregion Language specific write methods.

    internal HashSet<EdmPrimitiveTypeKind> ClrReferenceTypes { get {
        if (clrReferenceTypes == null)
        {
            clrReferenceTypes = new HashSet<EdmPrimitiveTypeKind>()
            {
                EdmPrimitiveTypeKind.String, EdmPrimitiveTypeKind.Binary, EdmPrimitiveTypeKind.Geography, EdmPrimitiveTypeKind.Stream,
                EdmPrimitiveTypeKind.GeographyPoint, EdmPrimitiveTypeKind.GeographyLineString, EdmPrimitiveTypeKind.GeographyPolygon,
                EdmPrimitiveTypeKind.GeographyCollection, EdmPrimitiveTypeKind.GeographyMultiPolygon, EdmPrimitiveTypeKind.GeographyMultiLineString,
                EdmPrimitiveTypeKind.GeographyMultiPoint, EdmPrimitiveTypeKind.Geometry, EdmPrimitiveTypeKind.GeometryPoint,
                EdmPrimitiveTypeKind.GeometryLineString, EdmPrimitiveTypeKind.GeometryPolygon, EdmPrimitiveTypeKind.GeometryCollection,
                EdmPrimitiveTypeKind.GeometryMultiPolygon, EdmPrimitiveTypeKind.GeometryMultiLineString, EdmPrimitiveTypeKind.GeometryMultiPoint
            };
        }
        return clrReferenceTypes;
    } }
    private HashSet<EdmPrimitiveTypeKind> clrReferenceTypes;

    internal string ClassAccessModifier {
        get {
            return this.context.MakeTypesInternal ? this.InternalAccessModifier : this.PublicAccessModifier;
        }
    }

    /// <summary>
    /// Generates code for the OData client.
    /// </summary>
    /// <returns>The generated code for the OData client.</returns>
    public override string TransformText()
    {
        context.MultipleFilesManager.StartHeader();
        this.WriteFileHeader();
        context.MultipleFilesManager.EndBlock();
        this.WriteNamespaces();
        context.MultipleFilesManager.GenerateFiles(context.GenerateMultipleFiles, null, null, null, false, false);
        return context.MultipleFilesManager.Template.ToString();
    }

    internal void WriteNamespaces()
    {
        foreach(string fullNamespace in context.NamespacesInModel)
        {
            this.WriteNamespace(fullNamespace);
        }
    }

    internal string GetFileNameForMultipleFilesGeneration(IEdmSchemaElement schemaElement)
    {
        IEdmSchemaElement[] schemaElementsInModel = this.context.NamespacesInModel.SelectMany(n => this.context.GetSchemaElements(n)).ToArray();
        string fileExtension = this.context.TargetLanguage == LanguageOption.VB ? ".vb" : ".cs";
        if (schemaElementsInModel.Count(e => e.Name.Equals(schemaElement.Name)) > 1)
        {
            return $"{schemaElement.FullName()}{fileExtension}";
        }

        return $"{schemaElement.Name}{fileExtension}";
    }

    internal void WriteNamespace(string fullNamespace)
    {
        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));

        IEdmSchemaElement[] schemaElementsInModel = this.context.NamespacesInModel.SelectMany(n => this.context.GetSchemaElements(n)).ToArray();
        IEdmSchemaElement[] schemaElements = this.context.GetSchemaElements(fullNamespace).ToArray();
        if (schemaElements.OfType<IEdmEntityContainer>().Any()) {
            IEdmEntityContainer container = schemaElements.OfType<IEdmEntityContainer>().Single();
            this.WriteEntityContainer(container, fullNamespace);
        }

        Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap = new Dictionary<IEdmStructuredType, List<IEdmOperation>>();
        foreach (IEdmOperation operation in schemaElements.OfType<IEdmOperation>())
        {
            if (operation.IsBound)
            {
                IEdmType edmType = operation.Parameters.First().Type.Definition;
                IEdmStructuredType edmStructuredType = edmType as IEdmStructuredType;
                if (edmStructuredType != null)
                {
                    List<IEdmOperation> operationList;
                    if (!boundOperationsMap.TryGetValue(edmStructuredType, out operationList))
                    {
                        operationList = new List<IEdmOperation>();
                    }

                    operationList.Add(operation);
                    boundOperationsMap[edmStructuredType] = operationList;
                }
            }
        }

        Dictionary<IEdmStructuredType, List<IEdmStructuredType>> structuredBaseTypeMap = new Dictionary<IEdmStructuredType, List<IEdmStructuredType>>();
        foreach(IEdmSchemaType type in schemaElements.OfType<IEdmSchemaType>())
        {
            if (type is IEdmEnumType enumType)
            {
                if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(enumType.FullName()))
                {
                    continue;
                }

                if(context.GenerateMultipleFiles)
                {
                    string fileName = GetFileNameForMultipleFilesGeneration(enumType);
                    context.MultipleFilesManager.StartNewFile(fileName, false);
                    this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                }

                this.WriteEnumType(enumType);

                if(context.GenerateMultipleFiles)
                {
                    this.WriteNamespaceEnd();
                    context.MultipleFilesManager.EndBlock();
                }
            }
            else
            {
                if (type is IEdmComplexType complexType)
                {
                    if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(complexType.FullName()))
                    {
                        continue;
                    }

                    if(context.GenerateMultipleFiles)
                    {
                        string fileName = GetFileNameForMultipleFilesGeneration(complexType);
                        context.MultipleFilesManager.StartNewFile(fileName, false);
                        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                    }

                    this.WriteComplexType(complexType, boundOperationsMap);

                    if(context.GenerateMultipleFiles)
                    {
                        this.WriteNamespaceEnd();
                        context.MultipleFilesManager.EndBlock();
                    }
                }
                else if (type is IEdmEntityType entityType)
                {
                    if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entityType.FullName()))
                    {
                        continue;
                    }

                    if(context.GenerateMultipleFiles)
                    {
                        string fileName = GetFileNameForMultipleFilesGeneration(entityType);
                        context.MultipleFilesManager.StartNewFile(fileName, false);
                        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
                    }

                    this.WriteEntityType(entityType, boundOperationsMap);

                    if(context.GenerateMultipleFiles)
                    {
                        this.WriteNamespaceEnd();
                        context.MultipleFilesManager.EndBlock();
                    }
                }

                IEdmStructuredType structuredType = type as IEdmStructuredType;
                if (structuredType?.BaseType != null)
                {
                    List<IEdmStructuredType> derivedTypes;
                    if (!structuredBaseTypeMap.TryGetValue(structuredType.BaseType, out derivedTypes))
                    {
                       structuredBaseTypeMap[structuredType.BaseType] = new List<IEdmStructuredType>();
                    }

                    structuredBaseTypeMap[structuredType.BaseType].Add(structuredType);
                }
            }
        }

        if (schemaElements.OfType<IEdmEntityType>().Any() ||
            schemaElements.OfType<IEdmOperation>().Any(o => o.IsBound))
        {
            if(context.GenerateMultipleFiles)
            {
                string ns = this.context.NamespacesInModel.Length > 1 ? $"{fullNamespace}." : string.Empty;
                string fileExtension = this.context.TargetLanguage == LanguageOption.VB ? ".vb" : ".cs";
                context.MultipleFilesManager.StartNewFile($"{ns}ExtensionMethods{fileExtension}", false);
                this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));
            }

            this.WriteExtensionMethodsStart();

            foreach (IEdmEntityType type in schemaElements.OfType<IEdmEntityType>())
            {

                if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(type.FullName()))
                {
                    continue;
                }

                string entityTypeName = type.Name;
                entityTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
                string entityTypeFullName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName), this);
                string returnTypeName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName + this.SingleSuffix), this);

                var keyProperties = type.Key();
                if(keyProperties != null && keyProperties.Any())
                {
                    List<string> keyParameters = new List<string>();
                    List<string> keyDictionaryItems = new List<string>();
                    List<string> keyNames = new List<string>();
                    foreach (IEdmProperty key in keyProperties)
                    {
                        string typeName = Utils.GetClrTypeName(key.Type, this.context.UseDataServiceCollection, this, this.context);
                        string keyName = Utils.CamelCase(key.Name);
                        keyNames.Add(keyName);
                        keyParameters.Add(string.Format(CultureInfo.InvariantCulture, this.ParameterDeclarationTemplate, typeName, this.GetFixedName(keyName)));
                        keyDictionaryItems.Add(string.Format(CultureInfo.InvariantCulture, this.DictionaryItemConstructor, "\"" + key.Name + "\"", this.GetFixedName(keyName)));
                    }

                    string keyParametersString = string.Join(this.KeyParameterSeparator, keyParameters);
                    string keyDictionaryItemsString = string.Join(this.KeyDictionaryItemSeparator, keyDictionaryItems);
                    this.WriteByKeyMethods(entityTypeFullName, returnTypeName, keyNames, keyParametersString, keyDictionaryItemsString);
                }

                IEdmEntityType current = (IEdmEntityType)type.BaseType;
                while (current != null)
                {
                    string baseTypeName = current.Name;
                    baseTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(baseTypeName) : baseTypeName;
                    baseTypeName = context.GetPrefixedFullName(current, GetFixedName(baseTypeName), this);
                    this.WriteCastToMethods(baseTypeName, entityTypeName, entityTypeFullName, returnTypeName);
                    current = (IEdmEntityType)current.BaseType;
                }
            }

            HashSet<string> boundOperations = new HashSet<string>(StringComparer.Ordinal);
            foreach (IEdmFunction function in schemaElements.OfType<IEdmFunction>())
            {
                if (function.IsBound)
                {
                    IEdmTypeReference edmTypeReference = function.Parameters.First().Type;

                    if (this.context.ExcludedBoundOperations?.Contains($"{function.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                    {
                        continue;
                    }

                    if(this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(edmTypeReference.FullName()))
                    {
                        continue;
                    }

                    string functionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(function.Name) : function.Name;
                    string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                    bool useEntityReference;
                    this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                    string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                    string fixedFunctionName = GetFixedName(functionName);
                    string func = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedFunctionName, sourceTypeName, parameterTypes );

                    if (!boundOperations.Contains(func))
                    {
                        boundOperations.Add(func);

                        if (function.ReturnType.IsCollection())
                        {
                            this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value);
                        }
                        else
                        {
                            this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value);
                        }
                    }

                    IEdmStructuredType structuredType;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        structuredType = (IEdmStructuredType)collectionType.ElementType.Definition;
                    }
                    else
                    {
                        structuredType = (IEdmStructuredType)edmTypeReference.Definition;
                    }

                    List<IEdmStructuredType> derivedTypes;
                        if (structuredBaseTypeMap.TryGetValue(structuredType, out derivedTypes))
                    {
                        foreach (IEdmStructuredType type in derivedTypes)
                        {
                            IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                            List<IEdmTypeReference> currentParameters = function.Parameters.Select(p => p.Type).ToList();
                            currentParameters[0] = derivedTypeReference;

                            sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                            string currentFunc = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedFunctionName, sourceTypeName, parameterTypes );
                            if (!boundOperations.Contains(currentFunc))
                            {
                                boundOperations.Add(currentFunc);

                                if (function.ReturnType.IsCollection())
                                {
                                    this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value);
                                }
                                else
                                {
                                    this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value);
                                }
                            }
                        }
                    }
                }
            }

            foreach (IEdmAction action in schemaElements.OfType<IEdmAction>())
            {
                if (action.IsBound)
                {
                    IEdmTypeReference edmTypeReference = action.Parameters.First().Type;

                    if (this.context.ExcludedBoundOperations?.Contains($"{action.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                    {
                        continue;
                    }

                    if(this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(edmTypeReference.FullName()))
                    {
                        continue;
                    }

                    string actionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(action.Name) : action.Name;
                    string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                    bool useEntityReference;
                    this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName;
                    if (action.ReturnType != null)
                    {
                        returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                        if (action.ReturnType.IsCollection())
                        {
                            returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
                        }
                        else
                        {
                            returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                        }
                    }
                    else
                    {
                        returnTypeName = this.DataServiceActionQueryTypeName;
                    }

                    string fixedActionName = GetFixedName(actionName);
                    string ac = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedActionName, sourceTypeName, parameterTypes );
                    if (!boundOperations.Contains(ac))
                    {
                        boundOperations.Add(ac);
                        this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value);
                    }

                    IEdmStructuredType structuredType;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        structuredType = (IEdmStructuredType)collectionType.ElementType.Definition;
                    }
                    else
                    {
                        structuredType = (IEdmStructuredType)edmTypeReference.Definition;
                    }

                    List<IEdmStructuredType> derivedTypes;
                    if (structuredBaseTypeMap.TryGetValue(structuredType, out derivedTypes))
                    {
                        foreach (IEdmStructuredType type in derivedTypes)
                        {
                            IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                            List<IEdmTypeReference> currentParameters = action.Parameters.Select(p => p.Type).ToList();
                            currentParameters[0] = derivedTypeReference;

                            sourceTypeName = string.Format(CultureInfo.InvariantCulture, edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                            string currentAc = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2})", fixedActionName, sourceTypeName, parameterTypes );
                            if (!boundOperations.Contains(currentAc))
                            {
                                boundOperations.Add(currentAc);
                                this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value);
                            }
                        }
                    }
                }
            }

            this.WriteExtensionMethodsEnd();
            if(context.GenerateMultipleFiles)
            {
                this.WriteNamespaceEnd();
                context.MultipleFilesManager.EndBlock();
            }
        }

        this.WriteNamespaceEnd();
    }

    internal bool HasBoundOperations(IEnumerable<IEdmOperation> operations)
    {
        foreach (IEdmOperation opeartion in operations)
        {
            if (opeartion.IsBound)
            {
                return true;
            }
        }

        return false;
    }

    internal void WriteEntityContainer(IEdmEntityContainer container, string fullNamespace)
    {
        string camelCaseContainerName = container.Name;
        string path = this.context.MetadataFilePath;
        bool useTempFile = !String.IsNullOrEmpty(path);
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }

        this.WriteClassStartForEntityContainer(container.Name, camelCaseContainerName, GetFixedName(camelCaseContainerName), GetDescriptionAnnotation(container)?.Value);
        this.WriteEntityContainerConstructor(container);

        if (this.context.NeedResolveNameFromType)
        {
            this.WritePropertyRootNamespace(GetFixedName(camelCaseContainerName), this.context.GetPrefixedNamespace(fullNamespace, this, false, false));
        }

        this.WriteResolveTypeFromName();
        this.WriteResolveNameFromType(camelCaseContainerName, fullNamespace);

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entitySetElementType.FullName()))
            {
                continue;
            }

            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            IDictionary<string, string> revisionAnnotations = new Dictionary<string, string>();

            this.WriteContextEntitySetProperty(camelCaseEntitySetName, GetFixedName(camelCaseEntitySetName), entitySet.Name, GetFixedName(entitySetElementTypeName), GetDescriptionAnnotation(entitySet)?.Value, GetRevisionAnnotations(entitySet));
            List<IEdmNavigationSource> edmNavigationSourceList = null;
            if (!this.context.ElementTypeToNavigationSourceMap.TryGetValue(entitySet.EntityType(), out edmNavigationSourceList))
            {
                edmNavigationSourceList = new List<IEdmNavigationSource>();
                this.context.ElementTypeToNavigationSourceMap.Add(entitySet.EntityType(), edmNavigationSourceList);
            }

            edmNavigationSourceList.Add(entitySet);
        }

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(entitySetElementType.FullName()))
            {
                continue;
            }

            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(/*IsLanguageCaseSensitive*/true);
            string parameterName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(entitySetElementType.Name));

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            this.WriteContextAddToEntitySetMethod(camelCaseEntitySetName, entitySet.Name, GetFixedName(entitySetElementTypeName), parameterName);
        }

        foreach (IEdmSingleton singleton in container.Singletons())
        {
            IEdmEntityType singletonElementType = singleton.EntityType();

            if (this.context.ExcludedSchemaTypes != null && this.context.ExcludedSchemaTypes.Contains(singletonElementType.FullName()))
            {
                continue;
            }

            string singletonElementTypeName = GetElementTypeName(singletonElementType, container);
            string camelCaseSingletonName = singleton.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseSingletonName = Customization.CustomizeNaming(camelCaseSingletonName);
            }

            this.WriteContextSingletonProperty(camelCaseSingletonName, GetFixedName(camelCaseSingletonName), singleton.Name, singletonElementTypeName + "Single", GetDescriptionAnnotation(singleton)?.Value, GetRevisionAnnotations(singleton));

            List<IEdmNavigationSource> edmNavigationSourceList = null;
            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(singleton.EntityType(), out edmNavigationSourceList))
            {
                edmNavigationSourceList.Add(singleton);
            }
        }

        string edmx = Utils.SerializeToString(this.context.Edmx);
        if (useTempFile)
        {
            this.WriteGeneratedEdmModel(edmx);
        }
        else // constructing Edmx string
        {
            edmx = edmx.Replace("\"", "\"\"");
            if (this.context.TargetLanguage == LanguageOption.VB)
            {
                this.WriteGeneratedEdmModel(edmx.Replace("\r\n", "\" & _\r\n \""));
            }
            else
            {
                this.WriteGeneratedEdmModel(edmx);
            }
        }

        bool hasOperationImport = container.OperationImports().OfType<IEdmOperationImport>().Any();
        foreach (IEdmFunctionImport functionImport in container.OperationImports().OfType<IEdmFunctionImport>())
        {
            if (this.context.ExcludedOperationImports?.Contains(functionImport.Name) == true)
            {
                continue;
            }

            string parameterString, parameterTypes, parameterExpressionString, parameterValues;
            bool useEntityReference;
            this.GetParameterStrings(false, false, functionImport.Function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
            string returnTypeName = GetSourceOrReturnTypeName(functionImport.Function.ReturnType);
            string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(functionImport.Function.ReturnType, true);
            string fixedContainerName = this.GetFixedName(functionImport.Container.Name);
            bool isCollectionResult = functionImport.Function.ReturnType.IsCollection();
            string functionImportName = functionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                functionImportName = Customization.CustomizeNaming(functionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            if (functionImport.Function.ReturnType.IsCollection())
            {
                this.WriteFunctionImportReturnCollectionResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, parameterString, parameterValues, functionImport.Function.IsComposable, useEntityReference, GetDescriptionAnnotation(functionImport)?.Value, GetRevisionAnnotations(functionImport));
            }
            else
            {
                this.WriteFunctionImportReturnSingleResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, parameterValues, functionImport.Function.IsComposable, functionImport.Function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(functionImport)?.Value, GetRevisionAnnotations(functionImport));
            }
        }

        foreach (IEdmActionImport actionImport in container.OperationImports().OfType<IEdmActionImport>())
        {
            if (this.context.ExcludedOperationImports?.Contains(actionImport.Name) == true)
            {
                continue;
            }

            string parameterString, parameterTypes, parameterExpressionString, parameterValues;
            bool useEntityReference;
            this.GetParameterStrings(false, true, actionImport.Action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
            string returnTypeName = null;
            string fixedContainerName = this.GetFixedName(actionImport.Container.Name);

            if (actionImport.Action.ReturnType != null)
            {
                returnTypeName = GetSourceOrReturnTypeName(actionImport.Action.ReturnType);
                if (actionImport.Action.ReturnType.IsCollection())
                {
                    returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
            }
                else
                {
                    returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                }
            }
            else
            {
                returnTypeName = this.DataServiceActionQueryTypeName;
            }

            string actionImportName = actionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                actionImportName = Customization.CustomizeNaming(actionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            this.WriteActionImport(this.GetFixedName(actionImportName), actionImport.Name, returnTypeName, parameterString, parameterValues, GetDescriptionAnnotation(actionImport)?.Value, GetRevisionAnnotations(actionImport));
        }

        this.WriteClassEndForEntityContainer();
    }

    internal void WriteEntityContainerConstructor(IEdmEntityContainer container)
    {
        string camelCaseContainerName = container.Name;
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }

        this.WriteMethodStartForEntityContainerConstructor(camelCaseContainerName, GetFixedName(camelCaseContainerName));

        if (this.context.UseKeyAsSegmentUrlConvention(container))
        {
            this.WriteKeyAsSegmentUrlConvention();
        }

        if (this.context.NeedResolveNameFromType)
        {
            this.WriteInitializeResolveName();
        }

        if (this.context.NeedResolveTypeFromName)
        {
            this.WriteInitializeResolveType();
        }

        this.WriteClassEndForEntityContainerConstructor();
    }

    internal void WriteResolveTypeFromName()
    {
        if (!this.context.NeedResolveTypeFromName)
        {
            return;
        }

        this.WriteMethodStartForResolveTypeFromName();

        // NOTE: since multiple namespaces can have the same prefix and match the namespace
        // prefix condition, it's important that the prefix check is done is prefix-length
        // order, starting with the longest prefix.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Key.Length).ThenBy(p => p.Key);

        string typeName = this.SystemTypeTypeName + " ";
        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveNamespace(typeName, namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
            typeName = string.Empty;
        }

        this.WriteMethodEndForResolveTypeFromName();
    }

    internal void WriteResolveNameFromType(string containerName, string fullNamespace)
    {
        if (!this.context.NeedResolveNameFromType)
        {
            return;
        }

        this.WriteMethodStartForResolveNameFromType(GetFixedName(containerName), fullNamespace);

        // NOTE: in this case order also matters, but the length of the CLR
        // namespace is what needs to be considered.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Value.Length).ThenBy(p => p.Key);

        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveType(namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
        }

        this.WriteMethodEndForResolveNameFromType(this.context.ModelHasInheritance);
    }

    internal void WritePropertiesForSingleType(IEnumerable<IEdmProperty> properties)
    {
        foreach (IEdmProperty property in properties.Where(i => i.PropertyKind == EdmPropertyKind.Navigation))
        {
            string propertyType;
            string propertyName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name;
            if (property.Type is Microsoft.OData.Edm.EdmCollectionTypeReference)
            {
                propertyType = GetSourceOrReturnTypeName(property.Type);
                WriteContextEntitySetProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, GetDescriptionAnnotation(property)?.Value, GetRevisionAnnotations(property), false);
            }
            else
            {
                propertyType = Utils.GetClrTypeName(property.Type, true, this, this.context, true, isEntitySingleType : true);
                WriteContextSingletonProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, GetDescriptionAnnotation(property)?.Value, GetRevisionAnnotations(property), false);
            }
        }
    }

    internal void WriteEntityType(IEdmEntityType entityType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        string entityTypeName = ((IEdmSchemaElement)entityType).Name;
        entityTypeName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
        this.WriteSummaryCommentForStructuredType(entityTypeName + this.SingleSuffix, GetDescriptionAnnotation(entityType)?.Value);
        this.WriteObsoleteAttribute(GetRevisionAnnotations(entityType), /* isClass */ true);
        this.WriteStructurdTypeDeclaration(entityType,
            this.ClassInheritMarker + string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)),
            this.SingleSuffix);
        string singleTypeName = (this.context.EnableNamingAlias ?
                        Customization.CustomizeNaming(((IEdmSchemaElement)entityType).Name) : ((IEdmSchemaElement)entityType).Name) + this.SingleSuffix;
        this.WriteConstructorForSingleType(GetFixedName(singleTypeName), string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)));
        IEdmEntityType current = entityType;
        while (current != null)
        {
            this.WritePropertiesForSingleType(current.DeclaredProperties);
            current = (IEdmEntityType)current.BaseType;
        }

        this.WriteClassEndForStructuredType();

        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityType.Name) : entityType.Name, GetDescriptionAnnotation(entityType)?.Value);

        if (entityType.Key().Any())
        {
            IEnumerable<string> keyProperties = entityType.Key().Select(k => k.Name);
            this.WriteKeyPropertiesCommentAndAttribute(
                this.context.EnableNamingAlias ? keyProperties.Select(k => Customization.CustomizeNaming(k)) : keyProperties,
                string.Join("\", \"", keyProperties));
        }
        else
        {
            this.WriteEntityTypeAttribute();
        }

        if (this.context.UseDataServiceCollection)
        {
            List<IEdmNavigationSource> navigationSourceList;
            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(entityType, out navigationSourceList))
            {
                if(navigationSourceList.Count == 1)
                {
                    this.WriteEntitySetAttribute(navigationSourceList[0].Name);
                }
            }
        }

        if (entityType.HasStream)
        {
            this.WriteEntityHasStreamAttribute();
        }

        this.WriteObsoleteAttribute(GetRevisionAnnotations(entityType), /* isClass */ true);
        this.WriteStructurdTypeDeclaration(entityType, this.BaseEntityType);
        this.SetPropertyIdentifierMappingsIfNameConflicts(entityType.Name, entityType);
        this.WriteTypeStaticCreateMethod(entityType.Name, entityType);
        this.WritePropertiesForStructuredType(entityType);

        if (entityType.BaseType == null && this.context.UseDataServiceCollection)
        {
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteBoundOperations(entityType, boundOperationsMap);

        this.WriteClassEndForStructuredType();
    }

    internal void WriteComplexType(IEdmComplexType complexType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(complexType.Name) : complexType.Name, GetDescriptionAnnotation(complexType)?.Value);
        this.WriteStructurdTypeDeclaration(complexType, string.Empty);
        this.SetPropertyIdentifierMappingsIfNameConflicts(complexType.Name, complexType);
        this.WriteTypeStaticCreateMethod(complexType.Name, complexType);
        this.WritePropertiesForStructuredType(complexType);

        if (complexType.BaseType == null && this.context.UseDataServiceCollection)
        {
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteClassEndForStructuredType();
    }

    internal void WriteBoundOperations(IEdmStructuredType structuredType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        List<IEdmOperation> operations;
        if (boundOperationsMap.TryGetValue(structuredType, out operations))
        {
            foreach (IEdmFunction function in operations.OfType<IEdmFunction>())
            {
                IEdmTypeReference edmTypeReference = function.Parameters.First().Type;

                if (this.context.ExcludedBoundOperations?.Contains($"{function.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                {
                    continue;
                }

                string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                bool useEntityReference;
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, function, boundOperationsMap);
                this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                string functionName = function.Name;
                if (this.context.EnableNamingAlias)
                {
                    functionName = Customization.CustomizeNaming(functionName);
                }

                if (function.ReturnType.IsCollection())
                {
                    this.WriteBoundFunctionInEntityTypeReturnCollectionResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference, GetDescriptionAnnotation(function)?.Value, GetRevisionAnnotations(function));
                }
                else
                {
                    this.WriteBoundFunctionInEntityTypeReturnSingleResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference, GetDescriptionAnnotation(function)?.Value, GetRevisionAnnotations(function));
                }
            }

            foreach (IEdmAction action in operations.OfType<IEdmAction>())
            {
                IEdmTypeReference edmTypeReference = action.Parameters.First().Type;

                if (this.context.ExcludedBoundOperations?.Contains($"{action.Name}({edmTypeReference.Definition.FullTypeName()})") == true)
                {
                    continue;
                }

                string parameterString, parameterExpressionString, parameterTypes, parameterValues;
                bool useEntityReference;
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, action, boundOperationsMap);
                this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out parameterString, out parameterTypes, out parameterExpressionString, out parameterValues, out useEntityReference);
                string returnTypeName;
                if (action.ReturnType != null)
                {
                    returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                    if (action.ReturnType.IsCollection())
                    {
                        returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQueryOfTStructureTemplate, returnTypeName);
                    }
                    else
                    {
                        returnTypeName = string.Format(CultureInfo.InvariantCulture, this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                    }
                }
                else
                {
                    returnTypeName = this.DataServiceActionQueryTypeName;
                }

                string actionName = action.Name;
                if (this.context.EnableNamingAlias)
                {
                    actionName = Customization.CustomizeNaming(actionName);
                }

                this.WriteBoundActionInEntityType(hideBaseMethod, GetFixedName(actionName), action.Name, returnTypeName, parameterString, action.Namespace, parameterValues, GetDescriptionAnnotation(action)?.Value, GetRevisionAnnotations(action));
            }
        }
    }

    internal bool CheckMethodsInBaseClass(IEdmStructuredType structuredType, IEdmOperation operation, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        if (structuredType != null)
        {
            List<IEdmOperation> operations;
            if (boundOperationsMap.TryGetValue(structuredType, out operations))
            {
                foreach (IEdmOperation op in operations)
                {
                    if (this.context.TargetLanguage == LanguageOption.VB)
                    {
                        if (operation.Name == op.Name)
                        {
                            return true;
                        }
                    }

                    List<IEdmOperationParameter> targetParameter = operation.Parameters.ToList();
                    List<IEdmOperationParameter> checkParameter = op.Parameters.ToList();
                    if (operation.Name == op.Name && targetParameter.Count == checkParameter.Count)
                    {
                        bool areSame = true;
                        for (int i = 1; i < targetParameter.Count; ++i)
                        {
                            var targetParameterType = targetParameter[i].Type;
                            var checkParameterType = checkParameter[i].Type;
                            if (!targetParameterType.Definition.Equals(checkParameterType.Definition)
                                || targetParameterType.IsNullable != checkParameterType.IsNullable)
                            {
                                areSame = false;
                                break;
                            }
                        }

                        if (areSame)
                        {
                            return true;
                        }
                    }
                }
            }

            return CheckMethodsInBaseClass(structuredType.BaseType, operation, boundOperationsMap);
        }

        return false;
    }

    internal void WriteEnumType(IEdmEnumType enumType)
    {
        this.WriteSummaryCommentForEnumType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(enumType.Name) : enumType.Name, GetDescriptionAnnotation(enumType)?.Value);
        if (enumType.IsFlags)
        {
            this.WriteEnumFlags();
        }

        string underlyingType = string.Empty;
        if (enumType.UnderlyingType != null && enumType.UnderlyingType.PrimitiveKind != EdmPrimitiveTypeKind.Int32)
        {
            underlyingType = Utils.GetClrTypeName(enumType.UnderlyingType, this);
            underlyingType = this.EnumUnderlyingTypeMarker + underlyingType;
        }

        this.WriteEnumDeclaration(this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(enumType.Name)) : GetFixedName(enumType.Name), enumType.Name, underlyingType);
        this.WriteMembersForEnumType(enumType.Members);
        this.WriteEnumEnd();
    }

    internal void WriteStructurdTypeDeclaration(IEdmStructuredType structuredType, string baseEntityType, string typeNameSuffix = null)
    {
        string abstractModifier = structuredType.IsAbstract && typeNameSuffix == null ? this.AbstractModifier : string.Empty;
        string baseTypeName = baseEntityType;

        if (typeNameSuffix == null)
        {
            if (structuredType.BaseType == null)
            {
                if (this.context.UseDataServiceCollection)
                {
                    if (this.context.TargetLanguage == LanguageOption.CSharp)
                    {
                        baseTypeName += string.IsNullOrEmpty(baseTypeName) ? this.ClassInheritMarker : ", ";
                    }

                    baseTypeName += this.NotifyPropertyChangedModifier;
                }
            }
            else
            {
                IEdmSchemaElement baseType = (IEdmSchemaElement)structuredType.BaseType;
                string baseTypeFixedName = this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(baseType.Name)) : GetFixedName(baseType.Name);
                baseTypeName = ((IEdmSchemaElement)structuredType).Namespace == baseType.Namespace ? baseTypeFixedName : this.context.GetPrefixedFullName(baseType, baseTypeFixedName, this);
                baseTypeName = this.ClassInheritMarker + baseTypeName;
            }
        }

        string structuredTypeName = this.context.EnableNamingAlias ?
            Customization.CustomizeNaming(((IEdmSchemaElement)structuredType).Name) : ((IEdmSchemaElement)structuredType).Name;
        this.WriteClassStartForStructuredType(abstractModifier, GetFixedName(structuredTypeName + typeNameSuffix), ((IEdmSchemaElement)structuredType).Name + typeNameSuffix, baseTypeName);
    }

    internal string GetSourceOrReturnTypeName(IEdmTypeReference typeReference, bool isEntitySingleType = false)
    {
        IEdmCollectionType edmCollectionType = typeReference.Definition as IEdmCollectionType;
        bool addNullableTemplate = true;
        if (edmCollectionType != null)
        {
            typeReference = edmCollectionType.ElementType;
            addNullableTemplate = false;
        }

        return Utils.GetClrTypeName(typeReference, this.context.UseDataServiceCollection, this, this.context, addNullableTemplate, isEntitySingleType:isEntitySingleType);
    }

    internal void GetParameterStrings(bool isBound, bool isAction, IEdmOperationParameter[] parameters, out string parameterString, out string parameterTypes, out string parameterExpressionString, out string parameterValues,  out bool useEntityReference)
    {
        parameterString = string.Empty;
        parameterExpressionString = string.Empty;
        parameterTypes = string.Empty;
        parameterValues = string.Empty;
        useEntityReference = false;

        int n = parameters.Count();
        for (int i = isBound ? 1 : 0; i < n; ++i)
        {
            IEdmOperationParameter param = parameters[i];
            if (i == (isBound ? 1 : 0))
            {
                if (this.context.TargetLanguage == LanguageOption.CSharp)
                {
                    parameterExpressionString += "\r\n                        ";
                }
                else
                {
                    parameterExpressionString += "\r\n                            ";
                }
            }

            string typeName = Utils.GetClrTypeName(param.Type, this.context.UseDataServiceCollection, this, this.context, true, true, true);
            if (this.context.TargetLanguage == LanguageOption.CSharp)
            {
                parameterString += typeName;
                parameterString += (" " + GetFixedName(param.Name));
            }
            else if (this.context.TargetLanguage == LanguageOption.VB)
            {
                parameterString += GetFixedName(param.Name);
                parameterString += (this.EnumUnderlyingTypeMarker + typeName);
            }

            parameterString += i == n - 1 ? string.Empty : ", ";
            parameterTypes += string.Format(CultureInfo.InvariantCulture, this.TypeofFormatter, typeName) + ", ";
            parameterExpressionString += this.GetParameterExpressionString(param, typeName) + ", ";

            if (i != (isBound ? 1 : 0))
            {
                parameterValues += ",\r\n                    ";
            }

            if (isAction)
            {
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.BodyOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
            else  if (param.Type.IsEntity() || (param.Type.IsCollection() && param.Type.AsCollection().ElementType().IsEntity()))
            {
                useEntityReference = true;
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.UriEntityOperationParameterConstructor, param.Name, GetFixedName(param.Name),"useEntityReference");
            }
            else
            {
                parameterValues += string.Format(CultureInfo.InvariantCulture, this.UriOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
        }
    }

    internal string GetParameterExpressionString(IEdmOperationParameter param, string typeName)
    {
        string clrTypeName;
        IEdmType edmType = param.Type.Definition;
        IEdmPrimitiveType edmPrimitiveType = edmType as IEdmPrimitiveType;
        if (edmPrimitiveType != null)
        {
            clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, this);
            if (param.Type.IsNullable && !this.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind))
            {
                clrTypeName += "?";
            }

            return string.Format(CultureInfo.InvariantCulture, this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), clrTypeName);
        }

        return string.Format(CultureInfo.InvariantCulture, this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), typeName);
    }

    // This is to solve duplicate names between property and type
    internal void SetPropertyIdentifierMappingsIfNameConflicts(string typeName, IEdmStructuredType structuredType)
    {
        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        // PropertyName in VB is case-insensitive.
        bool isLanguageCaseSensitive = this.context.TargetLanguage == LanguageOption.CSharp;

        // In VB, it is allowed that a type has a property whose name is same with the type's name
        bool allowPropertyNameSameWithTypeName = this.context.TargetLanguage == LanguageOption.VB;

        Func<string, string> customizePropertyName = (name) => { return this.context.EnableNamingAlias ? Customization.CustomizeNaming(name) : name; };

        var propertyGroups = structuredType.Properties()
            .GroupBy(p => isLanguageCaseSensitive ? customizePropertyName(p.Name) : customizePropertyName(p.Name).ToUpperInvariant());

        // If the group contains more than one property, or the property in the group has the same name with the type (only for C#), we need to rename the property
        var propertyToBeRenamedGroups = propertyGroups.Where(g => g.Count() > 1 || !allowPropertyNameSameWithTypeName && g.Key == typeName);

        var knownIdentifiers = propertyGroups.Select(g => customizePropertyName(g.First().Name)).ToList();
        if(!allowPropertyNameSameWithTypeName && !knownIdentifiers.Contains(typeName))
        {
            knownIdentifiers.Add(typeName);
        }
        UniqueIdentifierService uniqueIdentifierService =
            new UniqueIdentifierService(knownIdentifiers, isLanguageCaseSensitive);

        IdentifierMappings.Clear();
        foreach (IGrouping<string, IEdmProperty> g in propertyToBeRenamedGroups)
        {
            bool hasPropertyNameSameWithCustomizedPropertyName = false;
            int itemCount = g.Count();
            for (int i = 0; i < itemCount; i++)
            {
                var property = g.ElementAt(i);
                var customizedPropertyName = customizePropertyName(property.Name);

                if(this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                {
                    hasPropertyNameSameWithCustomizedPropertyName = true;
                }

                if(isLanguageCaseSensitive)
                {
                    // If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group
                    if(customizedPropertyName != typeName
                        && (customizedPropertyName == property.Name
                            || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1)))
                    {
                        continue;
                    }
                }
                else
                {
                    // When EnableNamingAlias = true, If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group.
                    if((this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                        || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1))
                    {
                        continue;
                    }
                }
                var renamedPropertyName = uniqueIdentifierService.GetUniqueIdentifier(customizedPropertyName);
                    IdentifierMappings.Add(property.Name, renamedPropertyName);
            }
        }
    }

    internal void WriteTypeStaticCreateMethod(string typeName, IEdmStructuredType structuredType)
    {
        Debug.Assert(structuredType != null, "structuredType != null");
        if (structuredType.IsAbstract)
        {
            return;
        }

        Func<IEdmProperty, bool> hasDefault = p => p.PropertyKind == EdmPropertyKind.Structural && ((IEdmStructuralProperty)p).DefaultValueString != null;

        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        IEnumerable<IEdmProperty> parameters = structuredType.Properties()
            .Where(p => !p.Type.IsNullable && !p.Type.IsCollection() && !hasDefault(p));
        if (!parameters.Any())
        {
            return;
        }

        this.WriteSummaryCommentForStaticCreateMethod(typeName);

        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService( /*IsLanguageCaseSensitive*/true);
        string instanceName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(typeName));
        KeyValuePair<IEdmProperty, string>[] propertyToParameterNamePairs = parameters
            .Select(p =>
                new KeyValuePair<IEdmProperty, string>(p,
                    uniqueIdentifierService.GetUniqueParameterName(
                        IdentifierMappings.ContainsKey(p.Name) ? IdentifierMappings[p.Name] : p.Name)))
            .ToArray();

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            string propertyName = propertyToParameterNamePair.Key.Name;
            propertyName = IdentifierMappings.ContainsKey(propertyName) ?
                IdentifierMappings[propertyName] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(propertyName) : propertyName);
            this.WriteParameterCommentForStaticCreateMethod(propertyToParameterNamePair.Value, propertyName);
        }

        propertyToParameterNamePairs = propertyToParameterNamePairs
            .Select(p => p = new KeyValuePair<IEdmProperty, string>(p.Key, GetFixedName(p.Value)))
            .ToArray();

        this.WriteDeclarationStartForStaticCreateMethod(typeName, GetFixedName(typeName));
        this.WriteStaticCreateMethodParameters(propertyToParameterNamePairs);
        this.WriteDeclarationEndForStaticCreateMethod(GetFixedName(typeName), instanceName);

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            IEdmProperty property = propertyToParameterNamePair.Key;
            string parameterName = propertyToParameterNamePair.Value;

            Debug.Assert(!property.Type.IsCollection(), "!property.Type.IsCollection()");
            Debug.Assert(!property.Type.IsNullable, "!property.Type.IsNullable");

            // The static create method only sets non-nullable properties. We should add the null check if the type of the property is not a clr ValueType.
            // For now we add the null check if the property type is non-primitive. We should add the null check for non-ValueType primitives in the future.
            if (!property.Type.IsPrimitive() && !property.Type.IsEnum())
            {
                this.WriteParameterNullCheckForStaticCreateMethod(parameterName);
            }

            var uniqIdentifier = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);
            this.WritePropertyValueAssignmentForStaticCreateMethod(instanceName,
                GetFixedName(uniqIdentifier),
                parameterName);
        }

        this.WriteMethodEndForStaticCreateMethod(instanceName);
    }

    internal void WriteStaticCreateMethodParameters(KeyValuePair<IEdmProperty, string>[] propertyToParameterPairs)
    {
        if (propertyToParameterPairs.Length == 0)
        {
            return;
        }

        // If the number of parameters are greater than 5, we put them in separate lines.
        string parameterSeparator = propertyToParameterPairs.Length > 5 ? this.ParameterSeparator : ", ";
        for (int idx = 0; idx < propertyToParameterPairs.Length; idx++)
        {
            KeyValuePair<IEdmProperty, string> propertyToParameterPair = propertyToParameterPairs[idx];

            string parameterType = Utils.GetClrTypeName(propertyToParameterPair.Key.Type, this.context.UseDataServiceCollection, this, this.context);
            string parameterName = propertyToParameterPair.Value;
            if (idx == propertyToParameterPairs.Length - 1)
            {
                // No separator after the last parameter.
                parameterSeparator = string.Empty;
            }

            this.WriteParameterForStaticCreateMethod(parameterType, GetFixedName(parameterName), parameterSeparator);
        }
    }

    internal void WritePropertiesForStructuredType(IEdmStructuredType structuredType)
    {
         bool useDataServiceCollection = this.context.UseDataServiceCollection;
         IEnumerable<IEdmProperty> properties = structuredType.DeclaredProperties;

        var propertyInfos = properties.Select(property =>
        {
            string propertyName = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);

            return new
                {
                    PropertyType = Utils.GetClrTypeName(property.Type, useDataServiceCollection, this, this.context),
                    PropertyVanillaName = property.Name,
                    PropertyName = propertyName,
                    FixedPropertyName = GetFixedName(propertyName),
                    PrivatePropertyName = "_" + propertyName,
                    PropertyInitializationValue = Utils.GetPropertyInitializationValue(property, useDataServiceCollection, this, this.context),
                    PropertyAttribute = string.Empty,
                    PropertyDescription = GetDescriptionAnnotation(property)?.Value,
                    PropertyMaxLength = property.Type.AsString()?.MaxLength,
                    IsNullable = property.Type.IsNullable,
                    RevisionAnnotations = GetRevisionAnnotations(property)
                };
        }).ToList();

        // NOTE: If structured type has a base type and that base type is open, then the dynamic properties property is emitted on the client base type
        if (structuredType.IsOpen && (structuredType.BaseType == null || (structuredType.BaseType != null && !structuredType.BaseType.IsOpen)))
        {
            string containerPropertyName = GetContainerPropertyName(structuredType);

            string containerPropertyAttribute = string.Empty;
            if (this.context.EmitContainerPropertyAttribute)
            {
                containerPropertyAttribute = this.ContainerPropertyAttribute;
            }

            // Add empty dictionary to the anonymous type
            IDictionary<string, string> emptyDict = new Dictionary<string, string>();

            propertyInfos.Add(new
            {
                PropertyType = string.Format(this.DictionaryInterfaceName, this.StringTypeName, this.ObjectTypeName),
                PropertyVanillaName = containerPropertyName,
                PropertyName = containerPropertyName,
                FixedPropertyName = containerPropertyName,
                PrivatePropertyName = "_" + containerPropertyName,
                PropertyInitializationValue = string.Format(this.DictionaryConstructor, this.StringTypeName, this.ObjectTypeName),
                PropertyAttribute = containerPropertyAttribute,
                PropertyDescription = string.Empty,
                PropertyMaxLength = (int?)null,
                IsNullable = true,
                RevisionAnnotations = emptyDict
            });
        }

        // Private name should not confict with field name
        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(propertyInfos.Select(_ => _.FixedPropertyName),
            this.context.TargetLanguage == LanguageOption.CSharp);

        foreach (var propertyInfo in propertyInfos)
        {
            string privatePropertyName = uniqueIdentifierService.GetUniqueIdentifier("_" + propertyInfo.PropertyName);

            this.WritePropertyForStructuredType(new PropertyOptions {
                PropertyType = propertyInfo.PropertyType,
                OriginalPropertyName = propertyInfo.PropertyVanillaName,
                PropertyName = propertyInfo.PropertyName,
                FixedPropertyName = propertyInfo.FixedPropertyName,
                PrivatePropertyName = privatePropertyName,
                PropertyInitializationValue = propertyInfo.PropertyInitializationValue,
                PropertyAttribute = propertyInfo.PropertyAttribute,
                PropertyDescription = propertyInfo.PropertyDescription,
                PropertyMaxLength = propertyInfo.PropertyMaxLength,
                WriteOnPropertyChanged = useDataServiceCollection,
                IsNullable = propertyInfo.IsNullable,
                RevisionAnnotations = propertyInfo.RevisionAnnotations
            });
        }
    }

    internal void WriteMembersForEnumType(IEnumerable<IEdmEnumMember> members)
    {
        int n = members.Count();
        for (int idx = 0; idx < n; ++idx)
        {
            IEdmEnumMember member = members.ElementAt(idx);
            string value = string.Empty;
            if (member.Value != null)
            {
                IEdmEnumMemberValue integerValue = member.Value as IEdmEnumMemberValue;
                if (integerValue != null)
                {
                    value = " = " + integerValue.Value.ToString(CultureInfo.InvariantCulture);
                }
            }

            string memberName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(member.Name) : member.Name;
            this.WriteMemberForEnumType(GetFixedName(memberName) + value, member.Name, idx == n - 1);
        }
    }

    internal string GetFixedName(string originalName)
    {
        string fixedName = originalName;

        if (this.LanguageKeywords.Contains(fixedName))
        {
            fixedName = string.Format(CultureInfo.InvariantCulture, this.FixPattern, fixedName);
        }

        return fixedName;
    }

    internal string GetElementTypeName(IEdmEntityType elementType, IEdmEntityContainer container)
    {
        string elementTypeName = elementType.Name;

        if (this.context.EnableNamingAlias)
        {
            elementTypeName = Customization.CustomizeNaming(elementTypeName);
        }

        if (elementType.Namespace != container.Namespace)
        {
            elementTypeName = this.context.GetPrefixedFullName(elementType, GetFixedName(elementTypeName), this);
        }

        return elementTypeName;
    }

    /// <summary>
    /// Returns a non-conflicting name for the container property.
    /// The preferred name for the container property will be suffixed with an integer
    /// in the odd case that there exists a declared property with a similar name
    /// </summary>
    private string GetContainerPropertyName(IEdmStructuredType structuredType)
    {
        int suffix = 2;
        bool conflict = true;
        string containerPropertyTemp = ContainerPropertyBase;

        do
        {
            IEdmStructuredType tempType = structuredType;

            while(tempType != null)
            {
                conflict = tempType.DeclaredProperties.Any(p => p.Name.Equals(containerPropertyTemp, StringComparison.Ordinal));
                if (conflict)
                {
                    break;
                }
                tempType = tempType.BaseType;
            }

            if (conflict)
            {
                containerPropertyTemp = ContainerPropertyBase + suffix.ToString();
                suffix++;
            }
        } while(conflict);

        return containerPropertyTemp;
    }

    /// <summary>
    /// Searches through model's vocabulary annotations and returns annotation of term 'Description' if present
    /// </summary>
    private IEdmStringConstantExpression GetDescriptionAnnotation(IEdmVocabularyAnnotatable model)
    {
        return model.VocabularyAnnotations(this.context.EdmModel).Where(x => x.Term.Name == "Description")
            .Select(x => x.Value).FirstOrDefault() as IEdmStringConstantExpression;
    }

    /// <summary>
    /// Searches through model's vocabulary annotations and returns dictionary of term 'Revisions' annotation kinds.
    /// </summary>
    private IDictionary<string,string> GetRevisionAnnotations(IEdmVocabularyAnnotatable schemaElement)
    {
        IEnumerable<IEdmExpression> collection = schemaElement.VocabularyAnnotations(this.context.EdmModel).Where(x => x.Term.FullName() == "Org.OData.Core.V1.Revisions")
            .Select(x => x.Value);

        IDictionary<string, string> revisionsAnnotation = new Dictionary<string, string>();

        IEdmCollectionExpression semanticElement = collection?.FirstOrDefault() as IEdmCollectionExpression;

        if (semanticElement != null)
        {
            foreach (IEdmRecordExpression element in semanticElement.Elements)
            {
                string description = (element?.Properties.Where(x => x.Name == "Description").Select(x => x.Value).FirstOrDefault() as IEdmStringConstantExpression)?.Value;

                if (string.IsNullOrEmpty(description))
                {
                    throw new Exception("Description property is missing from the Annotation Xml");
                }

                IEdmEnumMemberExpression revisionKind = element?.Properties.Where(x => x.Name == "Kind").Select(x => x.Value).FirstOrDefault() as IEdmEnumMemberExpression;

                if (revisionKind == null)
                {
                    throw new Exception("Kind property is missing from the Annotation Xml");
                }

                string name = revisionKind.EnumMembers.FirstOrDefault().Name;
                revisionsAnnotation.Add(name, description);
            }
        }

        return revisionsAnnotation;

    }
}

/// <summary>
/// Base class for text transformation
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "11.0.0.0")]
public abstract class TemplateBase
{
    #region Fields
    private global::System.Text.StringBuilder generationEnvironmentField;
    private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
    private global::System.Collections.Generic.List<int> indentLengthsField;
    private string currentIndentField = "";
    private bool endsWithNewline;
    private global::System.Collections.Generic.IDictionary<string, object> sessionField;
    #endregion
    #region Properties
    /// <summary>
    /// The string builder that generation-time code is using to assemble generated output
    /// </summary>
    protected System.Text.StringBuilder GenerationEnvironment
    {
        get
        {
            if ((this.generationEnvironmentField == null))
            {
                this.generationEnvironmentField = new global::System.Text.StringBuilder();
            }
            return this.generationEnvironmentField;
        }
        set
        {
            this.generationEnvironmentField = value;
        }
    }
    /// <summary>
    /// The error collection for the generation process
    /// </summary>
    public System.CodeDom.Compiler.CompilerErrorCollection Errors
    {
        get
        {
            if ((this.errorsField == null))
            {
                this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
            }
            return this.errorsField;
        }
    }
    /// <summary>
    /// A list of the lengths of each indent that was added with PushIndent
    /// </summary>
    private System.Collections.Generic.List<int> indentLengths
    {
        get
        {
            if ((this.indentLengthsField == null))
            {
                this.indentLengthsField = new global::System.Collections.Generic.List<int>();
            }
            return this.indentLengthsField;
        }
    }
    /// <summary>
    /// Gets the current indent we use when adding lines to the output
    /// </summary>
    public string CurrentIndent
    {
        get
        {
            return this.currentIndentField;
        }
    }
    /// <summary>
    /// Current transformation session
    /// </summary>
    public virtual global::System.Collections.Generic.IDictionary<string, object> Session
    {
        get
        {
            return this.sessionField;
        }
        set
        {
            this.sessionField = value;
        }
    }
    #endregion

    /// <summary>
    /// Create the template output
    /// </summary>
    public abstract string TransformText();

    #region Transform-time helpers
    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void Write(string textToAppend)
    {
        if (string.IsNullOrEmpty(textToAppend))
        {
            return;
        }
        // If we're starting off, or if the previous text ended with a newline,
        // we have to append the current indent first.
        if (((this.GenerationEnvironment.Length == 0)
                    || this.endsWithNewline))
        {
            this.GenerationEnvironment.Append(this.currentIndentField);
            this.endsWithNewline = false;
        }
        // Check if the current text ends with a newline
        if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
        {
            this.endsWithNewline = true;
        }
        // This is an optimization. If the current indent is "", then we don't have to do any
        // of the more complex stuff further down.
        if ((this.currentIndentField.Length == 0))
        {
            this.GenerationEnvironment.Append(textToAppend);
            return;
        }
        // Everywhere there is a newline in the text, add an indent after it
        textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
        // If the text ends with a newline, then we should strip off the indent added at the very end
        // because the appropriate indent will be added when the next time Write() is called
        if (this.endsWithNewline)
        {
            this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
        }
        else
        {
            this.GenerationEnvironment.Append(textToAppend);
        }
    }
    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void WriteLine(string textToAppend)
    {
        this.Write(textToAppend);
        this.GenerationEnvironment.AppendLine();
        this.endsWithNewline = true;
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void Write(string format, params object[] args)
    {
        this.Write(string.Format(CultureInfo.InvariantCulture, format, args));
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void WriteLine(string format, params object[] args)
    {
        this.WriteLine(string.Format(CultureInfo.InvariantCulture, format, args));
    }
    /// <summary>
    /// Raise an error
    /// </summary>
    public void Error(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Raise a warning
    /// </summary>
    public void Warning(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        error.IsWarning = true;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Increase the indent
    /// </summary>
    public void PushIndent(string indent)
    {
        if ((indent == null))
        {
            throw new global::System.ArgumentNullException("indent");
        }
        this.currentIndentField = (this.currentIndentField + indent);
        this.indentLengths.Add(indent.Length);
    }
    /// <summary>
    /// Remove the last indent that was added with PushIndent
    /// </summary>
    public string PopIndent()
    {
        string returnValue = "";
        if ((this.indentLengths.Count > 0))
        {
            int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
            this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
            if ((indentLength > 0))
            {
                returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
            }
        }
        return returnValue;
    }
    /// <summary>
    /// Remove any indentation
    /// </summary>
    public void ClearIndent()
    {
        this.indentLengths.Clear();
        this.currentIndentField = "";
    }
    #endregion
    #region ToString Helpers
    /// <summary>
    /// Utility class to produce culture-oriented representation of an object as a string.
    /// </summary>
    public class ToStringInstanceHelper
    {
        private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
        /// <summary>
        /// Gets or sets format provider to be used by ToStringWithCulture method.
        /// </summary>
        public System.IFormatProvider FormatProvider
        {
            get
            {
                return this.formatProviderField ;
            }
            set
            {
                if ((value != null))
                {
                    this.formatProviderField  = value;
                }
            }
        }
        /// <summary>
        /// This is called from the compile/run appdomain to convert objects within an expression block to a string
        /// </summary>
        public string ToStringWithCulture(object objectToConvert)
        {
            if ((objectToConvert == null))
            {
                throw new global::System.ArgumentNullException("objectToConvert");
            }
            System.Type t = objectToConvert.GetType();
            System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                        typeof(System.IFormatProvider)});
            if ((method == null))
            {
                return objectToConvert.ToString();
            }
            else
            {
                return ((string)(method.Invoke(objectToConvert, new object[] {
                            this.formatProviderField })));
            }
        }
    }
    private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
    /// <summary>
    /// Helper to produce culture-oriented representation of an object as a string
    /// </summary>
    public ToStringInstanceHelper ToStringHelper
    {
        get
        {
            return this.toStringHelperField;
        }
    }
    #endregion
}

/// <summary>
/// Service making names within a scope unique. Initialize a new instance for every scope.
/// </summary>
internal sealed class UniqueIdentifierService
{
    // This is the list of keywords we check against when creating parameter names from propert.
    // If a name matches this keyword we prefix it.
    private static readonly string[] Keywords = new string[] {"class", "event"};

    /// <summary>
    /// Hash set to detect identifier collision.
    /// </summary>
    private readonly HashSet<string> knownIdentifiers;

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="identifiers">identifiers used to detect collision.</param>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(IEnumerable<string> identifiers, bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(identifiers ?? Enumerable.Empty<string>(), caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Given an identifier, makes it unique within the scope by adding
    /// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
    /// </summary>
    /// <param name="identifier">Identifier. Must not be null or empty.</param>
    /// <returns>Identifier adjusted to be unique within the scope.</returns>
    internal string GetUniqueIdentifier(string identifier)
    {
        Debug.Assert(!string.IsNullOrEmpty(identifier), "identifier is null or empty");

        // find a unique name by adding suffix as necessary
        int numberOfConflicts = 0;
        string uniqueIdentifier = identifier;
        while (this.knownIdentifiers.Contains(uniqueIdentifier))
        {
            ++numberOfConflicts;
            uniqueIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
        }

        // remember the identifier in this scope
        Debug.Assert(!this.knownIdentifiers.Contains(uniqueIdentifier), "we just made it unique");
        this.knownIdentifiers.Add(uniqueIdentifier);

        return uniqueIdentifier;
    }

    /// <summary>
    /// Fix up the given parameter name and make it unique.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <returns>Fixed parameter name.</returns>
    internal string GetUniqueParameterName(string name)
    {
        name = Utils.CamelCase(name);

        // FxCop consider 'iD' as violation, we will change any property that is 'id'(case insensitive) to 'ID'
        if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
        {
            name = "ID";
        }

        return this.GetUniqueIdentifier(name);
    }
}

/// <summary>
/// Utility class.
/// </summary>
internal static class Utils
{
    /// <summary>
    /// Serializes the xml element to a string.
    /// </summary>
    /// <param name="xml">The xml element to serialize.</param>
    /// <returns>The string representation of the xml.</returns>
    internal static string SerializeToString(XElement xml)
    {
        // because comment nodes can contain special characters that are hard to embed in VisualBasic, remove them here
        xml.DescendantNodes().OfType<XComment>().Remove();

        var stringBuilder = new StringBuilder();
        using (var writer = XmlWriter.Create(
            stringBuilder,
            new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                NewLineHandling = NewLineHandling.Replace,
                Indent = true,
            }))
        {
            xml.WriteTo(writer);
        }

        return stringBuilder.ToString();
    }

    /// <summary>
    /// Changes the text to use camel case, which lower case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in camel case</returns>
    internal static string CamelCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Changes the text to use pascal case, which upper case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in pascal case</returns>
    internal static string PascalCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Gets the clr type name from the give type reference.
    /// </summary>
    /// <param name="edmTypeReference">The type reference in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <param name="addNullableTemplate">This flag indicates whether to return the type name in nullable format</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by global prefix</param>
    /// <param name="isOperationParameter">This flag indicates whether the edmTypeReference is for an operation parameter</param>
    /// <returns>The clr type name of the type reference.</returns>
    internal static string GetClrTypeName(IEdmTypeReference edmTypeReference, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context, bool addNullableTemplate = true, bool needGlobalPrefix = true, bool isOperationParameter = false, bool isEntitySingleType = false)
    {
        IEdmType edmType = edmTypeReference.Definition;
        if (edmType is IEdmPrimitiveType edmPrimitiveType)
        {
            var clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, clientTemplate);
            if (edmTypeReference.IsNullable && !clientTemplate.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind) && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmComplexType edmComplexType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmComplexType,
                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmComplexType.Name)) : clientTemplate.GetFixedName(edmComplexType.Name), clientTemplate);
            return clrTypeName;
        }
        if (edmType is IEdmEnumType edmEnumType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmEnumType,
                context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEnumType.Name)) : clientTemplate.GetFixedName(edmEnumType.Name), clientTemplate, needGlobalPrefix);
            if (edmTypeReference.IsNullable && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmEntityType edmEntityType)
        {
            var clrTypeName = context.GetPrefixedFullName(edmEntityType,
                context.EnableNamingAlias
                ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEntityType.Name) + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty))
                : clientTemplate.GetFixedName(edmEntityType.Name + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty)),
                clientTemplate);
            return clrTypeName;
        }
        if (edmType is IEdmTypeDefinition edmTypeDefinition)
        {
            var underlyingType = edmTypeDefinition.UnderlyingType;
            var clrTypeName = Utils.GetClrTypeName(underlyingType, clientTemplate);
            if (edmTypeReference.IsNullable && !clientTemplate.ClrReferenceTypes.Contains(underlyingType.PrimitiveKind) && addNullableTemplate)
            {
                clrTypeName = GetNullableClrTypeName(clrTypeName, clientTemplate);
            }
            return clrTypeName;
        }
        if (edmType is IEdmCollectionType edmCollectionType)
        {
            string clrTypeName = null;
            IEdmTypeReference elementTypeReference = edmCollectionType.ElementType;
            IEdmPrimitiveType primitiveElementType = elementTypeReference.Definition as IEdmPrimitiveType;
            if (primitiveElementType != null)
            {
                clrTypeName = Utils.GetClrTypeName(primitiveElementType, clientTemplate);
            }
            else
            {
                IEdmSchemaElement schemaElement = (IEdmSchemaElement)elementTypeReference.Definition;
                clrTypeName = context.GetPrefixedFullName(schemaElement,
                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(schemaElement.Name)) : clientTemplate.GetFixedName(schemaElement.Name), clientTemplate);
            }

            string collectionTypeName = isOperationParameter
                                            ? clientTemplate.ICollectionOfTStructureTemplate
                                            : (useDataServiceCollection
                                                ? (elementTypeReference.TypeKind() == EdmTypeKind.Entity
                                                    ? clientTemplate.DataServiceCollectionStructureTemplate
                                                    : clientTemplate.ObservableCollectionStructureTemplate)
                                                : clientTemplate.ObjectModelCollectionStructureTemplate);

            clrTypeName = string.Format(CultureInfo.InvariantCulture, collectionTypeName, clrTypeName);
            return clrTypeName;
        }

        var errors = edmTypeReference.Errors().Select(e => e.ErrorMessage);
        throw new Exception(
            $"Could not get CLR type name for EDM type '{edmTypeReference.FullName()}'{System.Environment.NewLine}{string.Join(global::System.Environment.NewLine, errors)}");
    }

    /// <summary>
    /// Gets the value expression to initualize the property with.
    /// </summary>
    /// <param name="property">The property in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <returns>The value expression to initualize the property with.</returns>
    internal static string GetPropertyInitializationValue(IEdmProperty property, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context)
    {
        IEdmTypeReference edmTypeReference = property.Type;
        IEdmCollectionTypeReference edmCollectionTypeReference = edmTypeReference as IEdmCollectionTypeReference;
        if (edmCollectionTypeReference == null)
        {
            IEdmStructuralProperty structuredProperty = property as IEdmStructuralProperty;
            if (structuredProperty != null)
            {
                if (!string.IsNullOrEmpty(structuredProperty.DefaultValueString))
                {
                    string valueClrType = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                    string defaultValue = structuredProperty.DefaultValueString;
                    bool isCSharpTemplate = clientTemplate is ODataClientCSharpTemplate;
                    if (edmTypeReference.Definition.TypeKind == EdmTypeKind.Enum)
                    {
                        var enumValues = defaultValue.Split(',');
                        string fullenumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                        string enumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context, false, false);
                        List<string> customizedEnumValues = new List<string>();
                        foreach(var enumValue in enumValues)
                        {
                            string currentEnumValue = enumValue.Trim();
                            int indexFirst = currentEnumValue.IndexOf('\'') + 1;
                            int indexLast = currentEnumValue.LastIndexOf('\'');
                            if (indexFirst > 0 && indexLast > indexFirst)
                            {
                                currentEnumValue = currentEnumValue.Substring(indexFirst, indexLast - indexFirst);
                            }

                            var customizedEnumValue = context.EnableNamingAlias ? Customization.CustomizeNaming(currentEnumValue) : currentEnumValue;
                            if (isCSharpTemplate)
                            {
                                currentEnumValue = "(" + fullenumTypeName + ")" + clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + customizedEnumValue  + "\")";
                            }
                            else
                            {
                                currentEnumValue = clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + currentEnumValue  + "\")";
                            }
                            customizedEnumValues.Add(currentEnumValue);
                        }
                        if (isCSharpTemplate)
                        {
                            return string.Join(" | ", customizedEnumValues);
                        }
                        else
                        {
                            return string.Join(" Or ", customizedEnumValues);
                        }
                    }

                    if (valueClrType.Equals(clientTemplate.StringTypeName))
                    {
                        defaultValue = "\"" + defaultValue + "\"";
                    }
                    else if (valueClrType.Equals(clientTemplate.BooleanTypeName))
                    {
                        // EDMX specifies boolean defaults with capital letter, C# needs this string to be lower case.
                        if (isCSharpTemplate)
                            defaultValue = defaultValue.ToLower();
                    }
                    else if (valueClrType.Equals(clientTemplate.BinaryTypeName))
                    {
                        defaultValue = "System.Text.Encoding.UTF8.GetBytes(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.SingleTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "f";
                        }
                        else
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "F";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.DecimalTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            // decimal in C# must be initialized with 'm' at the end, like Decimal dec = 3.00m
                            defaultValue = defaultValue.EndsWith("m", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "m";
                        }
                        else
                        {
                            // decimal in VB must be initialized with 'D' at the end, like Decimal dec = 3.00D
                            defaultValue = defaultValue.ToLower(CultureInfo.InvariantCulture).Replace("m", "D");
                            defaultValue = defaultValue.EndsWith("D", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "D";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.GuidTypeName)
                        | valueClrType.Equals(clientTemplate.DateTimeOffsetTypeName)
                        | valueClrType.Equals(clientTemplate.DateTypeName)
                        | valueClrType.Equals(clientTemplate.TimeOfDayTypeName))
                    {
                        defaultValue = valueClrType + ".Parse(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.DurationTypeName))
                    {
                        defaultValue = clientTemplate.XmlConvertClassName + ".ToTimeSpan(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Contains("Microsoft.Spatial"))
                    {
                        defaultValue = string.Format(CultureInfo.InvariantCulture, clientTemplate.GeoTypeInitializePattern, valueClrType, defaultValue);
                    }

                    return defaultValue;
                }
                else
                {
                    // doesn't have a default value
                    return null;
                }
            }
            else
            {
                // only structured property has default value
                return null;
            }
        }
        else
        {
            string constructorParameters;
            if (edmCollectionTypeReference.ElementType().IsEntity() && useDataServiceCollection)
            {
                constructorParameters = clientTemplate.DataServiceCollectionConstructorParameters;
            }
            else
            {
                constructorParameters = "()";
            }

            string clrTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
            return clientTemplate.NewModifier + clrTypeName + constructorParameters;
        }
    }

    /// <summary>
    /// Gets the corresponding nullable type name for the given clr type
    /// </summary>
    /// <param name="clrTypeName">Original CLR type name.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <returns>The nullable version of the specified type name.</returns>
    internal static string GetNullableClrTypeName(string clrTypeName, ODataClientTemplate clientTemplate)
    {
        return string.Format(CultureInfo.InvariantCulture, clientTemplate.SystemNullableStructureTemplate, clrTypeName);
    }

    /// <summary>
    /// Gets the clr type name from the give Edm primitive type.
    /// </summary>
    /// <param name="edmPrimitiveType">The Edm primitive type in question.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <returns>The clr type name of the Edm primitive type.</returns>
    internal static string GetClrTypeName(IEdmPrimitiveType edmPrimitiveType, ODataClientTemplate clientTemplate)
    {
        EdmPrimitiveTypeKind kind = edmPrimitiveType.PrimitiveKind;

        string type="UNKNOWN";
        if (kind==EdmPrimitiveTypeKind.Int32)
        {
            type= clientTemplate.Int32TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.String)
        {
            type= clientTemplate.StringTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Binary)
        {
            type= clientTemplate.BinaryTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Decimal)
        {
            type= clientTemplate.DecimalTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Int16)
        {
            type= clientTemplate.Int16TypeName;
        }
        else if(kind==EdmPrimitiveTypeKind.Single)
        {
            type= clientTemplate.SingleTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Boolean)
        {
            type= clientTemplate.BooleanTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Double)
        {
            type= clientTemplate.DoubleTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Guid)
        {
            type= clientTemplate.GuidTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Byte)
        {
            type= clientTemplate.ByteTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Int64)
        {
            type= clientTemplate.Int64TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.SByte)
        {
            type= clientTemplate.SByteTypeName;
        }
        else if (kind == EdmPrimitiveTypeKind.Stream)
        {
            type= clientTemplate.DataServiceStreamLinkTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Geography)
        {
            type= clientTemplate.GeographyTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPoint)
        {
            type= clientTemplate.GeographyPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyLineString)
        {
            type= clientTemplate.GeographyLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPolygon)
        {
            type= clientTemplate.GeographyPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyCollection)
        {
            type= clientTemplate.GeographyCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPolygon)
        {
            type= clientTemplate.GeographyMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiLineString)
        {
            type= clientTemplate.GeographyMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPoint)
        {
            type= clientTemplate.GeographyMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Geometry)
        {
            type= clientTemplate.GeometryTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPoint)
        {
            type= clientTemplate.GeometryPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryLineString)
        {
            type= clientTemplate.GeometryLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPolygon)
        {
            type= clientTemplate.GeometryPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryCollection)
        {
            type= clientTemplate.GeometryCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPolygon)
        {
            type= clientTemplate.GeometryMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiLineString)
        {
            type= clientTemplate.GeometryMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPoint)
        {
            type= clientTemplate.GeometryMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.DateTimeOffset)
        {
            type= clientTemplate.DateTimeOffsetTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Duration)
        {
            type= clientTemplate.DurationTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Date)
        {
            type= clientTemplate.DateTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.TimeOfDay)
        {
            type= clientTemplate.TimeOfDayTypeName;
        }
        else
        {
            throw new Exception("Type "+kind.ToString()+" is unrecognized");
        }

        return type;
    }
}

public sealed class ODataClientCSharpTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientCSharpTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix { get {return "global::"; } }
    internal override string SystemTypeTypeName { get { return "global::System.Type"; } }
    internal override string AbstractModifier { get { return " abstract"; } }
    internal override string PublicAccessModifier { get { return "public"; } }
    internal override string InternalAccessModifier { get { return "internal"; } }
    internal override string DataServiceActionQueryTypeName { get { return "global::Microsoft.OData.Client.DataServiceActionQuery"; } }
    internal override string DataServiceActionQuerySingleOfTStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceActionQuerySingle<{0}>"; } }
    internal override string DataServiceActionQueryOfTStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceActionQuery<{0}>"; } }
    internal override string NotifyPropertyChangedModifier { get { return "global::System.ComponentModel.INotifyPropertyChanged"; } }
    internal override string ClassInheritMarker { get { return " : "; } }
    internal override string ParameterSeparator { get { return ", \r\n                    "; } }
    internal override string KeyParameterSeparator { get { return ", \r\n            "; } }
    internal override string KeyDictionaryItemSeparator { get { return ", \r\n                "; } }
    internal override string SystemNullableStructureTemplate { get { return "global::System.Nullable<{0}>"; } }
    internal override string ICollectionOfTStructureTemplate { get { return "global::System.Collections.Generic.ICollection<{0}>"; } }
    internal override string DataServiceCollectionStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceCollection<{0}>"; } }
    internal override string DataServiceQueryStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceQuery<{0}>"; } }
    internal override string DataServiceQuerySingleStructureTemplate { get { return "global::Microsoft.OData.Client.DataServiceQuerySingle<{0}>"; } }
    internal override string ObservableCollectionStructureTemplate { get { return "global::System.Collections.ObjectModel.ObservableCollection<{0}>"; } }
    internal override string ObjectModelCollectionStructureTemplate { get { return "global::System.Collections.ObjectModel.Collection<{0}>"; } }
    internal override string DataServiceCollectionConstructorParameters { get { return "(null, global::Microsoft.OData.Client.TrackingMode.None)"; } }
    internal override string NewModifier { get { return "new "; } }
    internal override string GeoTypeInitializePattern { get { return "global::Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(false).Read<{0}>(new global::System.IO.StringReader(\"{1}\"))"; } }
    internal override string ObjectTypeName { get { return "object"; } }
    internal override string Int32TypeName { get { return "int"; } }
    internal override string StringTypeName { get { return "string"; } }
    internal override string BinaryTypeName { get { return "byte[]"; } }
    internal override string DecimalTypeName { get { return "decimal"; } }
    internal override string Int16TypeName { get { return "short"; } }
    internal override string SingleTypeName { get { return "float"; } }
    internal override string BooleanTypeName { get { return "bool"; } }
    internal override string DoubleTypeName { get { return "double"; } }
    internal override string GuidTypeName { get { return "global::System.Guid"; } }
    internal override string ByteTypeName { get { return "byte"; } }
    internal override string Int64TypeName { get { return "long"; } }
    internal override string SByteTypeName { get { return "sbyte"; } }
    internal override string DataServiceStreamLinkTypeName { get { return "global::Microsoft.OData.Client.DataServiceStreamLink"; } }
    internal override string GeographyTypeName { get { return "global::Microsoft.Spatial.Geography"; } }
    internal override string GeographyPointTypeName { get { return "global::Microsoft.Spatial.GeographyPoint"; } }
    internal override string GeographyLineStringTypeName { get { return "global::Microsoft.Spatial.GeographyLineString"; } }
    internal override string GeographyPolygonTypeName { get { return "global::Microsoft.Spatial.GeographyPolygon"; } }
    internal override string GeographyCollectionTypeName { get { return "global::Microsoft.Spatial.GeographyCollection"; } }
    internal override string GeographyMultiPolygonTypeName { get { return "global::Microsoft.Spatial.GeographyMultiPolygon"; } }
    internal override string GeographyMultiLineStringTypeName { get { return "global::Microsoft.Spatial.GeographyMultiLineString"; } }
    internal override string GeographyMultiPointTypeName { get { return "global::Microsoft.Spatial.GeographyMultiPoint"; } }
    internal override string GeometryTypeName { get { return "global::Microsoft.Spatial.Geometry"; } }
    internal override string GeometryPointTypeName { get { return "global::Microsoft.Spatial.GeometryPoint"; } }
    internal override string GeometryLineStringTypeName { get { return "global::Microsoft.Spatial.GeometryLineString"; } }
    internal override string GeometryPolygonTypeName { get { return "global::Microsoft.Spatial.GeometryPolygon"; } }
    internal override string GeometryCollectionTypeName { get { return "global::Microsoft.Spatial.GeometryCollection"; } }
    internal override string GeometryMultiPolygonTypeName { get { return "global::Microsoft.Spatial.GeometryMultiPolygon"; } }
    internal override string GeometryMultiLineStringTypeName { get { return "global::Microsoft.Spatial.GeometryMultiLineString"; } }
    internal override string GeometryMultiPointTypeName { get { return "global::Microsoft.Spatial.GeometryMultiPoint"; } }
    internal override string DateTypeName { get { return "global::Microsoft.OData.Edm.Date"; } }
    internal override string DateTimeOffsetTypeName { get { return "global::System.DateTimeOffset"; } }
    internal override string DurationTypeName { get { return "global::System.TimeSpan"; } }
    internal override string TimeOfDayTypeName { get { return "global::Microsoft.OData.Edm.TimeOfDay"; } }
    internal override string XmlConvertClassName { get { return "global::System.Xml.XmlConvert"; } }
    internal override string EnumTypeName { get { return "global::System.Enum"; } }
    internal override string DictionaryInterfaceName { get { return "global::System.Collections.Generic.IDictionary<{0}, {1}>"; } }
    internal override string DictionaryTypeName { get { return "global::System.Collections.Generic.Dictionary<{0}, {1}>"; } }
    internal override string FixPattern { get { return "@{0}"; } }
    internal override string EnumUnderlyingTypeMarker { get { return " : "; } }
    internal override string ConstantExpressionConstructorWithType { get { return "global::System.Linq.Expressions.Expression.Constant({0}, typeof({1}))"; } }
    internal override string TypeofFormatter { get { return "typeof({0})"; } }
    internal override string UriOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})"; } }
    internal override string UriEntityOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})"; } }
    internal override string BodyOperationParameterConstructor { get { return "new global::Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})"; } }
    internal override string DictionaryConstructor { get { return "new global::System.Collections.Generic.Dictionary<{0}, {1}>()"; } }
    internal override string BaseEntityType { get { return " : global::Microsoft.OData.Client.BaseEntityType"; } }
    internal override string OverloadsModifier { get { return "new "; } }
    internal override string ODataVersion { get { return "global::Microsoft.OData.ODataVersion.V4"; } }
    internal override string ParameterDeclarationTemplate { get { return "{0} {1}"; } }
    internal override string DictionaryItemConstructor { get { return "{{ {0}, {1} }}"; } }
    internal override string ContainerPropertyBase { get { return "DynamicProperties"; } }
    internal override string ContainerPropertyAttribute { get { return "[global::Microsoft.OData.Client.ContainerProperty]"; } }
    internal override HashSet<string> LanguageKeywords { get {
        if (CSharpKeywords == null)
        {
            CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
            {
                "abstract", "as", "base", "byte", "bool", "break", "case", "catch", "char", "checked", "class", "const", "continue",
                "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "for",
                "foreach", "finally", "fixed", "float", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
                "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "string", "short", "sizeof", "stackalloc", "static", "struct", "switch",
                "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "volatile",
                "void", "while"
            };
        }
        return CSharpKeywords;
    } }
    private HashSet<string> CSharpKeywords;

    internal override void WriteFileHeader()
    {

this.Write("//------------------------------------------------------------------------------\r" +
        "\n// <auto-generated>\r\n//     This code was generated by a tool.\r\n//     Runtime " +
        "Version:");

this.Write(this.ToStringHelper.ToStringWithCulture(Environment.Version));

this.Write("\r\n//\r\n//     Changes to this file may cause incorrect behavior and will be lost i" +
        "f\r\n//     the code is regenerated.\r\n// </auto-generated>\r\n//--------------------" +
        "----------------------------------------------------------\r\n\r\n// Generation date" +
        ": ");

this.Write(this.ToStringHelper.ToStringWithCulture(DateTime.Now.ToString(global::System.Globalization.CultureInfo.CurrentCulture)));

this.Write("\r\n");


    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {

this.Write("namespace ");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\r\n{\r\n");


    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {containerName} in the schema." : description, true);
        if (this.context.EnableNamingAlias)
        {

this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalContainerName));

this.Write("\")]\r\n");


        }

this.Write("    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" partial class ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

this.Write(" : global::Microsoft.OData.Client.DataServiceContext\r\n    {\r\n");


    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {

this.Write("        /// <summary>\r\n        /// Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(" object.\r\n        /// </summary>\r\n        [global::System.CodeDom.Compiler.Genera" +
        "tedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        public ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

this.Write("(global::System.Uri serviceRoot) :\r\n                base(serviceRoot, global::Mic" +
        "rosoft.OData.Client.ODataProtocolVersion.V4)\r\n        {\r\n");


    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {

this.Write("            this.UrlKeyDelimiter = global::Microsoft.OData.Client.DataServiceUrlK" +
        "eyDelimiter.Slash;\r\n");


    }

    internal override void WriteInitializeResolveName()
    {

this.Write("            this.ResolveName = new global::System.Func<global::System.Type, strin" +
        "g>(this.ResolveNameFromType);\r\n");


    }

    internal override void WriteInitializeResolveType()
    {

this.Write("            this.ResolveType = new global::System.Func<string, global::System.Typ" +
        "e>(this.ResolveTypeFromName);\r\n");


    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {

this.Write("            this.OnContextCreated();\r\n            this.Format.LoadServiceModel = " +
        "GeneratedEdmModel.GetInstance;\r\n            this.Format.UseJson();\r\n        }\r\n " +
        "       partial void OnContextCreated();\r\n");


    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {

this.Write(@"        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        protected global::System.Type ResolveTypeFromName(string typeName)\r\n" +
        "        {\r\n");


    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {

this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("resolvedType = this.DefaultResolveType(typeName, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\");\r\n            if ((resolvedType != null))\r\n            {\r\n                retu" +
        "rn resolvedType;\r\n            }\r\n");


    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {

this.Write("            return null;\r\n        }\r\n");


    }

    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {

    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {

this.Write(@"        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        protected string ResolveNameFromType(global::System.Type clientType)" +
        "\r\n        {\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write(@"            global::Microsoft.OData.Client.OriginalNameAttribute originalNameAttribute = (global::Microsoft.OData.Client.OriginalNameAttribute)global::System.Linq.Enumerable.SingleOrDefault(global::Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, typeof(global::Microsoft.OData.Client.OriginalNameAttribute), true));
");


        }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {

this.Write("            if (clientType.Namespace.Equals(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\", global::System.StringComparison.Ordinal))\r\n            {\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("                if (originalNameAttribute != null)\r\n                {\r\n          " +
        "          return string.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", originalNameAttribute.OriginalName);\r\n                }\r\n");


        }

this.Write("                return string.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", clientType.Name);\r\n            }\r\n");


    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {

this.Write("            if (originalNameAttribute != null)\r\n            {\r\n                re" +
        "turn clientType.Namespace + \".\" + originalNameAttribute.OriginalName;\r\n         " +
        "   }\r\n");


        }

this.Write("            return ");

this.Write(this.ToStringHelper.ToStringWithCulture(modelHasInheritance ? "clientType.FullName" : "null"));

this.Write(";\r\n        }\r\n");


    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {

this.Write("        /// <summary>\r\n        /// Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(" object.\r\n        /// </summary>\r\n        public ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write("(global::Microsoft.OData.Client.DataServiceContext context, string path)\r\n       " +
        "     : base(context, path) {}\r\n\r\n        /// <summary>\r\n        /// Initialize a" +
        " new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(" object.\r\n        /// </summary>\r\n        public ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write("(global::Microsoft.OData.Client.DataServiceContext context, string path, bool isC" +
        "omposable)\r\n            : base(context, path, isComposable) {}\r\n\r\n        /// <s" +
        "ummary>\r\n        /// Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(" object.\r\n        /// </summary>\r\n        public ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(" query)\r\n            : base(query) {}\r\n\r\n");


    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {entitySetName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write("> ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetFixedName));

this.Write("\r\n        {\r\n            get\r\n            {\r\n");


        if (!inContext)
        {

this.Write("                if (!this.IsComposable)\r\n                {\r\n                    t" +
        "hrow new global::System.NotSupportedException(\"The previous function is not comp" +
        "osable.\");\r\n                }\r\n");


        }

this.Write("                if ((this._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" == null))\r\n                {\r\n                    this._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "base" : "Context"));

this.Write(".CreateQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(">(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")"));

this.Write(");\r\n                }\r\n                return this._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(";\r\n            }\r\n        }\r\n        [global::System.CodeDom.Compiler.GeneratedCo" +
        "deAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        private global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write("> _");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(";\r\n");


    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {singletonName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalSingletonName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonFixedName));

this.Write("\r\n        {\r\n            get\r\n            {\r\n");


        if (!inContext)
        {

this.Write("                if (!this.IsComposable)\r\n                {\r\n                    t" +
        "hrow new global::System.NotSupportedException(\"The previous function is not comp" +
        "osable.\");\r\n                }\r\n");


        }

this.Write("                if ((this._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" == null))\r\n                {\r\n                    this._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" = new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "this" : "this.Context"));

this.Write(", ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")"));

this.Write(");\r\n                }\r\n                return this._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(";\r\n            }\r\n        }\r\n        [global::System.CodeDom.Compiler.GeneratedCo" +
        "deAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        private ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write(" _");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(";\r\n");


    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {
        WriteDescriptionSummary($"There are no comments for {entitySetName} in the schema.");

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        public virtual void AddTo");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(")\r\n        {\r\n            base.AddObject(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {
        string path = this.context.MetadataFilePath;
        string relativePath = this.context.MetadataFileRelativePath;
        if(!String.IsNullOrEmpty(path))
        {
            using (StreamWriter writer = new StreamWriter(path, false))
            {
                writer.WriteLine(escapedEdmxString);
            }
        }

        bool useTempFile = !String.IsNullOrEmpty(path) && System.IO.File.Exists(path);

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        private abstract class GeneratedEdmModel\r\n        {\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private static global::System.Collections.Generic.Dictionary<str" +
        "ing, string> ReferencesMap = new global::System.Collections.Generic.Dictionary<s" +
        "tring, string>()\r\n                {\r\n");


            foreach(var reference in this.context.ReferencesMap)
            {

this.Write("                    {@\"");

this.Write(this.ToStringHelper.ToStringWithCulture(reference.Key.OriginalString.Replace("\"", "\"\"")));

this.Write("\", @\"");

this.Write(this.ToStringHelper.ToStringWithCulture(Utils.SerializeToString(reference.Value).Replace("\"", "\"\"")));

this.Write("\"},\r\n");


            }

this.Write("                };\r\n");


        }

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel ParsedModel" +
        " = LoadModelFromString();\r\n\r\n");


            if (useTempFile)
            {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private const string filePath = @\"");

this.Write(this.ToStringHelper.ToStringWithCulture(relativePath));

this.Write("\";\r\n");


            }
            else
            {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private const string Edmx = @\"");

this.Write(this.ToStringHelper.ToStringWithCulture(escapedEdmxString));

this.Write("\";\r\n");


            }

this.Write("\r\n            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft." +
        "OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            public static global::Microsoft.OData.Edm.IEdmModel GetInstance(" +
        ")\r\n            {\r\n                return ParsedModel;\r\n            }\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")]
            private static global::System.Xml.XmlReader getReferencedModelFromMap(global::System.Uri uri)
            {
                string referencedEdmx;
                if (ReferencesMap.TryGetValue(uri.OriginalString, out referencedEdmx))
                {
                    return CreateXmlReader(referencedEdmx);
                }

                return null;
            }
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFr" +
        "omString()\r\n            {\r\n                ");


                if (useTempFile)
                {

this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader();\r\n");


                }
                else
                {

this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);\r\n");


                }

this.Write(@"                try
                {
                    return global::Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, getReferencedModelFromMap);
                }
                finally
                {
                    ((global::System.IDisposable)(reader)).Dispose();
                }
            }
");


        }
        else
        {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFr" +
        "omString()\r\n            {\r\n");


                if (useTempFile)
                {

this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader();\r\n");


                }
                else
                {

this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);\r\n");


                }

this.Write(@"                try
                {
                    global::System.Collections.Generic.IEnumerable<global::Microsoft.OData.Edm.Validation.EdmError> errors;
                    global::Microsoft.OData.Edm.IEdmModel edmModel;

                    if (!global::Microsoft.OData.Edm.Csdl.CsdlReader.TryParse(reader, ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.context.IgnoreUnexpectedElementsAndAttributes ? "true" : "false"));

this.Write(@", out edmModel, out errors))
                    {
	                    global::System.Text.StringBuilder errorMessages = new global::System.Text.StringBuilder();
	                    foreach (var error in errors)
	                    {
		                    errorMessages.Append(error.ErrorMessage);
		                    errorMessages.Append(""; "");
	                    }
	                    throw new global::System.InvalidOperationException(errorMessages.ToString());
                    }

                    return edmModel;
                }
                finally
                {
                    ((global::System.IDisposable)(reader)).Dispose();
                }
            }
");


        }

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n            private static global::System.Xml.XmlReader CreateXmlReader(stri" +
        "ng edmxToParse)\r\n            {\r\n                return global::System.Xml.XmlRea" +
        "der.Create(new global::System.IO.StringReader(edmxToParse));\r\n            }\r\n\r\n");


        if (useTempFile)
        {

this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
        "ata.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")]
            private static global::System.Xml.XmlReader CreateXmlReader()
            {
                try
                {
                    var assembly = global::System.Reflection.Assembly.GetExecutingAssembly();
                    var resourcePath = global::System.Linq.Enumerable.Single(assembly.GetManifestResourceNames(), str => str.EndsWith(filePath));
                    global::System.IO.Stream stream = assembly.GetManifestResourceStream(resourcePath);
                    return global::System.Xml.XmlReader.Create(new global::System.IO.StreamReader(stream));
                }
                catch(global::System.Xml.XmlException e)
                {
                    throw new global::System.Xml.XmlException(""Failed to create an XmlReader from the stream. Check if the resource exists."", e);
                }
            }
");


        }

this.Write("        }\r\n");


    }

    internal override void WriteClassEndForEntityContainer()
    {

this.Write("    }\r\n");


    }

    internal override void WriteSummaryCommentForStructuredType(string typeName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {typeName} in the schema." : description, true);
    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {

this.Write("    /// <KeyProperties>\r\n");


        foreach (string key in keyProperties)
        {

this.Write("    /// ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\r\n");


        }

this.Write("    /// </KeyProperties>\r\n    [global::Microsoft.OData.Client.Key(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(keyString));

this.Write("\")]\r\n");


    }

    internal override void WriteEntityTypeAttribute()
    {

this.Write("    [global::Microsoft.OData.Client.EntityType()]\r\n");


    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {

this.Write("    [global::Microsoft.OData.Client.EntitySet(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("\")]\r\n");


    }

    internal override void WriteEntityHasStreamAttribute()
    {

this.Write("    [global::Microsoft.OData.Client.HasStream()]\r\n");


    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
        {

this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalTypeName));

this.Write("\")]\r\n");


        }

this.Write("    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(this.ToStringHelper.ToStringWithCulture(abstractModifier));

this.Write(" partial class ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write("\r\n    {\r\n");


    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {

this.Write("        /// <summary>\r\n        /// Create a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" object.\r\n        /// </summary>\r\n");


    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {

this.Write("        /// <param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\">Initial value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(".</param>\r\n");


    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedTypeName));

this.Write(" Create");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("(");


    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {

this.Write(this.ToStringHelper.ToStringWithCulture(parameterTypeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(this.ToStringHelper.ToStringWithCulture(parameterSeparater));


    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {
          
this.Write(")\r\n        {\r\n            ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(" = new ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("();\r\n");


    }

    internal override void  WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {

this.Write("            if ((");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" == null))\r\n            {\r\n                throw new global::System.ArgumentNullE" +
        "xception(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\");\r\n            }\r\n");


    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {

this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(";\r\n");


    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {

this.Write("            return ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(";\r\n        }\r\n");


    }

    internal override void WritePropertyForStructuredType(PropertyOptions propertyOptions)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(propertyOptions.PropertyDescription) ? $"There are no comments for Property {propertyOptions.PropertyName} in the schema." : propertyOptions.PropertyDescription);
        WriteObsoleteAttribute(propertyOptions.RevisionAnnotations);

this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
        "Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n\r\n");


        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(propertyOptions.OriginalPropertyName))
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.OriginalPropertyName));

this.Write("\")]\r\n");


        }

        if (propertyOptions.PropertyMaxLength != null)
        {
            WriteStringLengthAttribute((int)propertyOptions.PropertyMaxLength, $"{propertyOptions.PropertyName} cannot be longer than {propertyOptions.PropertyMaxLength} characters.");
        }

        if (!propertyOptions.IsNullable)
        {
            WriteRequiredAttribute($"{propertyOptions.PropertyName} is required.");
        }


        if (!string.IsNullOrEmpty(propertyOptions.PropertyAttribute))
        {

this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyAttribute));

this.Write("\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.FixedPropertyName));

this.Write("\r\n        {\r\n            get\r\n            {\r\n                return this.");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write(";\r\n            }\r\n            set\r\n            {\r\n                this.On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changing(value);\r\n                this.");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write(" = value;\r\n                this.On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changed();\r\n");


        if (propertyOptions.WriteOnPropertyChanged)
        {

this.Write("                this.OnPropertyChanged(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.OriginalPropertyName));

this.Write("\");\r\n");


        }

this.Write("            }\r\n        }\r\n        [global::System.CodeDom.Compiler.GeneratedCodeA" +
        "ttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")]\r\n        private ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyInitializationValue != null ? " = " + propertyOptions.PropertyInitializationValue : string.Empty));

this.Write(";\r\n        partial void On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changing(");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write(" value);\r\n        partial void On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changed();\r\n");


    }

    internal override void WriteINotifyPropertyChangedImplementation()
    {

this.Write("        /// <summary>\r\n        /// This event is raised when the value of the pro" +
        "perty is changed\r\n        /// </summary>\r\n        [global::System.CodeDom.Compil" +
        "er.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")]
        public event global::System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        /// <summary>
        /// The value of the property is changed
        /// </summary>
        /// <param name=""property"">property name</param>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")]
        protected virtual void OnPropertyChanged(string property)
        {
            if ((this.PropertyChanged != null))
            {
                this.PropertyChanged(this, new global::System.ComponentModel.PropertyChangedEventArgs(property));
            }
        }
");


    }

    internal override void WriteClassEndForStructuredType()
    {

this.Write("    }\r\n");


    }

    internal override void WriteEnumFlags()
    {

this.Write("    [global::System.Flags]\r\n");


    }

    internal override void WriteSummaryCommentForEnumType(string enumName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {enumName} in the schema." : description, true);
    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
        {

this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEnumName));

this.Write("\")]\r\n");


        }

this.Write("    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" enum ");

this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

this.Write(this.ToStringHelper.ToStringWithCulture(underlyingType));

this.Write("\r\n    {\r\n");


    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalMemberName));

this.Write("\")]\r\n");


        }

this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(member));

this.Write(this.ToStringHelper.ToStringWithCulture(last ? string.Empty : ","));

this.Write("\r\n");


    }

    internal override void WriteEnumEnd()
    {

this.Write("    }\r\n");


    }

    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("> ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(")\r\n        {\r\n            return this.CreateFunctionQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(\"\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(")\r\n        {\r\n            return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("this.CreateFunctionQuerySingle<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(\"\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write(";\r\n        }\r\n");


    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("> ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(")\r\n        {\r\n            global::System.Uri requestUri;\r\n            Context.Try" +
        "GetUri(this, out requestUri);\r\n            return this.Context.CreateFunctionQue" +
        "ry<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(string.Join(\"/\", global::System.Linq.Enumerable.Select(global::System.Linq.Enum" +
        "erable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.T" +
        "rim(\'/\'))), \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(")\r\n        {\r\n            global::System.Uri requestUri;\r\n            Context.Try" +
        "GetUri(this, out requestUri);\r\n\r\n            return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("this.Context.CreateFunctionQuerySingle<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(string.Join(\"/\", global::System.Linq.Enumerable.Select(global::System.Linq.Enum" +
        "erable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.T" +
        "rim(\'/\'))), \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write(";\r\n        }\r\n");


        }

    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(")\r\n        {\r\n            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(this, this.BaseUri.OriginalString.Trim(\'/\') + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")]\r\n");


        }

this.Write("        public virtual ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(@")
        {
            global::Microsoft.OData.Client.EntityDescriptor resource = Context.EntityTracker.TryGetEntityDescriptor(this);
            if (resource == null)
            {
                throw new global::System.Exception(""cannot find entity"");
            }

            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(this.Context, resource.EditLink.OriginalString.Trim(\'/\') + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteExtensionMethodsStart()
    {

this.Write("    /// <summary>\r\n    /// Class containing all extension methods\r\n    /// </summ" +
        "ary>\r\n    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" static class ExtensionMethods\r\n    {\r\n");


    }

    internal override void WriteExtensionMethodsEnd()
    {

this.Write("    }\r\n");


    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {

this.Write("        /// <summary>\r\n        /// Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" specified by key from an entity set\r\n        /// </summary>\r\n        /// <param " +
        "name=\"_source\">source entity set</param>\r\n        /// <param name=\"_keys\">dictio" +
        "nary with the names and values of keys</param>\r\n        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" ByKey(this global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("> _source, global::System.Collections.Generic.IDictionary<string, object> _keys)\r" +
        "\n        {\r\n            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.Ge" +
        "tKeyString(_source.Context, _keys)));\r\n        }\r\n        /// <summary>\r\n       " +
        " /// Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" specified by key from an entity set\r\n        /// </summary>\r\n        /// <param " +
        "name=\"_source\">source entity set</param>\r\n");


        foreach (var key in keys)
        {

this.Write("        /// <param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\">The value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("</param>\r\n");


        }

this.Write("        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" ByKey(this global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("> _source,\r\n            ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyParameters));

this.Write(")\r\n        {\r\n            global::System.Collections.Generic.IDictionary<string, " +
        "object> _keys = new global::System.Collections.Generic.Dictionary<string, object" +
        ">\r\n            {\r\n                ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyDictionaryItems));

this.Write("\r\n            };\r\n            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.Ge" +
        "tKeyString(_source.Context, _keys)));\r\n        }\r\n");


    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {

this.Write("        /// <summary>\r\n        /// Cast an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(" to its derived type ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write("\r\n        /// </summary>\r\n        /// <param name=\"_source\">source entity</param>" +
        "\r\n        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" CastTo");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeName));

this.Write("(this global::Microsoft.OData.Client.DataServiceQuerySingle<");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write("> _source)\r\n        {\r\n            global::Microsoft.OData.Client.DataServiceQuer" +
        "ySingle<");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write("> query = _source.CastTo<");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write(">();\r\n            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, query.GetPath(null));\r\n        }\r\n");


    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(this ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(" _source");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n            " +
        "    throw new global::System.NotSupportedException(\"The previous function is not" +
        " composable.\");\r\n            }\r\n\r\n            return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("_source.CreateFunctionQuerySingle<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write(";\r\n        }\r\n");


    }

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")]\r\n");


        }

this.Write("        public static global::Microsoft.OData.Client.DataServiceQuery<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("> ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(this ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(" _source");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = true" : string.Empty));

this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n            " +
        "    throw new global::System.NotSupportedException(\"The previous function is not" +
        " composable.\");\r\n            }\r\n\r\n            return _source.CreateFunctionQuery" +
        "<");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(">(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower(CultureInfo.InvariantCulture)));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(");\r\n        }\r\n");


    }

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        if (this.context.EnableNamingAlias)
        {

this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")]\r\n");


        }

this.Write("        public static ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(this ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

this.Write(" _source");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n            " +
        "    throw new global::System.NotSupportedException(\"The previous function is not" +
        " composable.\");\r\n            }\r\n\r\n            return new ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.AppendRequestUri(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(");\r\n        }\r\n");


    }

    protected override void WriteDescriptionSummary(string description, bool isClass = false)
    {
        if (isClass)
        {

this.Write("    /// <summary>\r\n    /// ");

this.Write(this.ToStringHelper.ToStringWithCulture(description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n    ///")));

this.Write("\r\n    /// </summary>\r\n");


        }
        else
        {

this.Write("        /// <summary>\r\n        /// ");

this.Write(this.ToStringHelper.ToStringWithCulture(description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n        ///")));

this.Write("\r\n        /// </summary>\r\n");


        }
    }

    protected override void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false)
    {
        if (!revisionAnnotations.TryGetValue(deprecated, out string revisionDescription))
        {
           return;
        }

        if (isClass)
        {

this.Write("    [global::System.ObsoleteAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(revisionDescription));

this.Write("\")]\r\n");


        }
        else
        {

this.Write("        [global::System.ObsoleteAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(revisionDescription));

this.Write("\")]\r\n");


        }
    }

    protected override void WriteStringLengthAttribute(int maxLength, string errorMessage)
    {

this.Write("        [global::System.ComponentModel.DataAnnotations.StringLengthAttribute(");

this.Write(this.ToStringHelper.ToStringWithCulture(maxLength));

this.Write(", ErrorMessage = \"");

this.Write(this.ToStringHelper.ToStringWithCulture(errorMessage));

this.Write("\")]\r\n");


    }

    protected override void WriteRequiredAttribute(string errorMessage)
    {

this.Write("        [global::System.ComponentModel.DataAnnotations.RequiredAttribute(ErrorMes" +
        "sage = \"");

this.Write(this.ToStringHelper.ToStringWithCulture(errorMessage));

this.Write("\")]\r\n");


    }

    internal override void WriteNamespaceEnd()
    {

this.Write("}\r\n");


    }
}

public sealed class ODataClientVBTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The cotion context.</param>
    public ODataClientVBTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix { get { return string.Empty; } }
    internal override string SystemTypeTypeName { get { return "Global.System.Type"; } }
    internal override string AbstractModifier { get { return " MustInherit"; } }
    internal override string PublicAccessModifier { get { return "Public"; } }
    internal override string InternalAccessModifier { get { return "Friend"; } }
    internal override string DataServiceActionQueryTypeName { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery"; } }
    internal override string DataServiceActionQuerySingleOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuerySingle(Of {0})"; } }
    internal override string DataServiceActionQueryOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery(Of {0})"; } }
    internal override string NotifyPropertyChangedModifier { get { return "\r\n        Implements Global.System.ComponentModel.INotifyPropertyChanged"; } }
    internal override string ClassInheritMarker { get { return "\r\n        Inherits "; } }
    internal override string ParameterSeparator { get { return ",  _\r\n                    "; } }
    internal override string KeyParameterSeparator { get { return ",  _\r\n            "; } }
    internal override string KeyDictionaryItemSeparator { get { return ",  _\r\n                "; } }
    internal override string SystemNullableStructureTemplate { get { return "Global.System.Nullable(Of {0})"; } }
    internal override string ICollectionOfTStructureTemplate { get { return "Global.System.Collections.Generic.ICollection(Of {0})"; } }
    internal override string DataServiceCollectionStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceCollection(Of {0})"; } }
    internal override string DataServiceQueryStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuery(Of {0})"; } }
    internal override string DataServiceQuerySingleStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuerySingle(Of {0})"; } }
    internal override string ObservableCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.ObservableCollection(Of {0})"; } }
    internal override string ObjectModelCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.Collection(Of {0})"; } }
    internal override string DataServiceCollectionConstructorParameters { get { return "(Nothing, Global.Microsoft.OData.Client.TrackingMode.None)"; } }
    internal override string NewModifier { get { return "New "; } }
    internal override string GeoTypeInitializePattern { get { return "Global.Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(False).Read(Of {0})(New Global.System.IO.StringReader(\"{1}\"))"; } }
    internal override string ObjectTypeName { get { return "Object"; } }
    internal override string Int32TypeName { get { return "Integer"; } }
    internal override string StringTypeName { get { return "String"; } }
    internal override string BinaryTypeName { get { return "Byte()"; } }
    internal override string DecimalTypeName { get { return "Decimal"; } }
    internal override string Int16TypeName { get { return "Short"; } }
    internal override string SingleTypeName { get { return "Single"; } }
    internal override string BooleanTypeName { get { return "Boolean"; } }
    internal override string DoubleTypeName { get { return "Double"; } }
    internal override string GuidTypeName { get { return "Global.System.Guid"; } }
    internal override string ByteTypeName { get { return "Byte"; } }
    internal override string Int64TypeName { get { return "Long"; } }
    internal override string SByteTypeName { get { return "SByte"; } }
    internal override string DataServiceStreamLinkTypeName { get { return "Global.Microsoft.OData.Client.DataServiceStreamLink"; } }
    internal override string GeographyTypeName { get { return "Global.Microsoft.Spatial.Geography"; } }
    internal override string GeographyPointTypeName { get { return "Global.Microsoft.Spatial.GeographyPoint"; } }
    internal override string GeographyLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyLineString"; } }
    internal override string GeographyPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyPolygon"; } }
    internal override string GeographyCollectionTypeName { get { return "Global.Microsoft.Spatial.GeographyCollection"; } }
    internal override string GeographyMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPolygon"; } }
    internal override string GeographyMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiLineString"; } }
    internal override string GeographyMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPoint"; } }
    internal override string GeometryTypeName { get { return "Global.Microsoft.Spatial.Geometry"; } }
    internal override string GeometryPointTypeName { get { return "Global.Microsoft.Spatial.GeometryPoint"; } }
    internal override string GeometryLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryLineString"; } }
    internal override string GeometryPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryPolygon"; } }
    internal override string GeometryCollectionTypeName { get { return "Global.Microsoft.Spatial.GeometryCollection"; } }
    internal override string GeometryMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPolygon"; } }
    internal override string GeometryMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiLineString"; } }
    internal override string GeometryMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPoint"; } }
    internal override string DateTypeName { get { return "Global.Microsoft.OData.Edm.Date"; } }
    internal override string DateTimeOffsetTypeName { get { return "Global.System.DateTimeOffset"; } }
    internal override string DurationTypeName { get { return "Global.System.TimeSpan"; } }
    internal override string TimeOfDayTypeName { get { return "Global.Microsoft.OData.Edm.TimeOfDay"; } }
    internal override string XmlConvertClassName { get { return "Global.System.Xml.XmlConvert"; } }
    internal override string EnumTypeName { get { return "Global.System.Enum"; } }
    internal override string DictionaryInterfaceName { get { return "Global.System.Collections.Generic.IDictionary(Of {0}, {1})"; } }
    internal override string DictionaryTypeName { get { return "Global.System.Collections.Generic.Dictionary(Of {0}, {1})"; } }
    internal override string FixPattern { get { return "[{0}]"; } }
    internal override string EnumUnderlyingTypeMarker { get { return " As "; } }
    internal override string ConstantExpressionConstructorWithType { get { return "Global.System.Linq.Expressions.Expression.Constant({0}, GetType({1}))"; } }
    internal override string TypeofFormatter { get { return "GetType({0})"; } }
    internal override string UriOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})"; } }
    internal override string UriEntityOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})"; } }
    internal override string BodyOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})"; } }
    internal override string DictionaryConstructor { get { return "New Global.System.Collections.Generic.Dictionary(Of {0}, {1})"; } }
    internal override string BaseEntityType { get { return "\r\n        Inherits Global.Microsoft.OData.Client.BaseEntityType"; } }
    internal override string OverloadsModifier { get { return "Overloads "; } }
    internal override string ODataVersion { get { return "Global.Microsoft.OData.ODataVersion.V4"; } }
    internal override string ParameterDeclarationTemplate { get { return "{1} As {0}"; } }
    internal override string DictionaryItemConstructor { get { return "{{ {0}, {1} }}"; } }
    internal override string ContainerPropertyBase { get { return "DynamicProperties"; } }
    internal override string ContainerPropertyAttribute { get { return "<Global.Microsoft.OData.Client.ContainerProperty>"; } }
    internal override HashSet<string> LanguageKeywords { get {
        if (VBKeywords == null)
        {
            VBKeywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "AddHandler", "AddressOf", "Alias", "And", "AndAlso", "As", "Boolean", "ByRef", "Byte", "ByVal",
                "Call", "Case", "Catch", "CBool", "", "CByte", "CChar", "CDate", "CDbl", "CDec", "Char",
                "CInt", "Class", "CLng", "CObj", "Const", "Continue", "CSByte", "CShort", "CSng", "CStr",
                "CType", "CUInt", "CULng", "CUShort", "Date", "Decimal", "Declare", "Default", "Delegate", "Dim",
                "DirectCast", "Do", "Double", "Each", "Else", "ElseIf", "End", "EndIf", "Enum", "Erase",
                "Error", "Event", "Exit", "False", "Finally", "For", "Friend", "Function", "Get", "GetType",
                "GetXMLNamespace", "Global", "GoSub", "GoTo", "Handles", "If", "Implements", "Imports", "In", "Inherits",
                "Integer", "Interface", "Is", "IsNot", "Let", "Lib", "Like", "Long", "Loop", "Me",
                "Mod", "Module", "MustInherit", "MustOverride", "MyBase", "MyClass", "Namespace", "Narrowing", "New", "Next",
                "Not", "Nothing", "NotInheritable", "NotOverridable", "Object", "Of", "On", "Operator", "Option", "Optional",
                "Or", "OrElse", "Out", "Overloads", "Overridable", "Overrides", "ParamArray", "Partial", "Private", "Property",
                "Protected", "Public", "RaiseEvent", "ReadOnly", "ReDim", "REM", "RemoveHandler", "Resume", "Return", "SByte",
                "Select", "Set", "Shadows", "Shared", "Short", "Single", "Static", "Step", "Stop", "String",
                "Structure", "Sub", "SyncLock", "Then", "Throw", "To", "True", "Try", "TryCast", "TypeOf",
                "UInteger", "ULong", "UShort", "Using", "Variant", "Wend", "When", "While", "Widening", "With",
                "WithEvents", "WriteOnly", "Xor"
            };
        }
        return VBKeywords;
    } }
    private HashSet<string> VBKeywords;

    internal override void WriteFileHeader()
    {

this.Write("\'------------------------------------------------------------------------------\r\n" +
        "\' <auto-generated>\r\n\'     This code was generated by a tool.\r\n\'     Runtime Vers" +
        "ion:");

this.Write(this.ToStringHelper.ToStringWithCulture(Environment.Version));

this.Write(@"
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On


'Generation date: ");

this.Write(this.ToStringHelper.ToStringWithCulture(DateTime.Now.ToString(System.Globalization.CultureInfo.CurrentCulture)));

this.Write("\r\n");


    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {

this.Write("Namespace ");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\r\n");


    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {containerName} in the schema." : description, true);
        if (this.context.EnableNamingAlias)
        {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalContainerName));

this.Write("\")>  _\r\n");


        }

this.Write("    Partial ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" Class ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

this.Write("\r\n        Inherits Global.Microsoft.OData.Client.DataServiceContext\r\n");


    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(" object.\r\n        \'\'\' </summary>\r\n        <Global.System.CodeDom.Compiler.Generat" +
        "edCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Sub New(ByVal serviceRoot As Global.System.Uri)\r\n         " +
        "   MyBase.New(serviceRoot, Global.Microsoft.OData.Client.ODataProtocolVersion.V4" +
        ")\r\n");


    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {

this.Write("            Me.UrlKeyDelimiter = Global.Microsoft.OData.Client.DataServiceUrlKeyD" +
        "elimiter.Slash\r\n");


    }

    internal override void WriteInitializeResolveName()
    {

this.Write("            Me.ResolveName = AddressOf Me.ResolveNameFromType\r\n");


    }

    internal override void WriteInitializeResolveType()
    {

this.Write("            Me.ResolveType = AddressOf Me.ResolveTypeFromName\r\n");


    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {

this.Write("            Me.OnContextCreated\r\n            Me.Format.LoadServiceModel = Address" +
        "Of GeneratedEdmModel.GetInstance\r\n            Me.Format.UseJson()\r\n        End S" +
        "ub\r\n        Partial Private Sub OnContextCreated()\r\n        End Sub\r\n");


    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {

this.Write(@"        ''' <summary>
        ''' Since the namespace configured for this service reference
        ''' in Visual Studio is different from the one indicated in the
        ''' server schema, use type-mappers to map between the two.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Protected Function ResolveTypeFromName(ByVal typeName As String) " +
        "As Global.System.Type\r\n");


    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {
        if (!string.IsNullOrEmpty(typeName))
        {

this.Write("            Dim resolvedType As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("= Me.DefaultResolveType(typeName, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\", String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"))\r\n");


        }
        else
        {

this.Write("            resolvedType = Me.DefaultResolveType(typeName, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\", String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"))\r\n");


        }

this.Write("            If (Not (resolvedType) Is Nothing) Then\r\n                Return resol" +
        "vedType\r\n            End If\r\n");


    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {

this.Write("            Return Nothing\r\n        End Function\r\n");


    }

    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private Shared ROOTNAMESPACE As String = GetType(");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(").Namespace.Remove(GetType(");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(").Namespace.LastIndexOf(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\"))\r\n");


    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {

this.Write(@"        ''' <summary>
        ''' Since the namespace configured for this service reference
        ''' in Visual Studio is different from the one indicated in the
        ''' server schema, use type-mappers to map between the two.
        ''' </summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Protected Function ResolveNameFromType(ByVal clientType As Global" +
        ".System.Type) As String\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write(@"            Dim originalNameAttribute As Global.Microsoft.OData.Client.OriginalNameAttribute =
                CType(Global.System.Linq.Enumerable.SingleOrDefault(Global.Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, GetType(Global.Microsoft.OData.Client.OriginalNameAttribute), true)), Global.Microsoft.OData.Client.OriginalNameAttribute)
");


    }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {

this.Write("            If clientType.Namespace.Equals(String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"), Global.System.StringComparison.OrdinalIgnoreCase) Then\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("                If (Not (originalNameAttribute) Is Nothing) Then\r\n               " +
        "     Return String.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", originalNameAttribute.OriginalName)\r\n                End If\r\n");


        }

this.Write("                Return String.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", clientType.Name)\r\n            End If\r\n");


    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {

this.Write(@"            If (Not (originalNameAttribute) Is Nothing) Then
                Dim fullName As String = clientType.FullName.Substring(ROOTNAMESPACE.Length)
                Return fullName.Remove(fullName.LastIndexOf(clientType.Name)) + originalNameAttribute.OriginalName
            End If
");


        }

this.Write("            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(modelHasInheritance ? "clientType.FullName.Substring(ROOTNAMESPACE.Length)" : "Nothing"));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(@" object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String)
            MyBase.New(context, path)
        End Sub

        ''' <summary>
        ''' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(@" object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String, ByVal isComposable As Boolean)
            MyBase.New(context, path, isComposable)
        End Sub

        ''' <summary>
        ''' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(" object.\r\n        \'\'\' </summary>\r\n        Public Sub New(ByVal query As ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(")\r\n            MyBase.New(query)\r\n        End Sub\r\n");


    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {entitySetName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable ReadOnly Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetFixedName));

this.Write("() As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")\r\n            Get\r\n");


        if (!inContext)
        {

this.Write("                If Not Me.IsComposable Then\r\n                    Throw New Global" +
        ".System.NotSupportedException(\"The previous function is not composable.\")\r\n     " +
        "           End If\r\n");


        }

this.Write("                If (Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" Is Nothing) Then\r\n                    Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "MyBase" : "Context"));

this.Write(".CreateQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")"));

this.Write(")\r\n                End If\r\n                Return Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("\r\n            End Get\r\n        End Property\r\n        <Global.System.CodeDom.Compi" +
        "ler.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private _");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")\r\n");


    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, string description, IDictionary<string, string> revisionAnnotations, bool inContext)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {singletonName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalSingletonName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable ReadOnly Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonFixedName));

this.Write("() As ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("\r\n            Get\r\n");


        if (!inContext)
        {

this.Write("                If Not Me.IsComposable Then\r\n                    Throw New Global" +
        ".System.NotSupportedException(\"The previous function is not composable.\")\r\n     " +
        "           End If\r\n");


        }

this.Write("                If (Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" Is Nothing) Then\r\n                    Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" = New ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "Me" : "Me.Context"));

this.Write(", ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")"));

this.Write(")\r\n                End If\r\n                Return Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write("\r\n            End Get\r\n        End Property\r\n        <Global.System.CodeDom.Compi" +
        "ler.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private _");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("\r\n");


    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {
        WriteDescriptionSummary($"There are no comments for {entitySetName} in the schema.");

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Overridable Sub AddTo");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("(ByVal ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(")\r\n            MyBase.AddObject(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(")\r\n        End Sub\r\n");


    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {
        string path = this.context.MetadataFilePath;
        string relativePath = this.context.MetadataFileRelativePath;
        if(!String.IsNullOrEmpty(path))
        {
            using (StreamWriter writer = new StreamWriter(path, false))
            {
                writer.WriteLine(escapedEdmxString);
            }
        }

        bool useTempFile = !String.IsNullOrEmpty(path) && System.IO.File.Exists(path);

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private MustInherit Class GeneratedEdmModel\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared ReferencesMap As Global.System.Collections.Gen" +
        "eric.Dictionary(Of String, String) = New Global.System.Collections.Generic.Dicti" +
        "onary(Of String, String) From\r\n                {\r\n");


            int count = this.context.ReferencesMap.Count();
            foreach(var reference in this.context.ReferencesMap)
            {

this.Write("                    {\"");

this.Write(this.ToStringHelper.ToStringWithCulture(reference.Key.OriginalString.Replace("\"", "\"\"")));

this.Write("\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(Utils.SerializeToString(reference.Value).Replace("\"", "\"\"").Replace("\r\n", "\" & _\r\n \"")));

this.Write("\"}");

this.Write(this.ToStringHelper.ToStringWithCulture((--count>0?",":"")));

this.Write("\r\n");


            }

this.Write("                }\r\n");


        }

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared ParsedModel As Global.Microsoft.OData.Edm.IEdm" +
        "Model = LoadModelFromString\r\n");


            if (useTempFile)
            {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Const filePath As String = \"");

this.Write(this.ToStringHelper.ToStringWithCulture(relativePath));

this.Write("\"\r\n");


            }
            else
            {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Const Edmx As String = \"");

this.Write(this.ToStringHelper.ToStringWithCulture(escapedEdmxString));

this.Write("\"\r\n");


            }

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Public Shared Function GetInstance() As Global.Microsoft.ODat" +
        "a.Edm.IEdmModel\r\n                Return ParsedModel\r\n            End Function\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function getReferencedModelFromMap(ByVal uri As Global.System.Uri) As Global.System.Xml.XmlReader
                Dim referencedEdmx As String = Nothing
                If (ReferencesMap.TryGetValue(uri.OriginalString, referencedEdmx)) Then
                    Return CreateXmlReader(referencedEdmx)
                End If
                Return Nothing
            End Function
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared Function LoadModelFromString() As Global.Micro" +
        "soft.OData.Edm.IEdmModel\r\n");


                if (useTempFile)
                {

this.Write("                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader()\r\n");


                }
                else
                {

this.Write("                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)" +
        "\r\n");


                }

this.Write(@"                Try
                    Return Global.Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, AddressOf getReferencedModelFromMap)
                Finally
                    CType(reader,Global.System.IDisposable).Dispose
                End Try
            End Function
");


        }
        else
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared Function LoadModelFromString() As Global.Micro" +
        "soft.OData.Edm.IEdmModel\r\n");


                if (useTempFile)
                {

this.Write("                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader()\r\n");


                }
                else
                {

this.Write("                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)" +
        "\r\n");


                }

this.Write(@"                Try
                    Dim errors As Global.System.Collections.Generic.IEnumerable(Of Global.Microsoft.OData.Edm.Validation.EdmError) = Nothing
                    Dim edmModel As Global.Microsoft.OData.Edm.IEdmModel = Nothing
                    If Not Global.Microsoft.OData.Edm.Csdl.CsdlReader.TryParse(reader, ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.context.IgnoreUnexpectedElementsAndAttributes ? "True" : "False"));

this.Write(@", edmModel, errors) Then
                        Dim errorMessages As Global.System.Text.StringBuilder = New Global.System.Text.StringBuilder()
                        For Each err As Global.Microsoft.OData.Edm.Validation.EdmError In errors
                            errorMessages.Append(err.ErrorMessage)
                            errorMessages.Append(""; "")
                        Next
                        Throw New Global.System.InvalidOperationException(errorMessages.ToString())
                    End If

                    Return edmModel
                Finally
                    CType(reader, Global.System.IDisposable).Dispose()
                End Try
            End Function
");


        }

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared Function CreateXmlReader(ByVal edmxToParse As " +
        "String) As Global.System.Xml.XmlReader\r\n                Return Global.System.Xml" +
        ".XmlReader.Create(New Global.System.IO.StringReader(edmxToParse))\r\n            E" +
        "nd Function\r\n");


        if (useTempFile)
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function CreateXmlReader() As Global.System.Xml.XmlReader
                Try
                    Dim assembly As Global.System.Reflection.Assembly = Global.System.Reflection.Assembly.GetExecutingAssembly()
                    Dim resourcePath As Global.System.String = Global.System.Linq.Enumerable.Single(assembly.GetManifestResourceNames(), Function(str) str.EndsWith(filePath))
                    Dim stream As Global.System.IO.Stream = assembly.GetManifestResourceStream(resourcePath)
                    Return Global.System.Xml.XmlReader.Create(New Global.System.IO.StreamReader(stream))
                Catch e As Global.System.Xml.XmlException
                    Throw New Global.System.Xml.XmlException(""Failed to create an XmlReader from the stream. Check if the resource exists."", e)
                End Try
            End Function
");


        }

this.Write("        End Class\r\n");


    }

    internal override void WriteClassEndForEntityContainer()
    {

this.Write("    End Class\r\n");


    }

    internal override void WriteSummaryCommentForStructuredType(string typeName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {typeName} in the schema." : description, true);
    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {

this.Write("    \'\'\' <KeyProperties>\r\n");


        foreach (string key in keyProperties)
        {

this.Write("    \'\'\' ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\r\n");


        }

this.Write("    \'\'\' </KeyProperties>\r\n    <Global.Microsoft.OData.Client.Key(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(keyString));

this.Write("\")>  _\r\n");


    }

    internal override void WriteEntityTypeAttribute()
    {

this.Write("    <Global.Microsoft.OData.Client.EntityType()>  _\r\n");


    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {

this.Write("    <Global.Microsoft.OData.Client.EntitySet(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("\")>  _\r\n");


    }

    internal override void WriteEntityHasStreamAttribute()
    {

this.Write("    <Global.Microsoft.OData.Client.HasStream()>  _\r\n");


    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
    {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalTypeName));

this.Write("\")>  _\r\n");


        }

this.Write("    Partial ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(this.ToStringHelper.ToStringWithCulture(abstractModifier));

this.Write(" Class ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write("\r\n");


    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Create a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" object.\r\n        \'\'\' </summary>\r\n");


    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {

this.Write("        \'\'\' <param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\">Initial value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(".</param>\r\n");


    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Shared Function Create");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("(");



    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {

this.Write("ByVal ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(parameterSeparater));


    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {
          
this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("\r\n            Dim ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" = New ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("()\r\n");


    }

    internal override void  WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {

this.Write("            If (");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" Is Nothing) Then\r\n                Throw New Global.System.ArgumentNullException(" +
        "\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\")\r\n            End If\r\n");


    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {

this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\r\n");


    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {

this.Write("            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WritePropertyForStructuredType(PropertyOptions propertyOptions)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(propertyOptions.PropertyDescription) ? $"There are no comments for Property {propertyOptions.PropertyName} in the schema." : propertyOptions.PropertyDescription);
        WriteObsoleteAttribute(propertyOptions.RevisionAnnotations);

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(propertyOptions.OriginalPropertyName))
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.OriginalPropertyName));

this.Write("\")>  _\r\n");


        }

        if (propertyOptions.PropertyMaxLength != null)
        {
            WriteStringLengthAttribute((int)propertyOptions.PropertyMaxLength, $"{propertyOptions.PropertyName} cannot be longer than {propertyOptions.PropertyMaxLength} characters.");
        }

        if (!propertyOptions.IsNullable)
        {
            WriteRequiredAttribute($"{propertyOptions.PropertyName} is required.");
        }


        if (!string.IsNullOrEmpty(propertyOptions.PropertyAttribute))
        {

this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyAttribute));

this.Write("  _\r\n");


        }

this.Write("        Public Overridable Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.FixedPropertyName));

this.Write("() As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write("\r\n            Get\r\n                Return Me.");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write("\r\n            End Get\r\n            Set\r\n                Me.On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changing(value)\r\n                Me.");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write(" = value\r\n                Me.On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changed\r\n");


        if (propertyOptions.WriteOnPropertyChanged)
        {

this.Write("                Me.OnPropertyChanged(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.OriginalPropertyName));

this.Write("\")\r\n");


        }

this.Write("            End Set\r\n        End Property\r\n        <Global.System.CodeDom.Compile" +
        "r.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        string constructorString = string.Empty;
        if (!string.IsNullOrEmpty(propertyOptions.PropertyInitializationValue))
        {
            constructorString = " = " + propertyOptions.PropertyInitializationValue;
        }

this.Write("        Private ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PrivatePropertyName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write(this.ToStringHelper.ToStringWithCulture(constructorString));

this.Write("\r\n        Partial Private Sub On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changing(ByVal value As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyType));

this.Write(")\r\n        End Sub\r\n        Partial Private Sub On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyOptions.PropertyName));

this.Write("Changed()\r\n        End Sub\r\n");


    }

    internal override void WriteINotifyPropertyChangedImplementation()
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' This event is raised when the value of the pro" +
        "perty is changed\r\n        \'\'\' </summary>\r\n        <Global.System.CodeDom.Compile" +
        "r.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
        Public Event PropertyChanged As Global.System.ComponentModel.PropertyChangedEventHandler Implements Global.System.ComponentModel.INotifyPropertyChanged.PropertyChanged
        ''' <summary>
        ''' The value of the property is changed
        ''' </summary>
        ''' <param name=""property"">property name</param>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
        Protected Overridable Sub OnPropertyChanged(ByVal [property] As String)
            If (Not (Me.PropertyChangedEvent) Is Nothing) Then
                RaiseEvent PropertyChanged(Me, New Global.System.ComponentModel.PropertyChangedEventArgs([property]))
            End If
        End Sub
");


    }

    internal override void WriteClassEndForStructuredType()
    {

this.Write("    End Class\r\n");


    }

    internal override void WriteEnumFlags()
    {

this.Write("    <Global.System.Flags()>\r\n");


    }

    internal override void WriteSummaryCommentForEnumType(string enumName, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {enumName} in the schema." : description, true);
    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
    {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEnumName));

this.Write("\")>  _\r\n");


        }

this.Write("    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" Enum ");

this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

this.Write(this.ToStringHelper.ToStringWithCulture(underlyingType));

this.Write("\r\n");


    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalMemberName));

this.Write("\")>  _\r\n");


        }

this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(member));

this.Write("\r\n");


    }

    internal override void WriteEnumEnd()
    {

this.Write("    End Enum\r\n");


    }

    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return Me.CreateFunctionQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"\", \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("Me.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(\"\", \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Dim requestUri As Global.System.Uri = Nothing\r\n            Context" +
        ".TryGetUri(Me, requestUri)\r\n            Return Me.Context.CreateFunctionQuery(Of" +
        " ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"\", String.Join(\"/\", Global.System.Linq.Enumerable.Select(Global.System.Linq.En" +
        "umerable.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function" +
        "(s) s.Trim(\"/\"C))) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            Dim requestUri As Global.System.Uri = Nothing\r\n            Context." +
        "TryGetUri(Me, requestUri)\r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("Me.Context.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(String.Join(\"/\", Global.System.Linq.Enumerable.Select(Global.System.Linq.Enumer" +
        "able.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function(s) " +
        "s.Trim(\"/\"C))), \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(Me, Me.BaseUri.OriginalString.Trim(\"/\"C) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description, IDictionary<string, string> revisionAnnotations)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);
        WriteObsoleteAttribute(revisionAnnotations);
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Overridable ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(@"
            Dim resource As Global.Microsoft.OData.Client.EntityDescriptor = Context.EntityTracker.TryGetEntityDescriptor(Me)
            If resource Is Nothing Then
                Throw New Global.System.Exception(""cannot find entity"")
            End If

            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(Me.Context, resource.EditLink.OriginalString.Trim(\"/\"C) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteExtensionMethodsStart()
    {

this.Write("    \'\'\' <summary>\r\n    \'\'\' Class containing all extension methods\r\n    \'\'\' </summ" +
        "ary>\r\n    ");

this.Write(this.ToStringHelper.ToStringWithCulture(ClassAccessModifier));

this.Write(" Module ExtensionMethods\r\n");


    }

    internal override void WriteExtensionMethodsEnd()
    {

this.Write("    End Module\r\n");


    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(@" specified by key from an entity set
        ''' </summary>
        ''' <param name=""_source"">source entity set</param>
        ''' <param name=""_keys"">dictionary with the names and values of keys</param>
        <Global.System.Runtime.CompilerServices.Extension()>
        Public Function ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("), ByVal _keys As Global.System.Collections.Generic.IDictionary(Of String, Object" +
        ")) As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.Get" +
        "KeyString(_source.Context, _keys)))\r\n        End Function\r\n        \'\'\' <summary>" +
        "\r\n        \'\'\' Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" specified by key from an entity set\r\n        \'\'\' </summary>\r\n        \'\'\' <param " +
        "name=\"_source\">source entity set</param>\r\n");


        foreach (var key in keys)
        {

this.Write("        \'\'\' <param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\">The value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("</param>\r\n");


        }

this.Write("        <Global.System.Runtime.CompilerServices.Extension()>\r\n        Public Func" +
        "tion ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("),\r\n            ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyParameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Dim _keys As Global.System.Collections.Generic.IDictionary(Of Strin" +
        "g, Object) = New Global.System.Collections.Generic.Dictionary(Of String, Object)" +
        "() From\r\n            {\r\n                ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyDictionaryItems));

this.Write("\r\n            }\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.Get" +
        "KeyString(_source.Context, _keys)))\r\n        End Function\r\n");


    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Cast an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(" to its derived type ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write("\r\n        \'\'\' </summary>\r\n        \'\'\' <param name=\"_source\">source entity</param>" +
        "\r\n        <Global.System.Runtime.CompilerServices.Extension()>\r\n        Public F" +
        "unction CastTo");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeName));

this.Write("(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuerySingle(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(")) As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Dim query As Global.Microsoft.OData.Client.DataServiceQuerySingle(O" +
        "f ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write(") = _source.CastTo(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write(")()\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, query.GetPath(Nothing))\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);

this.Write("        <Global.System.Runtime.CompilerServices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(CultureInfo.InvariantCulture, this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            If Not _source.IsComposable Then\r\n                Throw New Global." +
        "System.NotSupportedException(\"The previous function is not composable.\")\r\n      " +
        "      End If\r\n\r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("_source.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {functionName} in the schema." : description);

this.Write("        <Global.System.Runtime.CompilerServices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            If Not _source.IsComposable Then\r\n                Throw New Global" +
        ".System.NotSupportedException(\"The previous function is not composable.\")\r\n     " +
        "       End If\r\n\r\n            Return _source.CreateFunctionQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues, string description)
    {
        WriteDescriptionSummary(string.IsNullOrWhiteSpace(description) ? $"There are no comments for {actionName} in the schema." : description);

this.Write("        <Global.System.Runtime.CompilerServices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            If Not _source.IsComposable Then\r\n                Throw New Global." +
        "System.NotSupportedException(\"The previous function is not composable.\")\r\n      " +
        "      End If\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.AppendRequestUri(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }

    protected override void WriteDescriptionSummary(string description, bool isClass = false)
    {
        if (isClass)
        {

this.Write("    \'\'\' <summary>\r\n    \'\'\' ");

this.Write(this.ToStringHelper.ToStringWithCulture(description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n    \'\'\'")));

this.Write("\r\n    \'\'\' </summary>\r\n");


        }
        else
        {

this.Write("        \'\'\' <summary>\r\n        \'\'\' ");

this.Write(this.ToStringHelper.ToStringWithCulture(description.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n        \'\'\'")));

this.Write("\r\n        \'\'\' </summary>\r\n");


        }
    }

    protected override void WriteObsoleteAttribute(IDictionary<string, string> revisionAnnotations, bool isClass = false)
    {
        if (!revisionAnnotations.TryGetValue(deprecated, out string revisionDescription))
        {
           return;
        }

        if (isClass)
        {

this.Write("    <Global.System.ObsoleteAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(revisionDescription));

this.Write("\")>  _\r\n");


        }
        else
        {

this.Write("        <Global.System.ObsoleteAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(revisionDescription));

this.Write("\")>  _\r\n");


        }
    }

    protected override void WriteStringLengthAttribute(int maxLength, string errorMessage)
    {

this.Write("        <Global.System.ComponentModel.DataAnnotations.StringLengthAttribute(");

this.Write(this.ToStringHelper.ToStringWithCulture(maxLength));

this.Write(")>  _\r\n");


    }

    protected override void WriteRequiredAttribute(string errorMessage)
    {

this.Write("        <Global.System.ComponentModel.DataAnnotations.RequiredAttribute()>  _\r\n");


    }

    internal override void WriteNamespaceEnd()
    {

this.Write("End Namespace\r\n");


    }
}


/// <summary>
/// Creates an instance of the FilesManager. The object used to generate and manage
/// multiple source files.
/// </summary>
/// <param name="context">The code generation context.</param>
public class FilesManager {

    /// <summary>
    /// Creates an instance of the FilesManager. The object used to generate and manage
    /// multiple source files.
    /// </summary>
    private class Block {

        /// <summary> Name of the block.</summary>
        public string Name;

        /// <summary> The line in the template from which the block starts.</summary>
        public int Start;

        /// <summary> Length of the block.</summary>
        public int Length;

         /// <summary> Block currently being processed.</summary>
        public bool IsContainer;
    }

    /// <summary> Block currently being processed.</summary>
    private Block _currentBlock;

    /// <summary> A list of all the blocks of texts to be used to generate multiple files.</summary>
    private List<Block> _files = new List<Block>();

    /// <summary> A block describing the footer of all files.</summary>
    private Block _footer = new Block();

    /// <summary> A block describing the header of all files.</summary>
    private Block _header = new Block();

    /// <summary> A list of file names to be generated.</summary>
    protected List<String> _generatedFileNames = new List<String>();

    /// <summary> Contains generated text.</summary>
    public StringBuilder Template
        {
            get;
            set;
        }

    /// <summary>
    /// Marks the start of a new file.
    /// </summary>
    public void StartNewFile(string name, bool isContainer)
    {
        if (name == null)
        {
                throw new ArgumentNullException("name");
        }

        CurrentBlock = new Block { Name = name, IsContainer =  isContainer};
    }

    /// <summary>
    /// Marks the start of the footer for all files.
    /// </summary>
    public void StartFooter()
    {
        CurrentBlock = _footer;
    }

    /// <summary>
    /// Marks the start of the header for all files.
    /// </summary>
    public void StartHeader()
    {
        CurrentBlock = _header;
    }


    /// <summary>
    /// Marks the End of a file.
    /// </summary>
    public void EndBlock()
    {
        if (CurrentBlock == null)
        {
            return;
        }

        CurrentBlock.Length = Template.Length - CurrentBlock.Start;

        if (CurrentBlock != _header && CurrentBlock != _footer)
        {
            _files.Add(CurrentBlock);
        }

        _currentBlock = null;
    }

    /// <summary>
    /// Generated multiple files depending on the number of blocks.
    /// </summary>
    /// <param name="split">If true the function is executed and multiple files generated
    /// otherwise only a single file is generated.</param>
    [SecurityCritical]
    public virtual void GenerateFiles(bool split, IFileHandler handlerHelper, IMessageLogger logger, string referenceFolder, bool fileCreated, bool OpenGeneratedFilesInIDE)
    {
        if (split)
        {
            EndBlock();
            string headerText = Template.ToString(_header.Start, _header.Length);
            string footerText = Template.ToString(_footer.Start, _footer.Length);
            string outputPath ="";

            outputPath = Path.GetTempPath();
            
            _files.Reverse();

            foreach(Block block in _files)
            {
                if(block.IsContainer) continue;
                string fileName = Path.Combine(outputPath, block.Name);

                if(fileCreated)
                {
                    string outputFile = Path.Combine(referenceFolder, block.Name);
                    bool fileExists = File.Exists(outputFile);
                    handlerHelper.AddFileAsync(fileName, outputFile, new ODataFileOptions { OpenOnComplete = OpenGeneratedFilesInIDE, SuppressOverwritePrompt = true }).ContinueWith(
                        async _ =>
                        {
                            await logger?.WriteMessageAsync(LogMessageCategory.Information,
                                "\"{0}\" has been {1}.", new FileInfo(fileName).Name, fileExists ? "updated" : "added");
                        }, System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously);
                }
                else
                {
                    string content = headerText + Template.ToString(block.Start, block.Length) + footerText;
                    _generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    Template.Remove(block.Start, block.Length);
                }
            }
        }
    }

    /// <summary>
    ///Creates a file with the name <paramref name="fileName"> and content <paramref name="content">.
    /// </summary>
    /// <param name="fileName">Name of the file to be created</param>
    /// <param name="content">Content of the file to be created</param>
    protected virtual void CreateFile(string fileName, string content)
    {
        if (IsFileContentDifferent(fileName, content))
        {
                 File.WriteAllText(fileName, content);
        }           
    }

    public virtual string GetCustomToolNamespace(string fileName)
    {
        return null;
    }

    public virtual string DefaultProjectNamespace
    {
        get
        {
            return null;
        }
    }

    /// <summary>
    /// checks if the generated content is different from the existing content.
    /// </summary>
    /// <param name="fileName">Name of the existing file</param>
    /// <param name="newContent">Content of existing file</param>
    /// <returns>true if the file content is different</returns>
    protected bool IsFileContentDifferent(string fileName, string newContent)
    {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    /// <summary>
    /// FilesManager constructor. Initializes the template variable.
    /// </summary>
    public FilesManager(StringBuilder template)
    {
        Template = template;
    }

    private Block CurrentBlock
    {
        get
        {
            return _currentBlock;
        }
        set
        {
            if (CurrentBlock != null)
            {
                EndBlock();
            }

            if (value != null)
            {
                value.Start = Template.Length;
            }
            _currentBlock = value;
        }
    }

    private class VSManager : FilesManager {

    /// <summary>
    ///Creates a file with the name <paramref name="fileName"> and content <paramref name="content">.
    /// </summary>
    /// <param name="fileName">Name of the file to be created</param>
    /// <param name="content">Content of the file to be created</param>
    protected override void CreateFile(string fileName, string content)
    {
        if (IsFileContentDifferent(fileName, content))
        {
            File.WriteAllText(fileName, content);
        }
    }

    /// <summary>
    /// Generates multiple files depending on the number of blocks.
    /// </summary>
    /// <param name="split">If true the function is executed and multiple files generated
    /// otherwise only a single file is generated.</param>
    [SecurityCritical]
    public override void GenerateFiles(bool split, IFileHandler handlerHelper, IMessageLogger logger, string referenceFolder, bool fileCreated, bool OpenGeneratedFilesInIDE) 
    {
        base.GenerateFiles(split, handlerHelper, logger, referenceFolder, fileCreated, OpenGeneratedFilesInIDE);
    }

    /// <summary>
    /// VSManager constructor. Initializes the template variable.
    /// </summary>
    internal VSManager(StringBuilder template)
        : base(template)
    {
    }
    }
} 
    }
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class ODataT4CodeGeneratorBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
